<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="ruanpapa和又吉君写字的地方">
<meta property="og:type" content="website">
<meta property="og:title" content="ruanpapa和又吉君写字的地方">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="ruanpapa和又吉君写字的地方">
<meta property="og:description" content="ruanpapa和又吉君写字的地方">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ruanpapa和又吉君写字的地方">
<meta name="twitter:description" content="ruanpapa和又吉君写字的地方">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> ruanpapa和又吉君写字的地方 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">ruanpapa和又吉君写字的地方</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/22/Clang之旅-添加自定义的attribute/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="ruanpapa & 又吉君">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="ruanpapa和又吉君写字的地方">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="ruanpapa和又吉君写字的地方" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/22/Clang之旅-添加自定义的attribute/" itemprop="url">
                  Clang 之旅—[翻译]添加自定义的 attribute
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-22T11:05:35+08:00">
                2018-03-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ruanpapa-技术贴/" itemprop="url" rel="index">
                    <span itemprop="name">ruanpapa--技术贴</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/22/Clang之旅-添加自定义的attribute/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/03/22/Clang之旅-添加自定义的attribute/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/03/22/Clang之旅-添加自定义的attribute/" class="leancloud_visitors" data-flag-title="Clang 之旅—[翻译]添加自定义的 attribute">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是 Clang 之旅系列的第二篇，自己想要完成的需求是：在编译阶段检查某个方法的参数与返回值的类型相同，如果类型不一致的话能抛出编译错误的提示。需要接触到 Clang 中关于 attribute 处理的代码，所以这篇先来翻译<a href="https://clang.llvm.org/docs/InternalsManual.html#how-to-add-an-attribute" target="_blank" rel="external">官方文档</a>中添加自定义的 attribute 这一节，不得不说，虽然 Clang 的文档可以说是很标杆了，但是总有一种看了后面忘了前面的感觉，可能是 Clang 比较庞大，涉及专有词汇比较多的原因，所以我会偏向意译多一点，试图用更加易懂的表达组织语言，也是加深自己的记忆吧。</p>
<p>Clang 之旅系列文章：<br><a href="https://www.jianshu.com/p/e3f46d42643b" target="_blank" rel="external">Clang 之旅–使用 Xcode 开发 Clang 插件</a><br><a href="https://www.jianshu.com/p/d277c42f4907" target="_blank" rel="external">Clang 之旅—[翻译]添加自定义的 attribute</a></p>
<h2 id="怎样添加-attribute"><a href="#怎样添加-attribute" class="headerlink" title="怎样添加 attribute"></a>怎样添加 attribute</h2><p>attribute 是一种可以附加到程序结构中的数据形式，允许开发人员传递信息给编译器来实现各种需求。例如，attribute 可以用来改变在程序构造时生成的代码，或者用来提供额外的信息给静态分析。本文档讲解如何添加一个自定义的 attribute 到 Clang 中。现有 attribute 列表的文档可以在<a href="https://clang.llvm.org/docs/AttributeReference.html" target="_blank" rel="external">这里</a>找到。</p>
<h3 id="attribute-基础知识"><a href="#attribute-基础知识" class="headerlink" title="attribute 基础知识"></a>attribute 基础知识</h3><p>Clang 中的 attribute 涉及到三个阶段：解析 attribute 、从已解析的 attribute 转换成语法树上的 attribute、对 attribute 进行处理。</p>
<p>attribute 的解析可以采用多种语法形式，例如 GNU、C++ 11 和 Microsoft 形式，还由 attribute 提供的其他信息来确定。最终，解析好的 attribute 用一个 <code>AttributeList</code> 对象来表示。这些解析好的 attribute 会链成一个 attribute 链，加到声明或者定义上。attribtue 的解析是由 Clang 自动完成的，除了那些关键字 attribute。关键字的解析和 <code>AttributeList</code> 对象的生成必须由我们手动完成。</p>
<p>最后，<code>Sema::ProcessDeclAttributeList()</code> 带着 <code>Decl</code> 类型和 <code>AttributeList</code> 类型的参数被调用，此时解析好的 attribute 就会被转化成语法树上的 attribute。这个处理依赖于 attribute 的属性定义和语义要求。最后的结果就是语法树上的 attribute 对象可以从 <code>Decl</code> 对象获取到，也就是通过调用 <code>Decl::getAttr&lt;T&gt;()</code> 来获取。</p>
<p>语法树上的 attribute 的结构同样也受到 Attr.td 文件中的定义所限制。这个定义会自动生成 attribute 的实现所用到的功能，包括生成 <code>clang::Attr</code> 的子类、解析器所用到的信息和某些 attribute 自动进行的语义分析等等。</p>
<h3 id="include-clang-Basic-Attr-td"><a href="#include-clang-Basic-Attr-td" class="headerlink" title="include/clang/Basic/Attr.td"></a>include/clang/Basic/Attr.td</h3><p>添加新的 attribute 到 Clang 的第一个步骤就是把其定义添加到 <a href="http://llvm.org/viewvc/llvm-project/cfe/trunk/include/clang/Basic/Attr.td?view=markup" target="_blank" rel="external">include/clang/Basic/Attr.td</a>。这个定义必须从 <code>Attr</code> 或者其子类继承。大多数 attribute 会直接从 <code>InheritableAttr</code> 继承，<code>InheritableAttr</code> 指定了这个 attribute 可以通过它所关联的 <code>Decl</code> 稍后进行重声明。如果这个 attribute 是作用于类型而不是声明，那么这种 attribute 应该从 <code>TypeAttr</code> 派生，并且通常不会被赋予 AST 表示（注意本文档并不讲解生成类型所用的 attribute）。一个继承于 <code>IgnoredAttr</code> 的 attribute 会被解析，但是会在被使用的时候产生一个 “被忽略的属性” 的警告，这种处理方法在某个属性支持别的前端而不支持 Clang 的情况下是很有用的。</p>
<p>这个定义能指定 attribute 的一些关键部分，比如 attribute 的名字、attribute 支持的拼写、attribute 的参数等等。<code>Attr</code> 类型中的大多数成员变量都不需要派生定义，缺省的就足够了。但是，每个 attribute 都需要至少指定 拼写列表、subject 列表和文档列表。</p>
<h5 id="拼写"><a href="#拼写" class="headerlink" title="拼写"></a>拼写</h5><p>所有 attribute 都需要指定一个拼写列表，表示拼写 attribute 的方式。比如某个 attribute 可能会包含关键字拼写， C++11 拼写和 GNU 拼写。空的拼写列表也是允许的并且可能对隐式创建的 attribute 有用。以下是支持的拼写的表格：</p>
<table>
<thead>
<tr>
<th style="text-align:left">拼写</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GNU</td>
<td style="text-align:left">用 GNU 风格 <code>__attribute__((attr))</code> 语法和位置拼写</td>
</tr>
<tr>
<td style="text-align:left">CXX11</td>
<td style="text-align:left">用 C++ 风格 <code>[[attr]]</code> 语法拼写。如果该 attribute 是由 Clang 所使用的，那么应该设置命名空间为 <code>&quot;clang&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">Declspec</td>
<td style="text-align:left">用 Microsoft 风格 <code>__declspec(attr)</code> 语法拼写</td>
</tr>
<tr>
<td style="text-align:left">Keyword</td>
<td style="text-align:left">这个 attribute 用关键字的方式拼写，并且需要自定义解析</td>
</tr>
<tr>
<td style="text-align:left">GCC</td>
<td style="text-align:left">指定两种拼写：首先是 GNU 风格拼写；然后是 C++ 风格拼写，命名空间为 <code>gnu</code>。只能为支持 GCC 的 attribute 指定这个拼写。</td>
</tr>
<tr>
<td style="text-align:left">Pragma</td>
<td style="text-align:left">attribute 用 <code>#pragma</code> 的形式拼写，并且需要在预处理器中执行自定义的处理。如果该 attribute 是由 Clang 所使用的，那么应该设置命名空间为 <code>&quot;clang&quot;</code>。需要注意这个拼写并不能被用于声明语句中。</td>
</tr>
</tbody>
</table>
<h5 id="Subjects"><a href="#Subjects" class="headerlink" title="Subjects"></a>Subjects</h5><p>每个 attribute 都有一个或者多个 subject。如果 attribute 被使用到了一个不在 subject 列表上的 subject，就会自动显示诊断信息。 这个信息是警告还是错误是由 attribute 中的 <code>SubjectList</code> 决定的，默认的是警告。显示给用户的诊断信息将根据 subject 列表自动确定，但是也可以在 <code>SubjectList</code> 中指定自定义诊断参数。不符合 subject 列表导致的诊断信息要么是 <code>diag::warn_attribute_wrong_decl_type</code>，要么是 <code>diag::err_attribute_wrong_decl_type</code>。具体参数的枚举值可以从 <a href="http://llvm.org/viewvc/llvm-project/cfe/trunk/include/clang/Sema/AttributeList.h?view=markup" target="_blank" rel="external">include/clang/Sema/AttributeList.h</a> 找到。如果先前未使用的 <code>Decl</code> 节点被添加到 <code>SubjectList</code> 中，则可能需要更新用于自动确定 <a href="http://llvm.org/viewvc/llvm-project/cfe/trunk/utils/TableGen/ClangAttrEmitter.cpp?view=markup" target="_blank" rel="external">utils/TableGen/ClangAttrEmitter.cpp</a> 中的诊断参数的逻辑。</p>
<p>所有在 SubjectList 中的 subject 要么是在 <code>DeclNodes.td</code> 中定义的 Decl 节点，要么就是在 <code>StmtNodes.td</code> 中定义的 statement 节点。不过，可以生成 <code>SubsetSubject</code> 对象来创建更加复杂的 subject。每个这样的对象都有一个它所属的基本对象（必须是一个 Decl 或 Stmt 节点，而不是一个 SubsetSubject 节点），还有一些自定义代码在确定某个 attribute 是否属于该对象时被调用。例如，一个 <code>NonBitField</code> SubsetSubject 关联到 <code>FieldDecl</code> 类，同时会测试给定的 FieldDecl 是否是一个位字段。当在 SubjectList 中指定了一个 SubsetSubject 时必须同时提供一个自定义的诊断信息参数。</p>
<p>attribute 的 subject 列表会在 <code>HasCustomParsing</code> 设为 <code>1</code> 的情况下自动进行诊断检查。</p>
<h5 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h5><p>所有的 attribute 都必须具有某种形式的文档。文档是通过每天运行的服务器端进程在公共服务器上生成的。通常来说，attribute 的文档是在 <a href="http://llvm.org/viewvc/llvm-project/cfe/trunk/include/clang/Basic/AttdDocs.td?view=markup" target="_blank" rel="external">include/clang/Basic/AttrDocs.td</a> 中单独定义的，以文档属性命名。</p>
<p>如果 attribute 不是通用的，或者是隐式创建的没有对应拼写的 attribuet，则可以将文档列表变量设置为 <code>Undocumented</code>。否则，该 attribute 应将其文档添加到 AttrDocs.td。</p>
<p>文档属性是从 <code>Documentation</code> tablegen 类型继承而来的，所有的派生类型都必须创建一个文档类别和设置文档本身内容。此外，它还可以为 attribute 指定一个自定义的标题，否则会选择默认的标题。</p>
<p>现在有四种预先定义好的文档类别：<code>DocCatFunction</code> 对应函数的 attribute，<code>DocCatVariable</code> 对应到变量的 attribute，<code>DocCatType</code> 对应类型的 attribute，<code>DocCatStmt</code> 对应声明的 attribute。自定义文档类别应该用于具有类似功能的 attribute 组。自定义类别非常适合用来为组中的 attribute 提供概述信息。</p>
<p>文档内容（包括 attribute 的内容或者类别的内容）是用 reStructuredText（RST）格式写的。</p>
<p>在编写该 attribute 的文档之后，应该对其在本地对其进行测试，以确保在服务器上生成文档不会有问题。本地测试需要重新构建 clang-tblgen。要生成 attribute 文档，请执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang-tblgen -gen-attr-docs -I /path/to/clang/include /path/to/clang/include/clang/Basic/Attr.td -o /path/to/clang/docs/AttributeReference.rst</div></pre></td></tr></table></figure>
<p>在本地进行测试时，不要对 <code>AttributeReference.rst</code> 提交更改。该文件是由服务器自动生成的，并且对该文件所做的任何更改都将被覆盖。</p>
<h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><p>attribute 可以选择指定可以传递给 attribute 的参数列表。attribute 的参数指定 attribute 的解析形式和语义形式。例如，如果 <code>Args</code> 是 <code>[StringArgument&lt;&quot;Arg1&quot;&gt;, IntArgument&lt;&quot;Arg2&quot;&gt;]</code>，那么 <code>__attribute__((myattribute(&quot;Hello&quot;, 3)))</code> 就是一个合法的使用方式；这个 attribute 在解析时要求有两个参数：一个 string 类型一个 integer 类型。</p>
<p>每个参数都有个名字和一个用来指定这个参数是否为可选的标志。参数关联的 C++ 类型由参数定义类型确定。如果现有参数类型不足，则可以创建新类型，但需要修改 <a href="http://llvm.org/viewvc/llvm-project/cfe/trunk/utils/TableGen/ClangAttrEmitter.cpp?view=markup" target="_blank" rel="external">utils/TableGen/ClangAttrEmitter.cpp</a> 才能正确支持该新类型。</p>
<h5 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h5><p><code>Attr</code> 的定义还具有其他变量来控制 attribute 的行为。其中有很多是用于特殊用途的，超出了本文档的范围，但有一些还是值得提上一嘴的。</p>
<p>如果 attribute 的解析形式更加复杂或者和语义形式不同，则可以将 <code>HasCustomParsing</code> 变量设置为 <code>1</code>，并且可以针对特殊情况修改 <a href="http://llvm.org/viewvc/llvm-project/cfe/trunk/lib/Parse/ParseDecl.cpp?view=markup" target="_blank" rel="external">Parser::ParseGNUAttributeArgs()</a> 中的解析代码。请注意，这仅适用于具有 GNU 拼写的 attribute；__declspec 拼写的 attribute 现在是忽略这个标志的，并由 <code>Parser::ParseMicrosoftDeclSpec</code>  负责解析。 </p>
<p>请注意，把 <code>HasCustomParsing</code> 设置为 <code>1</code> 将不再使用通用的 attribute 处理逻辑，需要额外的处理来确保该  attribute 能使用。</p>
<p>如果该 attribute 不通过模板声明实例化，则将 <code>Clone</code> 成员变量设置为 0。默认情况下，所有的 attribute 都将通过模板进行实例化。</p>
<p>不需要 AST 节点的 attribute 应该将 <code>ASTNode</code> 变量设置为 0 以避免污染 AST。请注意，从 <code>TypeAttr</code> 或 <code>IgnoredAttr</code> 继承的类都不会自动生成 AST 节点。所有其他属性默认会生成一个 AST 节点。该 AST 节点是 attribute 的语义表示。</p>
<p><code>LangOpts</code> 变量指定了 attribute 所需的语言选项列表。例如，所有的 CUDA-specific 的 attribuet 都将 <code>LangOpts</code> 字段指定为 <code>[CUDA]</code>，并且当 CUDA 语言选项未启用时，会发出“attribute ignored”的警告诊断。由于语言选项不是自动生成的节点，因此必须手动创建新的语言选项，并应指定 <code>LangOptions</code> 类所使用的拼写。</p>
<p>可以基于 attribute 的拼写列表为该 attribute 生成自定义的存取器。例如，如果某个 attribute 有两种不同的拼写：’foo’ 和 ‘bar’，则可以创建访问器：<code>[Accessor&lt;&quot;isFoo&quot;, [GNU&lt;&quot;Foo&quot;&gt;]&gt;, Accessor&lt;&quot;isBar&quot;,[GNU&lt;&quot;Bar&quot;&gt;]&gt;]</code>。这些存取器将在该 attribute 的语义形式上生成，不接受任何参数并返回一个布尔值。</p>
<p>不需要自定义语义分析的 attribute 应该将 <code>SemaHandler</code> 变量设为 <code>0</code>。请注意，任何从 <code>IgnoredAttr</code> 继承的 attribute 都不会自动进行语义处理。所有其他 attribute 都使用默认的语义处理。没有语义处理的 attribute 都不会有解析好的 attribute <code>Kind</code> 枚举器。</p>
<p>指定 Target 的 attribute 可能会与不同 Target 的 attribute 共用一个拼写。例如，ARM 和 msp430 Target 都有一个拼写为 <code>GNU&lt;&quot;interrupt&quot;&gt;</code> 的 attribute，但各自有不同的解析方式和语义要求。为了支持这个特性，继承自 <code>TargetSpecificAttribute</code> 的 attribute 可以指定 <code>ParseKind</code> 变量。这个变量在共用拼写的所有参数之间应该是相同的，并且对应于解析 attribute 的 <code>Kind</code> 的枚举器。这允许 attribute 共用一种解析类型，但具有不同的语义属性。例如，<code>AttributeList::AT_Interrupt</code> 是共用的解析类型，但 ARMInterruptAttr 和 MSP430InterruptAttr 是各自的语义属性。</p>
<p>默认情况下，当声明为 merging attribute 时，该 attributes 不会被复制。但是，如果在此合并阶段中可以复制某个 attribute，那么将 <code>DuplicatesAllowedWhileMerging</code> 变量设置为 <code>1</code>，该 attribute 就会被合并。</p>
<p>默认情况下，attribute 的参数在上下文中被解析。如果应该在上下文中解析 attribute 的参数（类似于解析 <code>sizeof</code> 表达式的参数的方式），请将 <code>ParseArgumentsAsUnevaluated</code> 设置为 <code>1</code>。</p>
<h3 id="样板代码"><a href="#样板代码" class="headerlink" title="样板代码"></a>样板代码</h3><p>声明 attribute 的所有的语义处理都在文件 <a href="http://llvm.org/viewvc/llvm-project/cfe/trunk/lib/Sema/SemaDeclAttr.cpp?view=markup" target="_blank" rel="external">lib/Sema/SemaDeclAttr.cpp</a> 中，并且通常都从 <code>ProcessDeclAttribute()</code> 函数开始。如果这个 attribute 是一个“简单的” attribute，也就是说这个 attribute 除了自动生成的内容之外不需要自定义的语义处理，那么就添加 <code>handleSimpleAttribute&lt;YourAttr&gt;(S, D, Attr);</code> 函数到 switch 语句中。否则，编写一个新的 <code>handleYourAttr()</code> 函数，并将其添加到 switch 语句中。不要直接在 <code>case</code> 语句中实现处理逻辑。</p>
<p>除非 attribute 的定义中另有规定，否则将自动处理解析 attribute 的常见语义检查，包括诊断不属于给定 <code>Decl</code> 的解析的 attribute、确保传递正确的最小数量的参数等等。</p>
<p>如果 attribute 要加上额外的警告，那么在 <a href="http://llvm.org/viewvc/llvm-project/cfe/trunk/include/clang/Basic/DiagnosticGroups.td?view=markup" target="_blank" rel="external">include/clang/Basic/DiagnosticGroups.td</a> 文件中定义一个 <code>DiagGroup</code>。如果只有一个诊断信息的话，直接在 <a href="http://llvm.org/viewvc/llvm-project/cfe/trunk/include/clang/Basic/DiagnosticSemaKinds.td?view=markup" target="_blank" rel="external">DiagnosticSemaKinds.td</a> 文件中使用 <code>InGroup&lt;DiagGroup&lt;&quot;your-attribute&quot;&gt;&gt;</code> 也是可以的。</p>
<p>所有为你自定义的 attribute 所生成的诊断信息，包括自动生成的（比如 subject 和参数个数），都应该有一个对应的测试用例。</p>
<h3 id="语义处理"><a href="#语义处理" class="headerlink" title="语义处理"></a>语义处理</h3><p>大多数 attribute 被实现为对编译器有一定的影响。例如，修改生成代码的方式，或为分析过程添加额外的语义检查等，将 attribute 的定义和转换添加到该 attribute 的语义表示中，剩下的就是实现 attribute 的自定义逻辑。</p>
<p>可以使用 <code>hasAttr&lt;T&gt;()</code> 方法来查询 <code>clang::Decl</code> 对象中是否有 attribute。可以使用 <code>getAttr&lt;T&gt;</code> 来获取一个指向 attribute 的指针。 </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/16/Clang之旅-使用Xcode开发Clang插件/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="ruanpapa & 又吉君">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="ruanpapa和又吉君写字的地方">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="ruanpapa和又吉君写字的地方" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/16/Clang之旅-使用Xcode开发Clang插件/" itemprop="url">
                  Clang 之旅--使用 Xcode 开发 Clang 插件
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-16T14:44:05+08:00">
                2018-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ruanpapa-技术贴/" itemprop="url" rel="index">
                    <span itemprop="name">ruanpapa--技术贴</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/16/Clang之旅-使用Xcode开发Clang插件/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/03/16/Clang之旅-使用Xcode开发Clang插件/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/03/16/Clang之旅-使用Xcode开发Clang插件/" class="leancloud_visitors" data-flag-title="Clang 之旅--使用 Xcode 开发 Clang 插件">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在跟老大的聊天中聊到了一个比较特殊的需求：是否有办法在编译阶段检查某个方法的参数与返回值的类型相同，如果类型不一致的话能抛出编译错误的提示。这似乎已经不是 Objective-C 或者 Swift 的语言语法本身所能解决的了，老大还指点了可以从编译器等底层中进行研究。于是，我踏进了 Clang 和 LLVM 的大门。</p>
<p>我打算将 Clang 的研究心得分为几篇文章来写，这是 Clang 之旅的第一篇，主要讲如何用 Xcode 编译 Clang，以及实现一个简单的 Clang 插件并挂载到 Xcode 中参与编译流程，算是进入 Clang 的门槛。只是，这门槛就狠狠地让我吃了苦头，Google 找到好几篇博客讲怎么编译 Clang 的，但是也有一些年头了，版本比较旧，编译出来的 Clang 不能运行在现在的系统上；还有一些写的比较含糊，漏了某些关键步骤，导致花了好几个小时跟着教程做下来最后还是一堆 error；而且试错的成本还是比较高的，下载的源码有1G多（考虑从 Github 下载的速度🙄，需要挂个代理），完整编译出来有20G左右，我的15款 Macbook Pro 大概需要疯狂编译2个小时……如果不能接受这些的话，还是别尝试了，很遗憾，你连见到 Clang 真容的机会都没有┑(￣Д ￣)┍</p>
<p><img src="https://upload-images.jianshu.io/upload_images/698554-49318ad53d98d6ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="llvm大小"></p>
<p>Clang 之旅系列文章：<br><a href="https://www.jianshu.com/p/e3f46d42643b" target="_blank" rel="external">Clang 之旅–使用 Xcode 开发 Clang 插件</a><br><a href="https://www.jianshu.com/p/d277c42f4907" target="_blank" rel="external">Clang 之旅—[翻译]添加自定义的 attribute</a></p>
<h3 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>Clang 需要用 CMake 来编译，CMake 的安装方法可以参考这篇文章：<a href="https://www.jianshu.com/p/7466c85d5d6b" target="_blank" rel="external">Mac 安装 CMake &amp; CMake Command Line Tools</a>，建议对 CMake 完全不了解的同学可以先补充一点 CMake 的基本知识，这样能更容易理解接下来要做的事情，CMake 的入门知识可以参考：<a href="http://www.hahack.com/codes/cmake/" target="_blank" rel="external">CMake 入门实战</a></p>
<h4 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h4><p>首先创建 LLVM 的源码路径及编译路径：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cd /opt</div><div class="line">sudo mkdir llvm</div><div class="line">sudo chown `whoami` llvm	// 将 llvm 目录的所有者指定为当前用户</div><div class="line">cd llvm</div><div class="line">export LLVM_HOME=`pwd`		// 设置当前目录(/opt/llvm)为 LLVM_HOME 目录</div></pre></td></tr></table></figure>
<p>接下来从 Github clone 源代码（注意这几条语句中的 release_60，在当前时间2018.3.18时，我试过了 release_33、release_39，编译出来的 Clang 插件在运行的时候都会报 NSUUID 的 Nullability 错误，应该是这些版本不支持 Objective-C 后来加的 Nullability 特性，所以我下载了当前最新的 release_60 分支。一般来说，最新分支是兼容已有特性的，所以优先下载最新分支，分支查看可以参照下图）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git clone -b release_60 git@github.com:llvm-mirror/llvm.git llvm</div><div class="line">git clone -b release_60 git@github.com:llvm-mirror/clang.git llvm/tools/clang</div><div class="line">git clone -b release_60 git@github.com:llvm-mirror/clang-tools-extra.git llvm/tools/clang/tools/extra</div><div class="line">git clone -b release_60 git@github.com:llvm-mirror/compiler-rt.git llvm/projects/compiler-rt</div></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/698554-5e54bd18bac5a151.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="llvm最新分支.png"></p>
<h4 id="编译源码-1"><a href="#编译源码-1" class="headerlink" title="编译源码"></a>编译源码</h4><p>生成 Xcode 工程（也可以直接用命令行编译，不过大家平时可能看习惯了 Xcode 工程，所以用 Xcode 编译比较习惯）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir llvm_build; cd llvm_build</div><div class="line">cmake -G Xcode ../llvm -DCMAKE_BUILD_TYPE:STRING=MinSizeRel</div></pre></td></tr></table></figure>
<p>生成的文件如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/698554-975fe9e218257288.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Xcode工程.png"></p>
<p>打开 Xcode 工程，选择自动创建 Schemes：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/698554-dd7980d5fe52b689.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自动创建Schemes.png"></p>
<p>然后编译 Clang 和 libClang（可以随时终止编译，再次点击编译会从上次停止的地方继续进行）：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/698554-cad3858632e8185b.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译Clang和libClang"></p>
<p>这里可能需要1个多小时才能完成编译，如无意外，编译成功！</p>
<h3 id="编写你的第一个插件"><a href="#编写你的第一个插件" class="headerlink" title="编写你的第一个插件"></a>编写你的第一个插件</h3><p>这个插件实现的功能就是打印语法树上所有节点的类名以及父类名，创建 Clang 插件的整体步骤如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/698554-214742ce207ea7ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建插件.png"></p>
<p>首先修改源代码目录 /opt/llvm/llvm/tools/clang/tools 下的 CMakeLists.txt 文件，添加一个新的编译目标，直接在 CMakeLists.txt 的最后面添加上一行，如下图：<br><img src="https://upload-images.jianshu.io/upload_images/698554-db674e4e4ade824d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加新的编译目标.png"></p>
<p>然后在 tools 目录下添加 MyPlugin 文件夹，文件夹里面新增两个文件 CMakeLists.txt 和 MyPlugin.cpp，这里先不讲解具体文件中的内容，目的是想让插件跑起来，看到运行效果。</p>
<p>   CMakeLists.txt 文件如下：</p>
   <figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">add_llvm_loadable_module(MyPlugin </div><div class="line">MyPlugin.cpp</div><div class="line">PLUGIN_TOOL clang</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">if</span>(LLVM_ENABLE_PLUGINS <span class="keyword">AND</span> (WIN32 <span class="keyword">OR</span> CYGWIN))</div><div class="line">  <span class="keyword">target_link_libraries</span>(MyPlugin PRIVATE</div><div class="line">    clangAST</div><div class="line">    clangBasic</div><div class="line">    clangFrontend</div><div class="line">    clangLex</div><div class="line">    LLVMSupport</div><div class="line">    )</div><div class="line"><span class="keyword">endif</span>()</div></pre></td></tr></table></figure>
<p>   MyPlugin.cpp 文件如下：</p>
   <figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clang/AST/AST.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clang/AST/ASTConsumer.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clang/AST/RecursiveASTVisitor.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clang/Frontend/CompilerInstance.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clang/Frontend/FrontendPluginRegistry.h"</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> clang;</div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</div><div class="line"><span class="keyword">namespace</span> MyPlugin</div><div class="line">&#123;</div><div class="line">    <span class="keyword">class</span> MyASTVisitor: <span class="keyword">public</span></div><div class="line">    RecursiveASTVisitor &lt; MyASTVisitor &gt;</div><div class="line">    &#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">        ASTContext *context;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setContext</span><span class="params">(ASTContext &amp;context)</span></span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">this</span>-&gt;context = &amp;context;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">VisitDecl</span><span class="params">(Decl *decl)</span></span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (isa &lt; ObjCInterfaceDecl &gt; (decl)) &#123;</div><div class="line">                ObjCInterfaceDecl *interDecl = (ObjCInterfaceDecl *)decl;</div><div class="line">                <span class="keyword">if</span> (interDecl-&gt;getSuperClass()) &#123;</div><div class="line">                    <span class="built_in">string</span> interName = interDecl-&gt;getNameAsString();</div><div class="line">                    <span class="built_in">string</span> superClassName = interDecl-&gt;getSuperClass()-&gt;getNameAsString();</div><div class="line"></div><div class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-------- ClassName:"</span> &lt;&lt; interName &lt;&lt; <span class="string">" superClassName:"</span> &lt;&lt; superClassName &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="keyword">class</span> MyASTConsumer: <span class="keyword">public</span> ASTConsumer</div><div class="line">    &#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">        MyASTVisitor visitor;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">HandleTranslationUnit</span><span class="params">(ASTContext &amp;context)</span></span></div><div class="line">        &#123;</div><div class="line">            visitor.setContext(context);</div><div class="line">            visitor.TraverseDecl(context.getTranslationUnitDecl());</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">class</span> MyASTAction: <span class="keyword">public</span> PluginASTAction</div><div class="line">    &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">        <span class="built_in">unique_ptr</span> &lt; ASTConsumer &gt; CreateASTConsumer(CompilerInstance &amp; Compiler, StringRef InFile) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="built_in">unique_ptr</span> &lt; MyASTConsumer &gt; (<span class="keyword">new</span> MyASTConsumer);</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">ParseArgs</span><span class="params">(<span class="keyword">const</span> CompilerInstance &amp;CI, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span> &lt; <span class="built_in">std</span>::<span class="built_in">string</span> &gt;&amp; args)</span></span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">static</span> clang::FrontendPluginRegistry::Add</div><div class="line">&lt; MyPlugin::MyASTAction &gt; X(<span class="string">"MyPlugin"</span>,</div><div class="line">                            <span class="string">"MyPlugin desc"</span>);</div></pre></td></tr></table></figure>
<p>再次在 llvm_build 目录下 CMake 一下</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cmake -G Xcode ../llvm -DCMAKE_BUILD_TYPE:<span class="keyword">STRING</span>=MinSizeRel</div></pre></td></tr></table></figure>
<p>然后重新打开 LLVM.xcodeproj 工程，会发现多了一个 MyPlugin 的编译目标，选中进行编译。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/698554-a1ec081353964edc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译myPlugin.png"></p>
<p>编译成功之后，就可以得到一个 MyPlugin.dylib 的 Clang 插件了~为了方便，我将 MyPlugin.dylib 放在桌面上：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/698554-3b17229fdf5192e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MyPlugin插件.png"></p>
<h3 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h3><h4 id="命令行中使用插件"><a href="#命令行中使用插件" class="headerlink" title="命令行中使用插件"></a>命令行中使用插件</h4><p>首先用命令行对单文件测试一下刚刚生成的 Clang 插件是否正确，新建一个测试用文件 test.m 放在桌面，test.m 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#import&lt;UIKit/UIKit.h&gt;</div><div class="line">@interface ViewController : UIViewController</div><div class="line">@end</div><div class="line">@implementation ViewController</div><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">	if(self = [super init])&#123;</div><div class="line">	&#125;</div><div class="line">	return self;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>现在我的 test.m 和 MyPlugin.dylib 都在桌面上了（当然也可以放在不同的目录下，只要在待会用到这两个文件的地方指定各自的绝对路径就行，这里是为了方便叙述）</p>
<p><img src="https://upload-images.jianshu.io/upload_images/698554-5bd1c283af274180.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文件结构"></p>
<p>接着命令行 cd 到桌面，然后执行以下命令就可以看到结果了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/opt/llvm/llvm_build/Debug/bin/clang -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.2.sdk -Xclang -load -Xclang ./MyPlugin.dylib -Xclang -add-plugin -Xclang MyPlugin -c ./test.m</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<ol>
<li><p>我编译出来的 clang 在 /opt/llvm/llvm_build/Debug/bin/clang 目录中，如果你与我的路径不一样则指定为你对应的路径</p>
</li>
<li><p>在我写这篇文章时 Xcode 版本是9.2，对应的是 iPhoneSimulator11.2.sdk，你需要进入该目录查看你的 sdk 版本</p>
</li>
</ol>
</blockquote>
<p>如无意外，命令行中会出现一大堆输出：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/698554-0c3a4024f8974640.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命令行输出"></p>
<h4 id="Xcode-中使用插件"><a href="#Xcode-中使用插件" class="headerlink" title="Xcode 中使用插件"></a>Xcode 中使用插件</h4><p>接下来讲怎么样在 Xcode 使用我们刚刚编译出来的插件（随着 Xcode 变得封闭，插件挂载到 Xcode 上运行在未来的版本中可能会被禁止）。</p>
<p>首先 hack Xcode，才能使 Xcode 指向我们自己编译的 Clang：</p>
<p>下载 <a href="http://www.njiang.cn/uploads/2017/03/01/XcodeHacking.zip" target="_blank" rel="external">XcodeHacking.zip</a> 并解压，里面有 HackedBuildSystem.xcspec 和 HackedClang.xcplugin 两个文件，这里可能需要修改一下 HackedClang.xcplugin/Contents/Resources/HackedClang.xcspec 文件，将 ExecPath 的值修改为你编译出来的 Clang 的目录：<br><img src="https://upload-images.jianshu.io/upload_images/698554-cd4d800cbebe8e09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改HackedClang.xcspec"></p>
<p>然后 cd 到解压的 XcodeHacking 目录，将这两个文件用命令行移动到对应的目录下：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo mv HackedClang.xcplugin `xcode-select -print-path`/../PlugIns/Xcode3Core.ideplugin/Contents/SharedSupport/Developer/Library/Xcode/Plug-ins</div><div class="line">sudo mv HackedBuildSystem.xcspec `xcode-select -print-path`/Platforms/iPhoneSimulator.platform/Developer/Library/Xcode/Specifications</div></pre></td></tr></table></figure>
<p>   ​</p>
<p>然后重启 Xcode，点击 Target 的 Build Settings，修改 Compiler for C/C++/Objective-C 项为 Clang LLVM Trunk（不进行第1步中 hack Xcode 操作的话是不会有这个选项的）</p>
<p><img src="https://upload-images.jianshu.io/upload_images/698554-4ad812d07429b0e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Complier.png"></p>
<p>然后修改 OTHER_CFLAGS 选项：<br><img src="https://upload-images.jianshu.io/upload_images/698554-e50bcd49a7356985.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OTHER_CFLAGS.png"></p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-Xclang -load -Xclang /Users/Vernon/Desktop/MyPlugin.dylib -Xclang -add-plugin -Xclang MyPlugin</div></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<ol>
<li>将 /Users/Vernon/Desktop/MyPlugin.dylib 修改为你生成的插件对应的目录</li>
<li>如果编译中出现一大堆系统库的 symbol not found 错误的话，可以在上述命令的最后手动指定你的 SDK 目录：-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.2.sdk</li>
</ol>
</blockquote>
<p>最后编译你的项目，然后快捷键 Command+9 跳到 Show the Report navigator，选中刚刚的编译报告，注意下图中每个文件右上角都有可以点击展开的按钮，展开后就能看到我们插件的输出了（下图4为对应输出）。Nice~<br><img src="https://upload-images.jianshu.io/upload_images/698554-de614d7d87c219d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看结果"></p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>文章不长，只是这看似简单的过程也花了我一个多星期的业余时间，写下这个系列文章一是为了记录自己这钻研的过程，以后也可查询，二是希望如果有人能看到这篇拙文可以省下一点时间，更快的踏进 LLVM 和 Clang 的世界探索。</p>
<p>接下来会根据我的个人需求尝试给 Clang 添加自定义的 attribute，如果有所心得，会撰文分享，敬请期待~</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/02/《指数基金投资指南》读后感/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="ruanpapa & 又吉君">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="ruanpapa和又吉君写字的地方">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="ruanpapa和又吉君写字的地方" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/02/《指数基金投资指南》读后感/" itemprop="url">
                  《指数基金投资指南》读后感
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-02T23:36:37+08:00">
                2018-03-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/投资理财/" itemprop="url" rel="index">
                    <span itemprop="name">投资理财</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/02/《指数基金投资指南》读后感/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/03/02/《指数基金投资指南》读后感/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/03/02/《指数基金投资指南》读后感/" class="leancloud_visitors" data-flag-title="《指数基金投资指南》读后感">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>自己正式工作也已经半年多了，刚参加工作虽然工资不是很高，但是自己还是比较有规划的，没有比较花钱的嗜好，也有记账的习惯，所以慢慢也攒下了一点钱。有了钱就要考虑怎么安置的问题，自己经过了几个月业余时间的学习与权衡，最终确定了自己的投资理财方案：</p>
<ol>
<li><p>这半年多攒下的钱留1万左右放到余额宝作为日常花销（餐饮、房租水电、购物等），以后每个月发了工资都会补充这部分到1万左右，足以应付自己的2~3个月的日常生活所需。最近因为国家把货币基金纳入了M2，总量1.6万亿的余额宝也开始了每日限额发售，不过现在还是有其他的替代品的，比如微信零钱通、支付宝中的余利宝、天天基金的活期宝等，这些都属于低风险、收益稳定的货币基金，七日年化收益率都有4.2%~4.4%，高过余额宝的4.1%，T+1日开始计算收益，同时实时转出，从资金灵活度、收益等角度都不输余额宝。</p>
</li>
<li><p>其余攒下的钱都购买银行的低风险的理财产品，年化收益能到4.8%~5.2%左右，通常期限都为90天以上，一年以下。不过在到期日之前无法赎回，可以说是完全没有灵活度的，不过相当的稳定。考虑到自己暂时不用添置大件，所以这笔钱放在低风险中比较高收益的产品中是最为理想的。</p>
</li>
<li><p>以后每个月发了工资，会填充一部分到第1点中，其余的大部分会根据自己的眼光进行基金定投。基金定投自己之前实习期间已经进行过了一段时间的学习与尝试，后来为了买电脑全取了出来，所以那次3个月定投没有赚到什么钱。现在有了稳定的收入，自己又再进行了一番学习。比较看好价值平均策略，这一部分留到关于《价值平均策略：获得高投资收益的安全简便方法》的读后感再分享，另一个就是一直都有留意的雪球大V<a href="https://xueqiu.com/u/3079173340" target="_blank" rel="external">银行螺丝钉</a>的”盈利收益率”获取超额收益的方法，接下来讲讲自己看完钉大的《指数基金投资指南》感想。</p>
<p>​</p>
</li>
</ol>
<p>本书作者<a href="https://xueqiu.com/u/3079173340" target="_blank" rel="external">@银行螺丝钉</a>是一个90后，看起来有着超出年龄的成熟稳重，不仅从外观长相、说话谈吐，还从在雪球、微信公众号的耐心回答都能体现，同时他还坚持每天更新基金的估值表3年多，这样稳重、有毅力的人总是比较让人放心。同时他专注于低估值指数基金投资，以格雷厄姆和巴菲特为师，建立起基于估值的投资体系，以我个人对巴菲特的了解，他所坚持的价值投资、长期持有的风格是比较适合我的，而不是通过大量的技术分析，对赌高风险博取高收益，所以我选择尝试钉大所提倡的“盈利收益率”进行估值以期获得超额收益的定投方法。</p>
<p>盈利收益率的定义是：盈利收益率=股票盈利/股票市值，其实也就是市盈率的倒数，这个指标反映了该股票的单位盈利能力。根据对全世界各个国家的股市历史数据进行观察，发现绝大多数股市，在熊市最低谷的时候，盈利收益率都会在10%以上，这是格雷厄姆买股票的第一个标准。第二个标准是只有当股票的盈利收益率是国债利率的两倍以上时，我们才会去考虑股票。</p>
<p><strong>(1). 盈利收益率要大于10%</strong></p>
<p><strong>(2). 盈利收益率要在国债利率的两倍以上</strong></p>
<p>符合这两个标准的就是当前低估的股票基金，我们可以不断定投符合这两个标准的基金，当越是低估时，我们定投对应的那一期的额度越要增加，这样我们在低位买入的份额会更多，当基金到了高位，我们就能获得更多的收益。</p>
<p>当基金估值从低估回到正常估值的时候，我们就停止定投，转为持有基金，等到估值到了高估的时候，我们就可以分批卖出我们持有的基金。以沪深300指数为例，估值主要集中在10-18PE，低于10PE就是低估阶段，此时坚持定投；10-18PE为正常估值，持有基金；高于18PE就是高估阶段，分批卖出。具体哪些基金处于估值的哪个阶段，可以关注钉大的微信公众号，每个交易日更新估值数据。</p>
<p>我个人还是比较看好这种方式的，也解决了之前普通定投的卖出止损等的一些问题。最后就是心态的问题，短期内要有拥抱下跌的准备，现在的下跌亏损意味着我们在低点多买入了份额，而这不正是很多人在回测复盘的时候想要做到的吗，千万不要被黎明前的黑暗所吓倒！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/06/翻译用LLDB调试Swift代码/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="ruanpapa & 又吉君">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="ruanpapa和又吉君写字的地方">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="ruanpapa和又吉君写字的地方" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/06/翻译用LLDB调试Swift代码/" itemprop="url">
                  (翻译)用 LLDB 调试 Swift 代码
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-06T14:41:38+08:00">
                2018-02-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ruanpapa-技术贴/" itemprop="url" rel="index">
                    <span itemprop="name">ruanpapa--技术贴</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/02/06/翻译用LLDB调试Swift代码/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/02/06/翻译用LLDB调试Swift代码/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/02/06/翻译用LLDB调试Swift代码/" class="leancloud_visitors" data-flag-title="(翻译)用 LLDB 调试 Swift 代码">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<ul>
<li>原文地址：<a href="https://medium.com/flawless-app-stories/debugging-swift-code-with-lldb-b30c5cf2fd49" target="_blank" rel="external">Debugging Swift code with LLDB</a></li>
<li>原文作者：<a href="https://medium.com/@ahmedsulaiman?source=post_header_lockup" target="_blank" rel="external">Ahmed Sulaiman</a></li>
</ul>
</blockquote>
<h1 id="用-LLDB-调试-Swift-代码"><a href="#用-LLDB-调试-Swift-代码" class="headerlink" title="用 LLDB 调试 Swift 代码"></a>用 LLDB 调试 Swift 代码</h1><p><img src="http://upload-images.jianshu.io/upload_images/698554-035b0df85ea54d32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>作为工程师，我们花了差不多 70% 的时间在调试上，剩下的 20% 用来思考架构以及和组员沟通，仅仅只有 10% 的时间是真的在写代码的。</p>
<blockquote>
<p>调试就像是在犯罪电影中做侦探一样，同时你也是凶手。</p>
<p>— <a href="https://twitter.com/fortes" target="_blank" rel="external">Filipe Fortes</a> 来自 Twitter</p>
</blockquote>
<p>所以让我们在这70%的时间尽可能愉悦是相当重要的。LLDB 就是来打救我们的。奇妙的 Xcode Debugger UI 展示了所有你可用的信息，而不用敲入任何一个 LLDB 命令。然而，控制台在我们的工作中同样也是很重要的一部分。现在让我们来分析一些最有用的 LLDB 技巧。我自己每天都在用它们进行调试。</p>
<h3 id="从哪里开始呢？"><a href="#从哪里开始呢？" class="headerlink" title="从哪里开始呢？"></a>从哪里开始呢？</h3><p>LLDB 是一个庞大的工具，内置了很多有用的命令。我不会全部讲解，而是带你浏览最有用的命令。这是我们的计划：</p>
<ol>
<li>获取变量值： <code>expression</code>, <code>e</code>, <code>print</code>, <code>po</code>, <code>p</code></li>
<li>获取整个应用程序的状态以及特定语言的命令：<code>bugreport</code>, <code>frame</code>, <code>language</code></li>
<li>控制应用的执行流程：<code>process</code>, <code>breakpoint</code>, <code>thread</code>, <code>watchpoint</code></li>
<li>荣誉奖：<code>command</code>, <code>platform</code>, <code>gui</code></li>
</ol>
<p>我还准备好了有用的 LLDB 命令说明和实例的表格，有需要的可以把它贴在 Mac 上面记住这些命令 🙂</p>
<p><img src="http://upload-images.jianshu.io/upload_images/698554-4425e8ad483d1e91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>通过这条链接下载全尺寸的版本 —  <a href="https://www.dropbox.com/s/9sv67e7f2repbpb/lldb-commands-map.png?dl=0" target="_blank" rel="external">https://www.dropbox.com/s/9sv67e7f2repbpb/lldb-commands-map.png?dl=0</a></p>
<h3 id="1-获取变量值和状态"><a href="#1-获取变量值和状态" class="headerlink" title="1. 获取变量值和状态"></a>1. 获取变量值和状态</h3><p>命令：<code>expression</code>, <code>e</code>, <code>print</code>, <code>po</code>, <code>p</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/698554-28e3583bcef761ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>调试器的一个基础功能就是获取和修改变量的值。这就是 <code>expression</code> 或者 <code>e</code> 被创造的原因（当然他们还有更高级的功能）。您可以简单的在运行时执行任何表达式或命令。</p>
<p>假设你现在正在调试方法 <code>valueOfLifeWithoutSumOf()</code> ：对两个数求和，再用42去减得到结果。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/698554-f788753308492216.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>继续假设你一直得到错误的结果并且你并不知道是什么原因。所以你可以做以下的事来找到问题：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/698554-ca27db839bd80a19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>或者。。。使用 LLDB 表达式在运行时修改值才是更好的方法，同时可以找出问题是在哪里出现的。首先，在你感兴趣的地方设置一个断点，然后运行你的应用。</p>
<p>为了用 LLDB 格式打印指定的变量你应该调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(lldb) e &lt;variable&gt;</div></pre></td></tr></table></figure>
<p>使用相同的命令来执行一些表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(lldb) e &lt;expression&gt;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/698554-42790260c5498fe3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(lldb) e sum </div><div class="line">(Int) $R0 = 6 // 下面你也可以用 $R0 来引用这个变量（在本次调试过程中）</div><div class="line"></div><div class="line">(lldb) e sum = 4 // 修改变量 sum 的值</div><div class="line"></div><div class="line">(lldb) e sum </div><div class="line">(Int) $R2 = 4 // 直到本次调试结束变量 sum 都会是 &quot;4&quot;</div></pre></td></tr></table></figure>
<p><code>expression</code> 命令也有一些标志。在 <code>expression</code> 后面用双破折号 <code>--</code> 将标志和实际的表达式分隔开，就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(lldb) expression &lt;some flags&gt; -- &lt;variable&gt;</div></pre></td></tr></table></figure>
<p><code>expression</code> 命令差不多有30种不同的标志。我鼓励你多去探索它们。在终端中键入以下命令可以看到完整的文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; lldb</div><div class="line">&gt; (lldb) help # 获取所有变量的命令</div><div class="line">&gt; (lldb) help expression # 获取所有表达式的子命令</div></pre></td></tr></table></figure>
<p>我会在下列 <code>expression</code> 的标志上多停留一会儿：</p>
<ul>
<li><code>-D &lt;count&gt;</code> (<code>--depth &lt;count&gt;</code>)  — 设置在转储聚合类型时的最大递归深度（默认为无穷大）。</li>
<li><code>-O</code> (<code>--object-description</code>)  — 如果可能的话，使用指定语言的描述API来显示。</li>
<li><code>-T</code> (<code>--show-types</code>)  — 在转储值的时候显示变量类型。</li>
<li><code>-f &lt;format&gt;</code> (<code>--format &lt;format&gt;</code>) — 指定一种用于显示的格式。</li>
<li><code>-i &lt;boolean&gt;</code> (<code>--ignore-breakpoints &lt;boolean&gt;</code>) — 在运行表达式时忽略断点。</li>
</ul>
<p>假设我们有一个叫 <code>logger</code> 的对象，这个对象有一些字符串和结构体类型的属性。比如说，你可能只是想知道第一层的属性，那只需要用 <code>-D</code> 标志以及恰当的层级深度值，就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(lldb) e -D 1 -- logger</div><div class="line"></div><div class="line">(LLDB_Debugger_Exploration.Logger) $R5 = 0x0000608000087e90 &#123;</div><div class="line">  currentClassName = &quot;ViewController&quot;</div><div class="line">  debuggerStruct =&#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>默认情况下，LLDB 会无限地遍历该对象并且给你展示每个嵌套的对象的完整描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(lldb) e -- logger</div><div class="line"></div><div class="line">(LLDB_Debugger_Exploration.Logger) $R6 = 0x0000608000087e90 &#123;</div><div class="line">  currentClassName = &quot;ViewController&quot;</div><div class="line">  debuggerStruct = (methodName = &quot;name&quot;, lineNumber = 2, commandCounter = 23)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你也可以用 <code>e -O --</code> 获取对象的描述或者更简单地用别名 <code>po</code>，就像下面的示例一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(lldb) po logger</div><div class="line"></div><div class="line">&lt;Logger: 0x608000087e90&gt;</div></pre></td></tr></table></figure>
<p>并不是很有描述性，不是吗？为了获取更加可阅读的描述，你自定义的类必须遵循 <code>CustomStringConvertible</code> 协议，同时实现 <code>var description: String { return ...}</code> 属性。接下来只需要用 <code>po</code> 就能返回可读的描述。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/698554-67b11fbfba92f9c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在本节的开始，我也提到了 <code>print</code> 命令。基本上 <code>print &lt;expression/variable&gt;</code> 就等同于 <code>expression -- &lt;expression/variable&gt;</code>。但是 <code>print</code> 命令不能带任何标志或者额外的参数。</p>
<h3 id="2-获取整个-APP-的状态和指定语言的命令"><a href="#2-获取整个-APP-的状态和指定语言的命令" class="headerlink" title="2. 获取整个 APP 的状态和指定语言的命令"></a>2. 获取整个 APP 的状态和指定语言的命令</h3><p><code>bugreport</code>, <code>frame</code>, <code>language</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/698554-b6780919d5f067a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>你是否经常复制粘贴崩溃日志到任务管理器中方便稍后能考虑这个问题吗？LLDB 提供了一个很好用的命令叫 <code>bugreport</code>，这个命令能生成当前应用状态的完整报告。在你偶然触发某些问题但是想在稍后再解决它时这个命令就会很有帮助了。为了能恢复应用的状态，你可以使用 <code>bugreport</code> 生成报告。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(lldb) bugreport unwind --outfile &lt;path to output file&gt;</div></pre></td></tr></table></figure>
<p>最终的报告看起来就像下面截图中的例子一样：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/698554-f8a7604c35151d5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><code>bugreport</code> 命令输出的示例。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/698554-2179c17fefec7742.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>假设你想要获取当前线程的当前栈帧的概述，<code>frame</code> 命令可以帮你完成：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/698554-5207a680ff245ddf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>使用下面的代码片段来快速获取当前地址以及当前的环境条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(lldb) frame info</div><div class="line"></div><div class="line">frame #0: 0x000000010bbe4b4d LLDB-Debugger-Exploration`ViewController.valueOfLifeWithoutSumOf(a=2, b=2, self=0x00007fa0c1406900) -&gt; Int at ViewController.swift:96</div></pre></td></tr></table></figure>
<p>这些信息在本文后面将要说到的断点管理中非常有用。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/698554-2b16ad60aed4e6af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>LLDB 有几个指定语言的命令，包括C++，Objective-C，Swift 和 RenderScript。在这篇文章中，我们重点关注 Swift。这是两个命令：<code>demangle</code> 和 <code>refcount</code>。</p>
<p><code>demangle</code> 正如其名字而言，就是用来重组 Swift 类型名的（因为 Swift 在编译的时候会生成类型名来避免命名空间的问题）。如果你想了解多一点的话，我建议你看 WWDC14 的这个分享会 —  <a href="https://developer.apple.com/videos/play/wwdc2014/410/" target="_blank" rel="external">“Advanced Swift Debugging in LLDB”</a>。</p>
<p><code>refcount</code> 同样也是一个相当直观的命令，能获得指定对象的引用数量。一起来看一下对象输出的示例，我们用了上一节讲到的对象 — <code>logger</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(lldb) language swift refcount logger</div><div class="line"></div><div class="line">refcount data: (strong = 4, weak = 0)</div></pre></td></tr></table></figure>
<p>当然了，在你调试某些内存泄露问题时，这个命令就会很有帮助。</p>
<h3 id="3-控制应用的执行流程"><a href="#3-控制应用的执行流程" class="headerlink" title="3. 控制应用的执行流程"></a>3. 控制应用的执行流程</h3><p><code>process</code>, <code>breakpoint</code>, <code>thread</code></p>
<p>这节是我最喜欢的一节，因为在 LLDB 使用这几个命令（尤其是 <code>breakpoint</code> 命令），你可以在调试的时候使很多常规任务变得自动化，这样就能大大加快你的调试工作。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/698554-190d8c7f7600ae0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>通过 <code>process</code> 基本上你就可以控制调试的过程了，还能链接到特定的 target 或者停止调试器。 但是因为 Xcode 已经自动地帮我们做好了这个工作了（Xcode 在任何时候运行一个 target 时都会连接 LLDB）。我不会在这儿讲太多，你可以在这篇 Apple 的指南中阅读一下如何用终端连接到一个 target — <a href="https://developer.apple.com/library/content/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-terminal-workflow-tutorial.html" target="_blank" rel="external">“Using LLDB as a Standalone Debugger”</a>。</p>
<p>使用 <code>process status</code> 的话，你可以知道当前调试器停住的地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(lldb) process status</div><div class="line"></div><div class="line">Process 27408 stopped</div><div class="line">* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = step over</div><div class="line">frame #0: 0x000000010bbe4889 LLDB-Debugger-Exploration`ViewController.viewDidLoad(self=0x00007fa0c1406900) -&gt; () at ViewController.swift:69</div><div class="line">66</div><div class="line">67           let a = 2, b = 2</div><div class="line">68           let result = valueOfLifeWithoutSumOf(a, and: b)</div><div class="line">-&gt; 69           print(result)</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td></tr></table></figure>
<p>想要继续 target 的执行过程直到遇到下次断点的话，运行这个命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(lldb) process continue</div><div class="line"></div><div class="line">(lldb) c // 或者只键入 &quot;c&quot;，这跟上一条命令是一样的</div></pre></td></tr></table></figure>
<p>这个命令等同于 Xcode 调试器工具栏上的”continue“按钮：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/698554-8d3a7affc384f574.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/698554-779f316d847a475c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><code>breakpoint</code> 命令允许你用任何可能的方式操作断点。我们跳过最显而易见的命令：<code>breakpoint enable</code>, <code>breakpoint disable</code> 和 <code>breakpoint delete</code>。</p>
<p>首先，查看你所有断点的话可以用如下示例中的 <code>list</code> 子命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(lldb) breakpoint list</div><div class="line"></div><div class="line">Current breakpoints:</div><div class="line">1: file = &apos;/Users/Ahmed/Desktop/Recent/LLDB-Debugger-Exploration/LLDB-Debugger-Exploration/ViewController.swift&apos;, line = 95, exact_match = 0, locations = 1, resolved = 1, hit count = 1</div><div class="line"></div><div class="line">1.1: where = LLDB-Debugger-Exploration`LLDB_Debugger_Exploration.ViewController.valueOfLifeWithoutSumOf (Swift.Int, and : Swift.Int) -&gt; Swift.Int + 27 at ViewController.swift:95, address = 0x0000000107f3eb3b, resolved, hit count = 1</div><div class="line"></div><div class="line">2: file = &apos;/Users/Ahmed/Desktop/Recent/LLDB-Debugger-Exploration/LLDB-Debugger-Exploration/ViewController.swift&apos;, line = 60, exact_match = 0, locations = 1, resolved = 1, hit count = 1</div><div class="line"></div><div class="line">2.1: where = LLDB-Debugger-Exploration`LLDB_Debugger_Exploration.ViewController.viewDidLoad () -&gt; () + 521 at ViewController.swift:60, address = 0x0000000107f3e609, resolved, hit count = 1</div></pre></td></tr></table></figure>
<p>列表中的第一个数字是是断点的 ID，你可以通过这个 ID 引用到指定的断点。现在让我们在控制台中设置一些新的断点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(lldb) breakpoint set -f ViewController.swift -l 96</div><div class="line"></div><div class="line">Breakpoint 3: where = LLDB-Debugger-Exploration`LLDB_Debugger_Exploration.ViewController.valueOfLifeWithoutSumOf (Swift.Int, and : Swift.Int) -&gt; Swift.Int + 45 at ViewController.swift:96, address = 0x0000000107f3eb4d</div></pre></td></tr></table></figure>
<p>这个例子中的 <code>-f</code> 是你想要放置断点处的文件名，<code>-l</code> 是新断点的行数。还有一种更简洁的方式设置同样的断点，就是用快捷方式 <code>b</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(lldb) b ViewController.swift:96</div></pre></td></tr></table></figure>
<p>同样地，你也可以用指定的正则（比如函数名）来设置断点，使用下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(lldb) breakpoint set --func-regex valueOfLifeWithoutSumOf</div><div class="line"></div><div class="line">(lldb) b -r valueOfLifeWithoutSumOf // 上一条命令的简化版本</div></pre></td></tr></table></figure>
<p>有些时候设置断点只命中一次也是有用的，然后指示这个断点立即删除自己，当然啦，有一个命令来处理这件事：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(lldb) breakpoint set --one-shot -f ViewController.swift -l 90</div><div class="line"></div><div class="line">(lldb) br s -o -f ViewController.swift -l 91 // 上一条命令的简化版本</div></pre></td></tr></table></figure>
<p>现在我们来到了最有趣的部分 — 自动化断点。你知道你可以设置一个特定的动作使它在断点停住的时候执行吗？是的，你可以！你是否会在代码中用 <code>print()</code> 来在调试的时候得到你感兴趣的值？请不要再这样做了，这里有一种更好的方法。🙂</p>
<p>通过 <code>breakpoint</code> 命令，你可以设置好命令，使其在断点命中时可以正确执行。你甚至可以设置”不可见“的断点，这种断点并不会打断运行过程。从技术上讲，这些“不可见的”断点其实是会中断执行的，但如果在命令链的末尾添上“continue”命令的话，你就不会注意到它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(lldb) b ViewController.swift:96 // Let&apos;s add a breakpoint first</div><div class="line"></div><div class="line">Breakpoint 2: where = LLDB-Debugger-Exploration`LLDB_Debugger_Exploration.ViewController.valueOfLifeWithoutSumOf (Swift.Int, and : Swift.Int) -&gt; Swift.Int + 45 at ViewController.swift:96, address = 0x000000010c555b4d</div><div class="line"></div><div class="line">(lldb) breakpoint command add 2 // 准备某些命令</div><div class="line"></div><div class="line">Enter your debugger command(s).  Type &apos;DONE&apos; to end.</div><div class="line">&gt; p sum // 打印变量 &quot;sum&quot; 的值</div><div class="line">&gt; p a + b // 运行 a + b</div><div class="line">&gt; DONE</div></pre></td></tr></table></figure>
<p>为了确保你添加的命令是正确的，可以使用  <code>breakpoint command list &lt;breakpoint id&gt;</code> 子命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(lldb) breakpoint command list 2</div><div class="line"></div><div class="line">Breakpoint 2:</div><div class="line">Breakpoint commands:</div><div class="line">p sum</div><div class="line">p a + b</div></pre></td></tr></table></figure>
<p>当下次断点命中时我们就会在控制台看到下面的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Process 36612 resuming</div><div class="line">p sum</div><div class="line">(Int) $R0 = 6</div><div class="line"></div><div class="line">p a + b</div><div class="line">(Int) $R1 = 4</div></pre></td></tr></table></figure>
<p>太棒了！这正是我们想要的。你可以通过在命令链的末尾添加 <code>continue</code> 命令让执行过程更加顺畅，这样你就不会停在这个断点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(lldb) breakpoint command add 2 // 准备某些命令</div><div class="line"></div><div class="line">Enter your debugger command(s).  Type &apos;DONE&apos; to end.</div><div class="line">&gt; p sum // 打印变量 &quot;sum&quot; 的值</div><div class="line">&gt; p a + b // 运行 a + b</div><div class="line">&gt; continue // 第一次命中断点后直接恢复</div><div class="line">&gt; DONE</div></pre></td></tr></table></figure>
<p>结果会是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">p sum</div><div class="line">(Int) $R0 = 6</div><div class="line"></div><div class="line">p a + b</div><div class="line">(Int) $R1 = 4</div><div class="line"></div><div class="line">continue</div><div class="line">Process 36863 resuming</div><div class="line">Command #3 &apos;continue&apos; continued the target.</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/698554-a1c3ec912e68ba8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>通过 <code>thread</code> 命令和它的子命令，你可以完全操控执行流程：<code>step-over</code>, <code>step-in</code>, <code>step-out</code> 和 <code>continue</code>。这些命令等同于 Xcode 调试器工具栏上的流程控制按钮。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/698554-0dfdf39bff20db4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>LLDB 同样也对这些特殊的命令预先定义好了快捷方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(lldb) thread step-over</div><div class="line">(lldb) next // 和 &quot;thread step-over&quot; 命令效果一样</div><div class="line">(lldb) n // 和 &quot;next&quot; 命令效果一样</div><div class="line"></div><div class="line">(lldb) thread step-in</div><div class="line">(lldb) step // 和 &quot;thread step-in&quot; 命令效果一样</div><div class="line">(lldb) s // 和 &quot;step&quot; 命令效果一样</div></pre></td></tr></table></figure>
<p>为了获取当前线程的更多信息，我们只需要调用 <code>info</code> 子命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(lldb) thread info </div><div class="line"></div><div class="line">thread #1: tid = 0x17de17, 0x0000000109429a90 LLDB-Debugger-Exploration`ViewController.sumOf(a=2, b=2, self=0x00007fe775507390) -&gt; Int at ViewController.swift:90, queue = &apos;com.apple.main-thread&apos;, stop reason = step in</div></pre></td></tr></table></figure>
<p>想要看到当前所有的活动线程的话使用 <code>list</code> 子命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(lldb) thread list</div><div class="line"></div><div class="line">Process 50693 stopped</div><div class="line"></div><div class="line">* thread #1: tid = 0x17de17, 0x0000000109429a90 LLDB-Debugger-Exploration`ViewController.sumOf(a=2, b=2, self=0x00007fe775507390) -&gt; Int at ViewController.swift:90, queue = &apos;com.apple.main-thread&apos;, stop reason = step in</div><div class="line"></div><div class="line">  thread #2: tid = 0x17df4a, 0x000000010daa4dc6  libsystem_kernel.dylib`kevent_qos + 10, queue = &apos;com.apple.libdispatch-manager&apos;</div><div class="line">  </div><div class="line">  thread #3: tid = 0x17df4b, 0x000000010daa444e libsystem_kernel.dylib`__workq_kernreturn + 10</div><div class="line"></div><div class="line">  thread #5: tid = 0x17df4e, 0x000000010da9c34a libsystem_kernel.dylib`mach_msg_trap + 10, name = &apos;com.apple.uikit.eventfetch-thread&apos;</div></pre></td></tr></table></figure>
<h3 id="荣誉奖"><a href="#荣誉奖" class="headerlink" title="荣誉奖"></a>荣誉奖</h3><p><code>command</code>, <code>platform</code>, <code>gui</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/698554-93fdf48e5daca771.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在 LLDB 中你可以找到一个命令管理其他的命令，听起来很奇怪，但实际上它是非常有用的小工具。首先，它允许你从文件中执行一些 LLDB 命令，这样你就可以创建一个储存着一些实用命令的文件，然后就能立刻允许这些命令，就像是单个命令那样。这是所说的文件的简单例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">thread info // 显示当前线程的信息</div><div class="line">br list // 显示所有的断点</div></pre></td></tr></table></figure>
<p>下面是实际命令的样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(lldb) command source /Users/Ahmed/Desktop/lldb-test-script</div><div class="line"></div><div class="line">Executing commands in &apos;/Users/Ahmed/Desktop/lldb-test-script&apos;.</div><div class="line"></div><div class="line">thread info</div><div class="line">thread #1: tid = 0x17de17, 0x0000000109429a90 LLDB-Debugger-Exploration`ViewController.sumOf(a=2, b=2, self=0x00007fe775507390) -&gt; Int at ViewController.swift:90, queue = &apos;com.apple.main-thread&apos;, stop reason = step in</div><div class="line"></div><div class="line">br list</div><div class="line">Current breakpoints:</div><div class="line">1: file = &apos;/Users/Ahmed/Desktop/Recent/LLDB-Debugger-Exploration/LLDB-Debugger-Exploration/ViewController.swift&apos;, line = 60, exact_match = 0, locations = 1, resolved = 1, hit count = 0</div><div class="line">1.1: where = LLDB-Debugger-Exploration`LLDB_Debugger_Exploration.ViewController.viewDidLoad () -&gt; () + 521 at ViewController.swift:60, address = 0x0000000109429609, resolved, hit count = 0</div></pre></td></tr></table></figure>
<p>遗憾的是还有一个缺点，你不能传递任何参数给这个源文件（除非你在脚本文件本身中创建一个有效的变量）。</p>
<p>如果你需要更高级的功能，你也可以使用 <code>script</code> 子命令，这个命令允许你用自定义的 Python 脚本 管理(<code>add</code>, <code>delete</code>, <code>import</code> 和 <code>list</code>)，通过 <code>script</code> 命令能实现真正的自动化。请阅读这个优秀的教程 <a href="http://www.fabianguerra.com/ios/introduction-to-lldb-python-scripting/" target="_blank" rel="external">Python scripting for LLDB</a>。为了演示的目的，让我们创建一个脚本文件 script.py，然后写一个简单的命令 <strong>print_hello()</strong>，这个命令会在控制台中打印出“Hello Debugger!“：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import lldb</div><div class="line"></div><div class="line">def print_hello(debugger, command, result, internal_dict):</div><div class="line">	print &quot;Hello Debugger!&quot;</div><div class="line">    </div><div class="line">def __lldb_init_module(debugger, internal_dict):</div><div class="line">	debugger.HandleCommand(&apos;command script add -f script.print_hello print_hello&apos;) // 控制脚本的初始化同时从这个模块中添加命令</div><div class="line">	print &apos;The &quot;print_hello&quot; python command has been installed and is ready for use.&apos; // 打印确认一切正常</div></pre></td></tr></table></figure>
<p>接下来我们需要导入一个 Python 模块，就能开始正常地使用我们的脚本命令了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(lldb) command import ~/Desktop/script.py</div><div class="line"></div><div class="line">The &quot;print_hello&quot; python command has been installed and is ready for use.</div><div class="line"></div><div class="line">(lldb) print_hello</div><div class="line"></div><div class="line">Hello Debugger!</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/698554-463b54c539c5eb64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>你可以使用 <code>status</code> 子命令来快速检查当前的环境信息，<code>status</code> 会告诉你：SDK 路径、处理器的架构、操作系统版本甚至是该 SDK 可支持的设备的列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">(lldb) platform status</div><div class="line"></div><div class="line">Platform: ios-simulator</div><div class="line">Triple: x86_64-apple-macosx</div><div class="line">OS Version: 10.12.5 (16F73)</div><div class="line">Kernel: Darwin Kernel Version 16.6.0: Fri Apr 14 16:21:16 PDT 2017; root:xnu-3789.60.24~6/RELEASE_X86_64</div><div class="line">Hostname: 127.0.0.1</div><div class="line">WorkingDir: /</div><div class="line">SDK Path: &quot;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk&quot;</div><div class="line"></div><div class="line">Available devices:</div><div class="line">614F8701-3D93-4B43-AE86-46A42FEB905A: iPhone 4s</div><div class="line">CD516CF7-2AE7-4127-92DF-F536FE56BA22: iPhone 5</div><div class="line">0D76F30F-2332-4E0C-9F00-B86F009D59A3: iPhone 5s</div><div class="line">3084003F-7626-462A-825B-193E6E5B9AA7: iPhone 6</div><div class="line">...</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/698554-7ac0c7f2bf73cecd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>你不能在 Xcode 中使用 LLDB GUI 模式，但你总是可以从终端使用（LLDB GUI 模式）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(lldb) gui</div><div class="line"></div><div class="line">// 如果你试着在 Xcode 中执行这个 gui 命令的话，你将会看到这个错误：the gui command requires an interactive terminal。</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/698554-5d99e8dfc0af41df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这就是 LLDB GUI 模式看起来的样子。</p>
<h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><p>在这篇文章中，我只是浅析了 LLDB 的皮毛知识而已，即使 LLDB 已经有好些年头了，但是仍然有许多人并没有完全发挥出它的潜能。我只是对基本的方法做了一个概述，以及谈了 LLDB 如何自动化调试步骤。我希望这会是有帮助的。</p>
<p>还有很多 LLDB 的方法并没有写到，然后还有一些视图调试技术我没有提及。如果你对这些话题感兴趣的话，请在下面留下你的评论，我会更加乐于写这些话题。</p>
<p>我强烈建议你打开终端，启动 LLDB，只需要敲入 <code>help</code>，就会向你展示完整的文档。你可以花费数小时去阅读，但是我保证这将是一个合理的时间投资。因为了解你的工具是工程师真正产出的唯一途径。</p>
<hr>
<ul>
<li><a href="http://lldb.llvm.org" target="_blank" rel="external">LLDB 官方网站</a> —  你会在这里找到所有与 LLDB 相关的材料。文档、指南、教程、源文件以及更多。</li>
<li><a href="https://developer.apple.com/library/content/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/Introduction.html#//apple_ref/doc/uid/TP40012917-CH1-SW1" target="_blank" rel="external">LLDB Quick Start Guide by Apple</a> — 同样地，Apple 提供了很好的文档。这篇指南能帮你快速上手 LLDB，当然，他们也叙述了怎样不通过 Xcode 地用 LLDB 调试。</li>
<li><a href="http://eli.thegreenplace.net/2011/01/23/how-debuggers-work-part-1" title="Permalink to How debuggers work: Part 1 - Basics" target="_blank" rel="external">How debuggers work: Part 1 — Basics</a> — 我非常喜欢这个系列的文章，这是对调试器实际工作方式很好的概述。文章介绍了用 C 语言手工编写的调试器代码要遵循的所有基本原理。我强烈建议你去阅读这个优秀系列的所有部分（<a href="http://eli.thegreenplace.net/2011/01/27/how-debuggers-work-part-2-breakpoints" target="_blank" rel="external">第2部分</a>, <a href="http://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information" target="_blank" rel="external">第3部分</a>）。</li>
<li><a href="https://developer.apple.com/videos/play/wwdc2014/410/" target="_blank" rel="external">WWDC14 Advanced Swift Debugging in LLDB</a> — 关于在 LLDB 中用 Swift 调试的一篇不错的概述，也讲了 LLDB 如何通过内建的方法和特性实现完整的调试操作，来帮你变得更加高效。</li>
<li><a href="http://www.fabianguerra.com/ios/introduction-to-lldb-python-scripting/" target="_blank" rel="external">Introduction To LLDB Python Scripting</a> — 这篇介绍 LLDB Python 脚本的指南能让你快速上手。</li>
<li><a href="https://www.objc.io/issues/19-debugging/lldb-debugging" target="_blank" rel="external">Dancing in the Debugger. A Waltz with LLDB</a>  — 对 LLDB 一些基础知识的介绍，有些知识有点过时了（比如说 <code>(lldb) thread return</code> 命令）。遗憾的是，它不能直接用于 Swift，因为它会对引用计数带了一些潜在的隐患。但是，这仍然是你开始 LLDB 之旅不错的文章。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/01/格式化Import/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="ruanpapa & 又吉君">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="ruanpapa和又吉君写字的地方">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="ruanpapa和又吉君写字的地方" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/01/格式化Import/" itemprop="url">
                  Source Editor Extension — Xcode 格式化 Import 的插件
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-01T17:06:35+08:00">
                2018-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ruanpapa-技术贴/" itemprop="url" rel="index">
                    <span itemprop="name">ruanpapa--技术贴</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/02/01/格式化Import/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/02/01/格式化Import/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/02/01/格式化Import/" class="leancloud_visitors" data-flag-title="Source Editor Extension — Xcode 格式化 Import 的插件">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Xcode 秉承了 Apple 封闭的传统，提供的可自定义的选项比起其他 IDE 来说是比较少的，不过在 Xcode 7 之前（包含 Xcode 7）我们还是可以通过插件实现 Xcode 的自定义，甚至还出现了像  <a href="https://github.com/alcatraz/Alcatraz" target="_blank" rel="external">Alcatraz</a> 的专门的插件管理工具，开源社区中也有诸如 <a href="https://link.jianshu.com/?t=https://github.com/onevcat/VVDocumenter-Xcode" target="_blank" rel="external">VVDocumenter-Xcode</a>、<a href="https://github.com/CocoaPods/CocoaPods" target="_blank" rel="external">CocoaPods</a> 等知名的插件，不过这些便利随着 Xcode 8 的发布成为了过去式。<br>出于安全性考虑（比如说 Xcode ghost 事件），Apple 从 Xcode 8 开始不再支持第三方的插件。Apple 方面提供了基于 App Extension 的解决方案 – Xcode Source Editor Extension，这是一个相当简单的方案，能且仅能完成有限的文本编辑辅助，很大部分之前第三方插件能完成的任务都没办法实现了。聊胜于无吧 😑<br>（本文会介绍 Source Editor Extension 的开发以及分发相关的知识，本文对应的 Demo 在：<a href="https://github.com/VernonVan/PPImportArrangerExtension）" target="_blank" rel="external">https://github.com/VernonVan/PPImportArrangerExtension）</a></p>
<h2 id="创建插件"><a href="#创建插件" class="headerlink" title="创建插件"></a>创建插件</h2><ol>
<li><p>创建一个 Cocoa App：Source Editor Extension 不能独立存在，必须依附于 Cocoa App。<br><img src="http://upload-images.jianshu.io/upload_images/698554-a00fabcbca0f7353.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Cocoa App"></p>
<p>​</p>
</li>
<li><p>File -&gt; New -&gt; Target -&gt; Xcode Source Editor Extension 添加一个 Target，并激活这个 Target。<br><img src="http://upload-images.jianshu.io/upload_images/698554-0c32ca262d291557.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Xcode Source Editor Extension"><br><img src="http://upload-images.jianshu.io/upload_images/698554-b6a7d64355a372d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="激活 target"></p>
</li>
</ol>
<p>这样就创建好了一个可运行的 Source Editor Extension，相当的简单。🧐</p>
<h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h2><p><img src="http://upload-images.jianshu.io/upload_images/698554-0e6f169643d8a20f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文件结构"></p>
<ul>
<li>SourceEditorExtension 类：遵循 XCSourceEditorExtension 协议的类，XCSourceEditorExtension 协议的头文件如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@protocol XCSourceEditorExtension &lt;NSObject&gt;</div><div class="line"></div><div class="line">@optional</div><div class="line"></div><div class="line">- (void)extensionDidFinishLaunching;</div><div class="line"></div><div class="line">@property (readonly, copy) NSArray &lt;NSDictionary &lt;XCSourceEditorCommandDefinitionKey, id&gt; *&gt; *commandDefinitions;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>XCSourceEditorExtension 协议只有一个方法和一个属性，extensionDidFinishLaunching 方法是用来在插件加载好后是对插件进行一些准备工作的，根据 <a href="https://developer.apple.com/videos/play/wwdc2016/414/" target="_blank" rel="external">WWDC</a> 的说法，各个插件与 Xcode 本身的初始化过程是在不同进程上进行的，同样地，插件的崩溃并不会引起 Xcode 的崩溃。commandDefinitions 属性则可以动态返回插件的菜单项。</p>
<p>SourceEditorCommand 类：遵循 XCSourceEditorCommand 协议的类，实现插件功能的核心类，对应到插件的菜单项，可以一个菜单项对应到一个 Command 类，也可以多个菜单项对应到一个 Command 类，XCSourceEditorCommand 协议头文件定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@protocol XCSourceEditorCommand &lt;NSObject&gt;</div><div class="line"></div><div class="line">@required</div><div class="line"></div><div class="line">- (void)performCommandWithInvocation:(XCSourceEditorCommandInvocation *)invocation completionHandler:(void (^)(NSError * _Nullable nilOrError))completionHandler;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>XCSourceEditorCommandInvocation 类型的参数 invocation 主要是点击的菜单项的标识、当前文本信息（文本字符串数组、选中区间等）以及点击取消按钮的回调事件，completionHandler 参数则是用来通知 Xcode 本插件已经完成了自己的操作，需要保证一定要调用 completionHandler！否则会出现下图所示的提示，然后菜单项就会变灰不能再点击：<br><img src="http://upload-images.jianshu.io/upload_images/698554-f57b5a31a603f5f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="插件 busy"><br><img src="http://upload-images.jianshu.io/upload_images/698554-8e6d0b4a636883f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="菜单项变灰"></p>
<ul>
<li>Info.plist：Info.plist 文件用于静态配置插件对应的菜单项，如下图所示，XCSourceEditorExtensionPrincipalClass 对应到上文说的 XCSourceEditorExtension 类，XCSourceEditorCommandDefinitions 指定菜单项，XCSourceEditorCommandClassName 对应到上文说的 SourceEditorCommand 类，XCSourceEditorCommandIdentifier 是每个具体菜单项的标识，XCSourceEditorCommandName 是菜单项的描述。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/698554-54682412d2c5b04a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Info.plist"></p>
<ul>
<li>保证 TARGETS 组下的两个 Target 用的同一个签名。</li>
</ul>
<h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>本 Demo 要实现的功能就是按照字母顺序重新排列当前文件的所有 Import，强迫症们一定知道我在说什么🤣，先来看一下效果：<br><img src="http://upload-images.jianshu.io/upload_images/698554-58e34917de432fbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图"><br><img src="http://upload-images.jianshu.io/upload_images/698554-9638491f62073029.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="演示效果"><br>可以点击 Editor -&gt; ImportArranger -&gt; Arrange Imports 重新排列所有的 Imports，甚至还可以为其设置快键键。</p>
<p>实现步骤反而没有什么可说的，主要是操作 invocation.buffer.lines 和 invocation.buffer.selections，分别对应的是当前文件的所有行和当前文件的选择区域，都是可变类型的数组，做完自定义的操作后操作数组即可更新当前文件。注意：<strong>不管是哪条执行路径，一定要保证调用到 completionHandler</strong>。其他需要留意的地方都在代码中的注释中给出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">- (void)performCommandWithInvocation:(XCSourceEditorCommandInvocation *)invocation completionHandler:(void (^)(NSError *_Nullable nilOrError))completionHandler</div><div class="line">&#123;</div><div class="line">    NSMutableArray&lt;NSString *&gt; *lines = invocation.buffer.lines;</div><div class="line">    if (!lines || !lines.count) &#123;</div><div class="line">        completionHandler(nil);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    NSMutableArray&lt;NSString *&gt; *importLines = [[NSMutableArray alloc] init];</div><div class="line">    NSInteger firstLine = -1;</div><div class="line">    for (NSUInteger index = 0, max = lines.count; index &lt; max; index++) &#123;</div><div class="line">        NSString *line = lines[index];</div><div class="line">        NSString *pureLine = [line stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;];       // 去掉多余的空格，以防被空格干扰没检测到 #import</div><div class="line">        // 支持 Objective-C、Swift、C 语言的导入方式</div><div class="line">        if ([pureLine hasPrefix:@&quot;#import&quot;] || [pureLine hasPrefix:@&quot;import&quot;] || [pureLine hasPrefix:@&quot;@class&quot;]</div><div class="line">            || [pureLine hasPrefix:@&quot;@import&quot;] || [pureLine hasPrefix:@&quot;#include&quot;]) &#123;     </div><div class="line">            [importLines addObject:line];</div><div class="line">            if (firstLine == -1) &#123;</div><div class="line">                firstLine = index;      // 记住第一行 #import 所在的行数，用来等下重新插入的位置</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!importLines.count) &#123;</div><div class="line">        completionHandler(nil);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    [invocation.buffer.lines removeObjectsInArray:importLines];</div><div class="line"></div><div class="line">    NSArray *noRepeatArray = [[NSSet setWithArray:importLines] allObjects];         // 去掉重复的 #import</div><div class="line">    NSMutableArray&lt;NSString *&gt; *sortedImports = [[NSMutableArray alloc] initWithArray:[noRepeatArray sortedArrayUsingSelector:@selector(caseInsensitiveCompare:)]];</div><div class="line"></div><div class="line">    // 引用系统文件在前，用户自定义的文件在后</div><div class="line">    NSMutableArray *systemImports = [[NSMutableArray alloc] init];</div><div class="line">    for (NSString *line in sortedImports) &#123;</div><div class="line">        if ([line containsString:@&quot;&lt;&quot;]) &#123;</div><div class="line">            [systemImports addObject:line];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (systemImports.count) &#123;</div><div class="line">        [sortedImports removeObjectsInArray:systemImports];</div><div class="line">        [sortedImports insertObjects:systemImports atIndexes:[NSIndexSet indexSetWithIndexesInRange:NSMakeRange(0, systemImports.count)]];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (firstLine &gt;= 0 &amp;&amp; firstLine &lt; invocation.buffer.lines.count) &#123;</div><div class="line">        // 重新插入排好序的 #import 行</div><div class="line">        [invocation.buffer.lines insertObjects:sortedImports atIndexes:[NSIndexSet indexSetWithIndexesInRange:NSMakeRange(firstLine, sortedImports.count)]];</div><div class="line">        // 选中所有 #import 行</div><div class="line">        [invocation.buffer.selections addObject:[[XCSourceTextRange alloc] initWithStart:XCSourceTextPositionMake(firstLine, 0) end:XCSourceTextPositionMake(firstLine + sortedImports.count, sortedImports.lastObject.length)]];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    completionHandler(nil);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>选择这个插件作为当前 Scheme，选择 Xcode 运行，然后就会弹出一个黑色的 Xcode 供你调试了。<br><img src="http://upload-images.jianshu.io/upload_images/698554-8fb83256d9e38800.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="http://upload-images.jianshu.io/upload_images/698554-7410ea37b33422fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="调试插件"></p>
<h2 id="分发"><a href="#分发" class="headerlink" title="分发"></a>分发</h2><p>插件开发测试完成之后，最重要的当然是将插件分发出去，供他人使用。Apple 在  <a href="https://developer.apple.com/videos/play/wwdc2016/414/" target="_blank" rel="external">WWDC</a> 说到 Xcode Source Editor Extension 是可以上架 Mac App Store 的，不过受限于 Source Editor Extension 功能实在太少，目前也没有在 Mac App Store 上看到很火的插件。更多是直接把 .app 文件上传到 Github 上供人下载（这里有人整理了一些不错的插件：<a href="https://github.com/theswiftdev/awesome-xcode-extensions），具体步骤如下：" target="_blank" rel="external">https://github.com/theswiftdev/awesome-xcode-extensions），具体步骤如下：</a></p>
<h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><p>测试完成后，找到 Products 下面的 .app 文件，注意需要保证上文中说的两个签名是一致的。然后就可以把这个 .app 上传到个人网站或者 Github 上供人下载使用了。<br><img src="http://upload-images.jianshu.io/upload_images/698554-5202f8ddea721d38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=".app 文件"></p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>当我们下载好了一个 .app 格式的插件之后，直接双击这个 .app 文件，然后在 系统偏好设置-&gt; 扩展 -&gt; Xcode Source Editor Extension 勾选该插件，最后重启 Xcode 就可以在 Editor 菜单中找到该插件了。<br><img src="http://upload-images.jianshu.io/upload_images/698554-b35bafce22cccf86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="勾选插件"></p>
<p>还可以在 Xcode 中为插件的菜单项设置快捷键。<br><img src="http://upload-images.jianshu.io/upload_images/698554-d5f2a3622205f490.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设置快键键"></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>至少现有的 Xcode Source Editor Extension 还是比较受限的，接口少的可怜，可想象的空间不是很多，大部分之前第三方插件能做的事情都没办法完成了🤷‍♀️。还是默默希望 Apple 能以更加开放的姿态，提供更多的接口给开发者，Xcode 没办法满足所有人的喜好，起码，能让喜欢折腾的人把它变得更好 :-D</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/19/iOS表情键盘的完整实现/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="ruanpapa & 又吉君">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="ruanpapa和又吉君写字的地方">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="ruanpapa和又吉君写字的地方" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/19/iOS表情键盘的完整实现/" itemprop="url">
                  iOS表情键盘的完整实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-19T23:55:51+08:00">
                2018-01-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ruanpapa-技术贴/" itemprop="url" rel="index">
                    <span itemprop="name">ruanpapa--技术贴</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/01/19/iOS表情键盘的完整实现/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/01/19/iOS表情键盘的完整实现/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/01/19/iOS表情键盘的完整实现/" class="leancloud_visitors" data-flag-title="iOS表情键盘的完整实现">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在公司做了个表情键盘的需求，这个需求的技术难度不会很大，比较偏向业务。但是要把用户体验做的好也是不容易的，其中有几个点需要特别注意。话不多说，下面开始正文(注：本文对应的Demo放在Github上：<a href="https://github.com/VernonVan/PPStickerKeyboard" target="_blank" rel="external">https://github.com/VernonVan/PPStickerKeyboard</a>)。</p>
<h2 id="市面上的表情键盘的分析"><a href="#市面上的表情键盘的分析" class="headerlink" title="市面上的表情键盘的分析"></a>市面上的表情键盘的分析</h2><p>首先来看一下市面上主要的几个APP上的表情键盘，平时使用的时候不会去关注细节，这次特意去使用了表情键盘，发现各个APP的体验还是有优有劣的。</p>
<p>首先是QQ和微信，这两者差不多，切换到表情键盘的时候都是没有光标的，这样的用户体验是非常不好的，没有办法在输入表情的时候框选区域，也不能拖动光标进行特定位置的复制黏贴删除等操作，微信甚至在输入框里显示的都不是点击的表情图片，而是文字描述。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/698554-2c59f42aa0dd0dd1.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信QQ表情键盘.JPG"></p>
<p>接下来看一下微博国际版，国际版调起表情键盘时是有光标的，是一个”真正的”键盘，但是想要拖拽光标的时候，很大概率上会触发到保存图片的行为（如下图所示），导致根本没办法拖动光标。<br><img src="http://upload-images.jianshu.io/upload_images/698554-5f667795a7778a6e.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微博国际版误触.JPG"></p>
<p>同时微博国际版输入框表情黏贴后的光标定位是错误的，如下图，开始时光标是在第4个表情后面，然后复制狗头+害羞两个表情黏贴到光标后，光标还是在第4个表情后，同时黏贴的表情前后都莫名多了空格。<br><img src="http://upload-images.jianshu.io/upload_images/698554-d4cddecefc22cfc9.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微博国际版黏贴.JPG"></p>
<p>最后是微博，微博客户端的表情键盘的体验是非常好的，上面说到的问题都不存在，而且表情键盘的删除按钮还能长按删除输入框的内容。<br><img src="http://upload-images.jianshu.io/upload_images/698554-63023d1dfcce132b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微博表情键盘.jpg"></p>
<h2 id="表情键盘的实现"><a href="#表情键盘的实现" class="headerlink" title="表情键盘的实现"></a>表情键盘的实现</h2><h4 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h4><p>主要实现了以下几个功能</p>
<ul>
<li>能输入表情，有光标，支持复制黏贴删除表情等</li>
<li>长按预览表情</li>
<li>删除表情、长按连续删除表情</li>
<li>适配 iPhone X<br><img src="http://upload-images.jianshu.io/upload_images/698554-9d1661ee627dc3ca.GIF?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="演示.GIF"></li>
</ul>
<h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p>首先，表情包的图片是用bundle的形式组织的，用<code>PPSticker</code>类表征一套表情包，用<code>PPEmoji</code>类表征某一个表情，用一个plist作为配置文件，存储表情包的信息。<br><img src="http://upload-images.jianshu.io/upload_images/698554-10847f03391e9560.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表情的组织.jpg"></p>
<p><code>PPStickerDataManager</code>类主要负责数据部分，用单例的形式，这样可以在初始化的时候只会读取一次plist文件中的所有表情信息；同时我们把输入框内容发到服务端以及从服务端请求到的都是纯文本的，比如会把 “笑死了🤣” 转成 “笑死了[笑哭]” 这样的纯文本，而不是直接把表情图片直接发到服务端，也就是说项目中有大量的地方会有把文本-&gt;表情的操作，所以<code>PPStickerDataManager</code>类也提供匹配某段纯文本中的表情，并把文本替换为图片的功能，<code>PPStickerDataManager</code>类的头文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@interface PPStickerDataManager : NSObject</div><div class="line"></div><div class="line">+ (instancetype)sharedInstance;</div><div class="line"></div><div class="line">/// 所有的表情包</div><div class="line">@property (nonatomic, strong, readonly) NSArray&lt;PPSticker *&gt; *allStickers;</div><div class="line"></div><div class="line">/* 匹配给定attributedString中的所有emoji，如果匹配到的emoji有本地图片的话会直接换成本地的图片</div><div class="line"> *</div><div class="line"> * @param attributedString 可能包含表情包的attributedString</div><div class="line"> * @param font 表情图片的对齐字体大小</div><div class="line"> */</div><div class="line">- (void)replaceEmojiForAttributedString:(NSMutableAttributedString *)attributedString font:(UIFont *)font;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="“真正的”键盘"><a href="#“真正的”键盘" class="headerlink" title="“真正的”键盘"></a>“真正的”键盘</h4><p>真正的键盘也就是说调起表情键盘时输入框是有光标的，能进行拖拽光标、选中区域等的操作，这样的体验才是与系统键盘一致的。其实系统已经提供好了接口给我们直接使用，<code>UITextView</code>和<code>UITextField</code>都有的<code>inputView</code>和<code>inputAccessoryView</code>就是用来实现自定义键盘的，这两个属性的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// Presented when object becomes first responder.  If set to nil, reverts to following responder chain.  If</div><div class="line">// set while first responder, will not take effect until reloadInputViews is called.</div><div class="line">@property (nullable, readwrite, strong) UIView *inputView;             </div><div class="line">@property (nullable, readwrite, strong) UIView *inputAccessoryView;</div></pre></td></tr></table></figure>
<p>同时系统键盘在 设置-&gt;声音-&gt;按键音 选项打开且手机非静音状态下输入是有按键的声音的，这个按键音也是可以支持的，只要自定义键盘类遵循<code>UIInputViewAudioFeedback</code>协议，同时实现 <code>enableInputClicksWhenVisible</code>方法并返回YES，这样就可以在点击表情的时候调用<code>[[UIDevice currentDevice] playInputClick]</code>方法发出按键音了，详情请查看<a href="https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/InputViews/InputViews.html" target="_blank" rel="external">苹果的官方文档</a>。</p>
<p>下面是Demo中键盘切换方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (void)changeKeyboardTo:(PPKeyboardType)toType</div><div class="line">&#123;</div><div class="line">    switch (toType) &#123;</div><div class="line">        case PPKeyboardTypeSystem:</div><div class="line">            self.textView.inputView = nil;    // 切换到系统键盘</div><div class="line">            [self.textView reloadInputViews]; // 调用reloadInputViews方法会立刻进行键盘的切换</div><div class="line">            break;</div><div class="line">        case PPKeyboardTypeSticker:            </div><div class="line">            self.textView.inputView = self.stickerKeyboard; // 切换到自定义的表情键盘</div><div class="line">            [self.textView reloadInputViews];</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="去除表情的拖拽交互"><a href="#去除表情的拖拽交互" class="headerlink" title="去除表情的拖拽交互"></a>去除表情的拖拽交互</h4><p>在iOS11上，<code>UITextView</code>上的<code>NSTextAttachment</code>（表情）默认可以进行拖拽交互，但是却导致拖动光标时很容易触发这个交互（图示可以查看上面说到的微博国际版中的误触）。一番查找之后才找到一个比较隐蔽的属性：<code>textDragInteraction</code>，直接设置为<code>NO</code>就能禁止掉<code>NSTextAttachment</code>的拖拽交互。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (@available(iOS 11.0, *)) &#123;	// 只在iOS11及以上才有这个属性</div><div class="line">     _textView.textDragInteraction.enabled = NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="与服务端的交互"><a href="#与服务端的交互" class="headerlink" title="与服务端的交互"></a>与服务端的交互</h4><p>我们在输入框中输入的内容与服务端进行交互的时候都是用纯文本的，比如会把 “笑死了🤣” 转成 “笑死了[笑哭]” 这样的纯文本发到服务端，而不是直接发表情图片，向服务端请求内容的时候也是传回 “笑死了[笑哭]”，然后客户端再根据正则匹配找出表情替换成对应的表情图片，然后显示到页面上。具体过程可以看下图：<br><img src="http://upload-images.jianshu.io/upload_images/698554-00199a31ec46945d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="与服务端的交互.png"></p>
<p>也就是说，我们设置到输入框的<code>NSAttributedString</code>中的每一个<code>NSTextAttachment</code>都有一个”隐藏的”属性—表情的文本描述，这里对<code>NSAttributedString</code>进行拓展就能实现。<code>pp_setTextBackedString</code>可以对<code>NSAttributedString</code>的指定<code>range</code>设置一个<code>PPTextBackedString</code>类型的属性，而<code>pp_plainTextForRange</code>能拿到<code>NSAttributedString</code>指定<code>range</code>的纯文本。具体实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">@implementation NSAttributedString (PPAddition)</div><div class="line"></div><div class="line">- (NSString *)pp_plainTextForRange:(NSRange)range</div><div class="line">&#123;</div><div class="line">    if (range.location == NSNotFound || range.length == NSNotFound) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    NSMutableString *result = [[NSMutableString alloc] init];</div><div class="line">    if (range.length == 0) &#123;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    NSString *string = self.string;</div><div class="line">    [self enumerateAttribute:PPTextBackedStringAttributeName inRange:range options:kNilOptions usingBlock:^(id value, NSRange range, BOOL *stop) &#123;</div><div class="line">        PPTextBackedString *backed = value;</div><div class="line">        if (backed &amp;&amp; backed.string) &#123;</div><div class="line">            [result appendString:backed.string];</div><div class="line">        &#125; else &#123;</div><div class="line">            [result appendString:[string substringWithRange:range]];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation NSMutableAttributedString (PPAddition)</div><div class="line"></div><div class="line">- (void)pp_setTextBackedString:(PPTextBackedString *)textBackedString range:(NSRange)range</div><div class="line">&#123;</div><div class="line">    if (textBackedString &amp;&amp; ![NSNull isEqual:textBackedString]) &#123;</div><div class="line">        [self addAttribute:PPTextBackedStringAttributeName value:textBackedString range:range];</div><div class="line">    &#125; else &#123;</div><div class="line">        [self removeAttribute:PPTextBackedStringAttributeName range:range];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="灵活的光标"><a href="#灵活的光标" class="headerlink" title="灵活的光标"></a>灵活的光标</h4><p>表情功能，<code>UITextView</code>都是用<code>NSAttributedString</code>进行赋值的，并且我们底层其实还是用上面说到的纯文本进行实现的，那么把 [笑死] 转成 🤣 就会从4个字符变成1个字符，这里是有差值的，如果不处理的话就会出现上面提到的微博国际版中复制黏贴输入框的表情会导致光标位置不对，甚至莫名其妙多出前后空格的问题。为了精准的定位光标，我们需要自行处理好这些问题。</p>
<p>这里自己继承并实现了<code>UITextView</code>的子类<code>PPStickerTextView</code>，在这个类中重载复制、黏贴、剪切等操作，分别对应的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)cut:(id)sender;		// 剪切</div><div class="line"></div><div class="line">- (void)copy:(id)sender;	// 复制</div><div class="line"></div><div class="line">- (void)paste:(id)sender;	// 黏贴</div></pre></td></tr></table></figure>
<p>下面以剪切方法举例，看看怎么处理光标的问题，需要注意的地方请看对应的注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (void)cut:(id)sender</div><div class="line">&#123;</div><div class="line">    // 1.从textView中拿到对应的纯文本，比如：笑死了[笑死]</div><div class="line">    NSString *string = [self.attributedText pp_plainTextForRange:self.selectedRange];</div><div class="line">    if (string.length) &#123;</div><div class="line">      	// 2. 将纯文本写入到剪贴板中</div><div class="line">        [UIPasteboard generalPasteboard].string = string;</div><div class="line"></div><div class="line">      	// 3. 记住当前的光标位置</div><div class="line">        NSRange selectedRange = self.selectedRange;</div><div class="line">        NSMutableAttributedString *attributeContent = [[NSMutableAttributedString alloc] initWithAttributedString:self.attributedText];</div><div class="line">      	// 4. 将检测到是表情的文本替换成对应的图片</div><div class="line">        [attributeContent replaceCharactersInRange:self.selectedRange withString:@&quot;&quot;];</div><div class="line">        self.attributedText = attributeContent;</div><div class="line">      </div><div class="line">      	// 5. 重新设置光标</div><div class="line">        self.selectedRange = NSMakeRange(selectedRange.location, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>技术点的分析就是以上这些，详细的代码可以clone代码查看：<a href="https://github.com/VernonVan/PPStickerKeyboard" target="_blank" rel="external">https://github.com/VernonVan/PPStickerKeyboard</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/30/2017年终总结/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="ruanpapa & 又吉君">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="ruanpapa和又吉君写字的地方">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="ruanpapa和又吉君写字的地方" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/30/2017年终总结/" itemprop="url">
                  2017年终总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-30T14:13:29+08:00">
                2017-12-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ruanpapa-又吉君的日常/" itemprop="url" rel="index">
                    <span itemprop="name">ruanpapa&又吉君的日常</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/12/30/2017年终总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/12/30/2017年终总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/12/30/2017年终总结/" class="leancloud_visitors" data-flag-title="2017年终总结">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这几天被“18岁”、“网易云音乐年度听歌报告”、“支付宝年度账单”各种刷屏，大家都玩的不亦乐乎，毕竟也是年底了，辛苦工作学习了一年了，也该是时候放松一下了。自己通常都不是太喜欢凑热闹的，偏安一隅，躲在自己的小角落，写下刚刚过去的2017年发生的大事小情，顺便展望一下明年。这也是我第一次提笔写下自己的年终总结，也希望自己以后都能坚持这件事情。</p>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>过去的这一年，最先想说的还是工作上的事情，毕竟今年告别用了16年的学生身份。</p>
<p>前半年一直是实习生身份，上下班都是步行回学校，完全没有觉得生活有发生什么变化。公司给了大量的时间自己学习与熟悉技术，所以上班并没有感到什么压力，下了班回去宿舍，打打球，这里溜达溜达，那里吹吹水，偶尔抽出时间处理论文、入党、毕业的事宜，一切如故。</p>
<p>接下来顺利转了正，到现在也半年了，这半年是技术快速进步的一段时间，也开始接触比较复杂的需求。以前常常能在社区看到大家吐槽做业务的程序员是最底层的，我倒是不这么认为，我觉得凡事都需要循序渐进，不是每个人都能一入门就玩核心算法、深度学习、底层架构这些高深的东西的，相反，当前任何公司绝大部分的都是这些业务需求，做需求的能力扎实了，到哪里都不愁找不到工作。正如我在入职的职业规划上写的：希望自己在未来的一、两年内能尽量的做各种需求。</p>
<p>但是只停留在术而不去钻研道的话，这样职业生涯也不会太长久，自己也在空余时间接触了一下clang+llvm、逆向工程等比较高深的技术，铩羽而归算不上，反正还没有什么实际产出，还需要的前期知识、铺垫比较多，我会慢慢补上。同时自己也一直对金融这一块比较有兴趣，平时经常驻足新浪财经、虎嗅等各种财经类的网站，尤其自己也是搞技术的，互联网+金融，完全是一片广阔的天地。</p>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>今年最重要的是什么呢？那当然是，我收获了一个全世界最可爱的女朋友啦~(≧▽≦)/。1月10号初识，3月7号正式在一起，不知不觉竟然携手走过了快一年了。这一年里，有过很多个阶段。从各自试探，到互生好感，再到每天甜甜腻腻，再到现在更多了一份理性。期间有因为小事吵吵闹闹，也有三观的激烈碰撞，异地总是比较辛苦的，但是能经受的住异地的考验，那得来的才更加难能可贵。</p>
<p>这一年也是我真正独立生活的第一年，很庆幸自己还是保持了一些良好的习惯，房间总是会打扫收拾，周末的时候会自己煮饭，平时会进行阅读学习，偶尔还会去跑步。不过跑步运动这一段时间真的是松懈了，总觉得跑起来动力不足，时常跑了没几公里就觉得够了，然后就停下了脚步，新的一年，还是希望自己能把运动的好习惯重拾起来。</p>
<h2 id="上一年定下的目标"><a href="#上一年定下的目标" class="headerlink" title="上一年定下的目标"></a>上一年定下的目标</h2><ul>
<li>写<strong>5</strong>篇高质量的技术文章（完成度60%）：今年的产出只有3篇技术文章，实在是太少了，也是因为自己今年比较多私人事情，明年还是要更多的进行产出。不过今年倒是打理了自己的博客、掘金、简书等账号，更多的将自己的产出放到社交平台上互动，尤其是掘金，竟然已经有了2000个关注者了，但是自己心里清楚离大牛还有很远的距离，要多多努力了。</li>
<li>开发并维护1个开源库（完成）：呃。。。看着Github上稀稀拉拉的contributions，实在拿不出手啊。</li>
<li>翻译5篇技术文章 3/5（完成度60%）：<a href="https://vernonvan.github.io/2017/07/21/%E7%BF%BB%E8%AF%91%E6%9D%82%E5%BF%97%E5%BA%94%E7%94%A8/" target="_blank" rel="external">iOS的Core Text教程：制作一个杂志应用</a>、iPhone X 网页设计(校对)、<a href="https://vernonvan.github.io/2017/10/22/%E7%BF%BB%E8%AF%91%E5%85%B3%E4%BA%8ESwift%E7%9A%84%E7%BC%96%E8%AF%91%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96/" target="_blank" rel="external">关于Swift的编译时间优化</a>。</li>
<li>看15本书（完成）（《南京大屠杀》、《激荡三十年》、《史蒂夫乔布斯传》、《穷查理宝典》、《100个Swift2开发必备Tip》、《亮剑》、《数学之美》、《浪潮之巅》、《欧神文集01》、《ASO优化道与术》、《在你身边，为你设计Ⅱ》、《腾讯传》、《欧神文集02》、《iOS应用逆向工程》、《欧神文集03、04、05》）：今年的阅读还是达标的，有自己感兴趣的人物传记、历史等方面的书籍，也有一些是技术书籍、投资入门方面的一些书。</li>
<li>开始接触理财与投资产品</li>
</ul>
<h2 id="我想要的2018"><a href="#我想要的2018" class="headerlink" title="我想要的2018"></a>我想要的2018</h2><ul>
<li>写6篇技术文章，并更多的在社区中互动。</li>
<li>开发一个独立APP</li>
<li>技术方面还是深耕iOS：逆向工程、图像处理，拓展方面的打算入门一下机器学习、区块链的基础知识</li>
<li>看12本书，而且得保证看了的书都写一篇读后感，否则不能算上这本书。</li>
<li>争取能做到Github的contributions能亮起来一半吧。。。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/22/翻译关于Swift的编译时间优化/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="ruanpapa & 又吉君">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="ruanpapa和又吉君写字的地方">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="ruanpapa和又吉君写字的地方" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/22/翻译关于Swift的编译时间优化/" itemprop="url">
                  (翻译)关于Swift的编译时间优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-22T21:39:50+08:00">
                2017-10-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ruanpapa-技术贴/" itemprop="url" rel="index">
                    <span itemprop="name">ruanpapa--技术贴</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/22/翻译关于Swift的编译时间优化/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/10/22/翻译关于Swift的编译时间优化/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/10/22/翻译关于Swift的编译时间优化/" class="leancloud_visitors" data-flag-title="(翻译)关于Swift的编译时间优化">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文链接：<a href="https://medium.com/@RobertGummesson/regarding-swift-build-time-optimizations-fc92cdd91e31" target="_blank" rel="external">Regarding Swift build time optimizations</a></p>
<p>上周，在我读完 <a href="https://medium.com/@nickoneill" target="_blank" rel="external">@nickoneill</a> 写的一篇优秀的博文<a href="https://medium.com/swift-programming/speeding-up-slow-swift-build-times-922feeba5780#.k0pngnkns" target="_blank" rel="external">《为缓慢的Swift编译时间提速》</a>后，我发现用一个不同的角度去审视 Swift 代码并不是很难的一件事。</p>
<p>可以被认为是简洁的一行代码现在引发了一个新的问题 – 是否应该把这行代码重构成对应的9行代码以让编译器更容易工作（看看接下来要讲的关于空合运算符(nil coalescing operator)的示例）？到底哪个才是更重要的，简洁的代码还是对编译器友好的代码？这取决于项目的大小和开发者的想法。</p>
<h4 id="慢着。。。这里有一个-Xcode-插件"><a href="#慢着。。。这里有一个-Xcode-插件" class="headerlink" title="慢着。。。这里有一个 Xcode 插件"></a>慢着。。。这里有一个 Xcode 插件</h4><p>在展示具体的例子之前，我先想到就是手动查看日志是一件非常耗时的事情。有人提出了用终端命令可以让这件事情变得比较容易，但是我更进一步，把这个用 <a href="https://github.com/RobertGummesson/BuildTimeAnalyzer-for-Xcode" target="_blank" rel="external">Xcode 插件</a> 给实现出来了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/698554-be809654f87b2336.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Xcode插件.png"></p>
<p>对我来说，最初的目的就是找到并修复最耗时的地方，但我现在的想法是让它经历更多的迭代过程。这样的话我就不仅可以让代码编译更有效率，还可以防止第一次进入项目的耗时。</p>
<h4 id="更加惊喜的是"><a href="#更加惊喜的是" class="headerlink" title="更加惊喜的是"></a>更加惊喜的是</h4><p>我经常在多个 Git 分支间跳来跳去，等待一个缓慢的项目编译完成往往浪费了大量的时间。我想了好长一段时间为什么我的一个宠物项目会编译地这么缓慢（大概2万行 Swift 代码）。</p>
<p>在我学习了究竟是原因导致的这件事之后，我不得不承认我的确很吃惊，一行代码就需要几秒钟来编译。</p>
<p>让我们看看几个例子。</p>
<h4 id="空合操作符"><a href="#空合操作符" class="headerlink" title="空合操作符"></a>空合操作符</h4><p>编译器是很不喜欢这里的第一种方式的。在展开下面两处简写的代码之后，编译时间减少了99.4%。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 编译时间: 5238.3ms</span></div><div class="line"><span class="keyword">return</span> <span class="type">CGSize</span>(width: size.width + (rightView?.bounds.width ?? <span class="number">0</span>) + (leftView?.bounds.width ?? <span class="number">0</span>) + <span class="number">22</span>, height: bounds.height)</div><div class="line"></div><div class="line"><span class="comment">// 编译时间: 32.4ms</span></div><div class="line"><span class="keyword">var</span> padding: <span class="type">CGFloat</span> = <span class="number">22</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> rightView = rightView &#123;</div><div class="line">    padding += rightView.bounds.width</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> leftView = leftView &#123;</div><div class="line">    padding += leftView.bounds.width</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="type">CGSizeMake</span>(size.width + padding, bounds.height)</div></pre></td></tr></table></figure>
<h4 id="ArrayOfStuff-Stuff"><a href="#ArrayOfStuff-Stuff" class="headerlink" title="ArrayOfStuff + [Stuff]"></a>ArrayOfStuff + [Stuff]</h4><p>这个看起来像下面这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> <span class="type">ArrayOfStuff</span> + [<span class="type">Stuff</span>]</div><div class="line"><span class="comment">// 而不是</span></div><div class="line"><span class="type">ArrayOfStuff</span>.append(stuff)</div><div class="line"><span class="keyword">return</span> <span class="type">ArrayOfStuff</span></div></pre></td></tr></table></figure>
<p>我经常这样做，每次都会对所需的编译时间产生影响。下面是最差的一个，这里的编译时间减少了97.9％。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 编译时间: 1250.3ms</span></div><div class="line"><span class="keyword">let</span> systemOptions = [ <span class="number">7</span>, <span class="number">14</span>, <span class="number">30</span>, -<span class="number">1</span> ]</div><div class="line"><span class="keyword">let</span> systemNames = (<span class="number">0</span>...<span class="number">2</span>).<span class="built_in">map</span>&#123; <span class="type">String</span>(format: localizedFormat, systemOptions[$<span class="number">0</span>]) &#125; + [<span class="type">NSLocalizedString</span>(<span class="string">"everything"</span>, comment: <span class="string">""</span>)]</div><div class="line"><span class="comment">// 一些中间的代码</span></div><div class="line">labelNames = <span class="type">Array</span>(systemNames[<span class="number">0</span>..&lt;<span class="built_in">count</span>]) + [systemNames.last!]</div><div class="line"></div><div class="line"><span class="comment">// 编译时间: 25.5ms</span></div><div class="line"><span class="keyword">let</span> systemOptions = [ <span class="number">7</span>, <span class="number">14</span>, <span class="number">30</span>, -<span class="number">1</span> ]</div><div class="line"><span class="keyword">var</span> systemNames = systemOptions.<span class="built_in">dropLast</span>().<span class="built_in">map</span>&#123; <span class="type">String</span>(format: localizedFormat, $<span class="number">0</span>) &#125;</div><div class="line">systemNames.append(<span class="type">NSLocalizedString</span>(<span class="string">"everything"</span>, comment: <span class="string">""</span>))</div><div class="line"><span class="comment">// 一些中间的代码</span></div><div class="line">labelNames = <span class="type">Array</span>(systemNames[<span class="number">0</span>..&lt;<span class="built_in">count</span>])</div><div class="line">labelNames.append(systemNames.last!)</div></pre></td></tr></table></figure>
<h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><p>仅仅只是把三元运算符替换成 if-else 语句，就让编译时间减少了92.9%。如果将 map 换成 for 循环，就又能减少75%（但是那样的话我的眼睛可就受不了了）。😉</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 编译时间: 239.0ms</span></div><div class="line"><span class="keyword">let</span> labelNames = type == <span class="number">0</span> ? (<span class="number">1</span>...<span class="number">5</span>).<span class="built_in">map</span>&#123;type0ToString($<span class="number">0</span>)&#125; : (<span class="number">0</span>...<span class="number">2</span>).<span class="built_in">map</span>&#123;type1ToString($<span class="number">0</span>)&#125;</div><div class="line"></div><div class="line"><span class="comment">// 编译时间: 16.9ms</span></div><div class="line"><span class="keyword">var</span> labelNames: [<span class="type">String</span>]</div><div class="line"><span class="keyword">if</span> type == <span class="number">0</span> &#123;</div><div class="line">    labelNames = (<span class="number">1</span>...<span class="number">5</span>).<span class="built_in">map</span>&#123;type0ToString($<span class="number">0</span>)&#125;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    labelNames = (<span class="number">0</span>...<span class="number">2</span>).<span class="built_in">map</span>&#123;type1ToString($<span class="number">0</span>)&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="转换-CGFloat-到-CGFloat"><a href="#转换-CGFloat-到-CGFloat" class="headerlink" title="转换 CGFloat 到 CGFloat"></a>转换 CGFloat 到 CGFloat</h4><p>没听懂我在说什么？其实下面例子中值已经是 CGFloat 了，并且有些括号是多余的。在清理完这些冗余之后，编译时间减少了99.9%。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 编译时间: 3431.7 ms</span></div><div class="line"><span class="keyword">return</span> <span class="type">CGFloat</span>(<span class="type">M_PI</span>) * (<span class="type">CGFloat</span>((hour + hourDelta + <span class="type">CGFloat</span>(minute + minuteDelta) / <span class="number">60</span>) * <span class="number">5</span>) - <span class="number">15</span>) * unit / <span class="number">180</span></div><div class="line"></div><div class="line"><span class="comment">// 编译时间: 3.0ms</span></div><div class="line"><span class="keyword">return</span> <span class="type">CGFloat</span>(<span class="type">M_PI</span>) * ((hour + hourDelta + (minute + minuteDelta) / <span class="number">60</span>) * <span class="number">5</span> - <span class="number">15</span>) * unit / <span class="number">180</span></div></pre></td></tr></table></figure>
<h4 id="Round"><a href="#Round" class="headerlink" title="Round()"></a>Round()</h4><p>下面是一个很奇怪的例子，下面的例子中变量是一个局部变量与实例变量的混合。这个问题似乎不是出在四舍五入本身，而是在于结合代码的方法。去掉四舍五入的方法大概能减少 <strong>97.6%</strong> 的构建时间。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 编译时间: 1433.7ms</span></div><div class="line"><span class="keyword">let</span> expansion = a — b — <span class="built_in">c</span> + round(d * <span class="number">0.66</span>) + e</div><div class="line"><span class="comment">// 编译时间: 34.7ms</span></div><div class="line"><span class="keyword">let</span> expansion = a — b — <span class="built_in">c</span> + d * <span class="number">0.66</span> + e</div></pre></td></tr></table></figure>
<p>注意：以上所有测试都在MacBool Air(13英寸，2013年中)上进行。</p>
<h4 id="尝试一下吧"><a href="#尝试一下吧" class="headerlink" title="尝试一下吧"></a>尝试一下吧</h4><p>不管你是否面临过编译时间太长的问题，编写对编译器友好的代码都是非常有用的。我确信你会在其中找到一些惊喜。作为参考，这里有完整的代码，我的工程中可以5秒内完成编译…</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMExpandingTextField</span>: <span class="title">UITextField</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">textFieldEditingChanged</span><span class="params">()</span></span> &#123;</div><div class="line">        invalidateIntrinsicContentSize()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">intrinsicContentSize</span><span class="params">()</span></span> -&gt; <span class="type">CGSize</span> &#123;</div><div class="line">        <span class="keyword">if</span> isFirstResponder(), <span class="keyword">let</span> text = text &#123;</div><div class="line">            <span class="keyword">let</span> size = text.sizeWithAttributes(typingAttributes)</div><div class="line">            <span class="keyword">return</span> <span class="type">CGSize</span>(width: size.width + (rightView?.bounds.width ?? <span class="number">0</span>) + (leftView?.bounds.width ?? <span class="number">0</span>) + <span class="number">22</span>, height: bounds.height)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.intrinsicContentSize()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/12/响应式编程与MVVM架构--理论篇/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="ruanpapa & 又吉君">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="ruanpapa和又吉君写字的地方">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="ruanpapa和又吉君写字的地方" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/12/响应式编程与MVVM架构--理论篇/" itemprop="url">
                  响应式编程与MVVM架构—理论篇
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-12T10:26:38+08:00">
                2017-10-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ruanpapa-技术贴/" itemprop="url" rel="index">
                    <span itemprop="name">ruanpapa--技术贴</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/12/响应式编程与MVVM架构--理论篇/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/10/12/响应式编程与MVVM架构--理论篇/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/10/12/响应式编程与MVVM架构--理论篇/" class="leancloud_visitors" data-flag-title="响应式编程与MVVM架构—理论篇">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前段时间，在使用了一段时间的MVVM架构之后，我从实际的项目中抽离出来，对使用MVVM架构的整个过程进行了总结，对于架构、对于编程思维又有了不一样的体会。于是提笔写下自己探索MVVM架构的经验和心得，以飨读者。</p>
<p>本文会先对MVC架构做一个回顾，明确MVC中各层的职责；然后会提出MVVM架构的概念，本来接下来应该顺势举几个MVVM的例子进行说明的，但是考虑到响应式编程之于MVVM的重要性，所以在举例之前会先讲解一下响应式编程的概念(出于篇幅考虑，将MVVM架构实践独立成一篇文章，想直接看实例的请移驾<a href="">这里</a>)；最后会对MVC和MVVM的取舍谈谈自己的看法。话不多说，现在进入正题。</p>
<h2 id="MVC架构"><a href="#MVC架构" class="headerlink" title="MVC架构"></a>MVC架构</h2><p>MVC(Model-View-Controller)，是一种常见的客户端软件开发框架，具体到iOS上，绝大部分人从开始接触iOS编程的时候都被告知MVC就是事实上的默认框架。系统也为我们实现好了公共的视图类：UIView 和控制器类：UIViewController。大多数时候，我们都需要继承这些类来实现我们的程序逻辑，因此，我们几乎逃避不开MVC这种设计模式。下面就对MVC各层的职责进行明确：</p>
<h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p>Model层 是服务端数据在客户端的映射，是薄薄的一层，完全可以用struct表征。下面看一个实例：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/698554-39fbabcc27672a79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Model"></p>
<p>可以看到，Model 层通常是服务端传回的 JSON数据的映射，对应为一个一个的属性。不过现在也有很多人将网络层(Service层)归到Model中，也就是MVC(S)架构。同时，大部分时候数据的持久化操作也会放在Model层中。</p>
<p>总结一下，Model层的职责主要有以下几项：<strong>HTTP请求、进行字段验证、持久化</strong>等。</p>
<h3 id="View层"><a href="#View层" class="headerlink" title="View层"></a>View层</h3><p>View层是展示在屏幕上的视图的封装，在 iOS 中也就是UIView以及UIView的子类。下面是UIView的继承层级图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/698554-075df5d6895547a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="View"></p>
<p>View层的职责是<strong>展示内容</strong>和<strong>接受用户的操作与事件</strong>。</p>
<h3 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h3><p>看了Model层和View层如此简单清晰的定义，如果你以为接下来要讲的Controller层的定义也跟这两层一样，那你就要失望了。</p>
<p>粗略总结了一下，Controller层的职责包括但不限于：<strong>管理根视图以及其子视图的生命周期</strong>、<strong>展示内容和布局</strong>、<strong>处理用户行为</strong>(如按钮的点击和手势的触发等)、<strong>储存当前界面的状态</strong>(例如分页加载的页数、是否正在进行网络请求的布尔值等)、<strong>处理界面的跳转</strong>、<strong>作为UITableView以及其它容器视图的代理以及数据源</strong>、<strong>业务逻辑</strong>和<strong>各种动画效果</strong>等。</p>
<p>画风似乎不对啊，为什么Controller层的职责比其他两层加起来还多？</p>
<h3 id="MVC的困境"><a href="#MVC的困境" class="headerlink" title="MVC的困境"></a>MVC的困境</h3><p>因为MVC架构中Controller层往往代码很多，动辄2、3千行的这一特点，MVC也常常被调侃成是 Massive View Controller。造成这个问题的原因就是MVC的定义太过简单朴素，要知道支撑一个尚不算大的企业级应用都动辄几十万行代码，还不包括各种依赖的第三方库。这么多的代码如何安置？按照传统的MVC定义，分割了小部分到Model层和View层，剩下的代码都没有其他地方可以去了，于是被统统的丢到了Controll层中。</p>
<p>庞大的Controller层带来的问题就是难以维护、难以测试。而且其中充斥着大量的状态值，一个任务的完成依赖于好几个状态值，而一个状态值又同时参与到多个任务中，这样复杂的多对多关系带来的问题就是开发效率低下，需要花费大量的时间周旋在各个状态值之间，对以后的功能拓展、业务添加也造成了障碍。</p>
<p>这样的前提下，架构的改进就显得非常有必要了。</p>
<h2 id="MVVM架构初探"><a href="#MVVM架构初探" class="headerlink" title="MVVM架构初探"></a>MVVM架构初探</h2><p>MVVM(Model-View-ViewModel)，2005年由微软的WPF和Silverlight的架构师 John Gossman 提出，是MVP模式与WPF结合发展演变过来的一种架构框架。MVVM实质上还是MVC架构范围，是一个精心优化的MVC架构，所以与MVC架构是兼容的。</p>
<p>MVVM首先将View层和Controller层进行了合并，统称为View层，因为View层和Controller层往往是一起出现的。然后引入了一个新的模块 — <strong>ViewModel层</strong>，ViewModel层承载的内容就是之前在Controller层中<strong>视图展现逻辑</strong>。MVVM的图示如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/698554-5f804627e25202e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MVVM图示"></p>
<p>什么是视图展现逻辑呢？在一款应用中，数据的来源可能是服务端返回、数据库获取和用户输入，然后存储在Model中，但是这样的数据是一种“未经格式化的”原始数据，还不能直接显示到屏幕上。比如Model中可能有姓、名、昵称等属性，在某些界面中需要显示成”姓名”的样式，某些界面中显示成”名姓”的样式，某些界面中显示”昵称”的样式。视图展现逻辑就是把这些原始数据经过业务需求处理成展现到屏幕上的数据。可以把一个应用看成是播出一个新闻节目，Model层就是一大堆繁杂的稿件，View层就是主持人实际播报的新闻，而ViewModel层就是幕后的编辑处理团队，负责从凌乱的稿件中抽出需要的信息，整理成播报时用的稿件。这样主持人拿着整理好的稿件，就能轻松的播报新闻了。</p>
<p>但是呢，平白无故多了一个ViewModel层。多一个层带来的直接问题就是信息的传递问题，层与层之间需要互通信息，进行交流。在MVVM架构的实现中，开发人员想出了一个与传统消息传递所不一样的方式，这就引出了响应式编程的概念。</p>
<h2 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h2><p>响应式编程(Reactive Programming)，是一种面向数据流和变化传播的范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。举个维基百科中的例子：c:=a+b表示将表达式的结果赋给c，而之后改变a或b的值不会影响c。但在响应式编程中，c的值会随着a或b的更新而更新。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/698554-0a3c4d4e90a11372.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="响应式编程"></p>
<p>也就是说，<strong>上图中c的值最后会是5</strong>。</p>
<p>同样的例子还有Excel中的单元格，单元格可以包含字面值或类似”=B1+C1”的公式，而包含公式的单元格的值会依据其他单元格的值的变化而变化 。</p>
<p>如何实现所谓的响应式编程？在WPF中官方提供了Data Binding技术，macOS中也有类似的Cocoa Binding框架，但是在iOS中官方没有提供这样的框架。于是GitHub上出现了ReactiveCococa(以下简称为RAC)和RxSwift等优秀的第三方框架。</p>
<p>在RAC的思维中，iOS上的一切都是在变化的数据流，比如输入框上用户正在不断输入的文字、被点击的按钮、旋转缩放的视图、不断改变的NSString等等，这些就像是一个”水龙头”，当有变化产生的时候，水龙头就会出水，把变化传递下去，对这个变化感兴趣的人就可以在这个水龙头上套一个”水管”，这个人就成为了一个接收者(subscriber)，当有变化产生的时候，接收者就能从水管中拿到这个变化的具体信息。</p>
<p>RAC就提供了这样的”水管”，但是和现实中的水管有所不同，RAC有自己的一些限制：水管中传递的不是水，而是一个个的”玻璃球”，这些玻璃球的直径和水管的内径一样大，保证了玻璃球在水管中都是依次排列通过的，这就保证了不会出现多个玻璃球并列通过的情况。更加重要的是，在拿到玻璃球之前，可以对其进行一些个性化的定制。例如，可以在水龙头上加一个过滤嘴(filter)，不符合的不让通过；也可以加一个改动装置，把球改变成符合自己的需求(map)；还可以把多个水龙头合并成一个新的水龙头(combineLatest:reduce:)，经过了这些定制之后，出来的符合要求的玻璃球就能拿来直接用了。</p>
<p>在这么强大的框架帮助下，MVVM所引入的ViewModel层和其他层之间的通讯问题得到了解决。</p>
<h2 id="MVC还是MVVM？"><a href="#MVC还是MVVM？" class="headerlink" title="MVC还是MVVM？"></a>MVC还是MVVM？</h2><p>在考虑是否要选择MVVM架构之前，先来总结一下MVVM的优势和不足。</p>
<p>MVVM主要有以下几个优势：</p>
<ul>
<li>Controller层瘦身：将视图展现逻辑抽出到ViewModel层带来的直接变化就是Controller层变得更加轻量级，更加容易维护。</li>
<li>更加容易测试：Controller层代码减少了，也意味着对Controller层的测试更加容易。</li>
<li>兼容MVC：选择MVVM并不意味着完全摒弃MVC，MVVM相当于是MVC的超集，所以和MVC是兼容的，也就是说，可以只在某一个模块中使用MVVM，不用担心迁移架构时会造成需要全局重构的问题。</li>
<li>解决状态以及状态之间依赖过多的问题：这个优势是由RAC所带来的，响应式编程关注的数据的变化和流向，免除了一部分的状态，而是直接将变化传到显示的控件上，<a href="">实例</a>在这里。</li>
<li>提供统一的消息传递机制：这也是由RAC所带来的，RAC对iOS编程中大部分的实物进行了抽象，提供了统一的接口，所以可以将iOS上KVO、通知(NSNotification)、委托(delegate)、Target-Action、块(Block)等消息传递方式统一，<a href="">实例</a>在这里。</li>
</ul>
<p>MVVM存在的问题主要有：</p>
<ul>
<li>学习曲线比较陡，通常需要引入第三方库(ReactiveCocoa/RxSwift)：使用MVVM通常需要引入第三方库，而且需要转换成响应式编程的思维方式，这是需要花费相当的学习适应时间的。</li>
<li>创建更多的类：基本上每个Controller类会对应有一个ViewModel类</li>
<li>性能上有一定影响，调用栈变深：RAC的实现底层依赖于KVO，带来的问题是性能的损耗，比如光是subscribNext就慢了1个数量级，目前的回调堆栈也比较深，最简单的[signal subscribeNext^(id x){}]就会有近40次的调用。</li>
</ul>
<p>MVVM好处不少，缺点也一堆。那到底要不要用MVVM呢？我觉得，在项目还不算臃肿的时候，可以简单的对现有的MVC进行解耦优化，比如将网络层(Service层)、持久层(Storage层)等部分抽象出来即可。另一方面，MVVM对MVC也是兼容的，可以考虑在项目中的某个模块试水MVVM，觉得好再逐步替换其他模块；而且很重要的一点是，响应式编程这样一种范式相当的锻炼我们的编程思维，让我们可以站在数据的变化和流向的角度去思考我们的整一个项目，掌握这种思维方式也可以反哺到我们项目中别的地方。</p>
<p>架构没有绝对的优劣，适合自己的架构就是最好的架构，那就让我们理性分析，拥抱变化。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/20/iOS性能优化探讨/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="ruanpapa & 又吉君">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="ruanpapa和又吉君写字的地方">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="ruanpapa和又吉君写字的地方" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/20/iOS性能优化探讨/" itemprop="url">
                  iOS性能优化探讨
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-20T11:11:06+08:00">
                2017-09-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ruanpapa-技术贴/" itemprop="url" rel="index">
                    <span itemprop="name">ruanpapa--技术贴</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/09/20/iOS性能优化探讨/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/09/20/iOS性能优化探讨/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/09/20/iOS性能优化探讨/" class="leancloud_visitors" data-flag-title="iOS性能优化探讨">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>最近在公司内部做了一个分享会，探讨了iOS性能优化的话题，现在将重点的内容整理好发出来，各位大牛斧正。</em></p>
<p>本文将从原理出发，解释卡顿发生的原理，然后会讲解项目中行之有效的几个优化点，最后会展望一下接下来将要尝试的方向。下面进入正题。</p>
<h3 id="屏幕显示的原理"><a href="#屏幕显示的原理" class="headerlink" title="屏幕显示的原理"></a>屏幕显示的原理</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p><img src="http://upload-images.jianshu.io/upload_images/698554-f81809fe17a003e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕显示"></p>
<p>我们知道，远古时代的CRT显示器的显示原理是用电子枪扫描荧光屏来发光。如上图所示，电子枪按照从左到右，从上到下的顺序扫描。当电子枪换到新的一行准备进行扫描时，也就是上图A4、B4、C4、D4的位置，显示器会发出一个水平同步信号；而当一帧画面绘制完成后，电子枪回复到原位准备画下一帧前，也就是上图D4的位置，显示器会发出一个垂直同步信号。垂直同步信号的作用一方面是通知显示器回到A1位置，另外一方面，也通知显卡，准备输出下一帧画面。现在已经是液晶显示器的时代了，不再使用电子枪扫描了，但是原理还是类似的，水平同步信号和垂直同步信号还是一样被使用的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/698554-10c8e7e137166beb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="计算机工作原理"></p>
<p>计算机系统的工作原理如上图所示：首先是CPU的工作，包括创建视图分配内存、计算布局、图片解码以及文本绘制等；接下来轮到GPU工作了，GPU负责视图变换、合成和渲染等；GPU渲染完提交到帧缓冲区中，等收到垂直同步信号后将帧缓冲区的内容显示到屏幕上。</p>
<h4 id="屏幕撕裂-Screen-tearing"><a href="#屏幕撕裂-Screen-tearing" class="headerlink" title="屏幕撕裂(Screen tearing)"></a>屏幕撕裂(Screen tearing)</h4><p>上述的简单的屏幕显示原理其实会产生这样一个问题：假设我们的显卡速度很快，每秒生产的帧数肯定要超过显示器刷新率。那么在实际数据处理过程中，缓冲区的数据，在被输出之前，就被显卡不断的刷新重写。但是缓冲区并不是“先清空再写入数据”，这太没有效率，而是采用“新数据覆盖老数据”的方式。</p>
<p>假设这样一种情况，缓冲区已经有一副完整的帧画面（A帧），然后显卡生成了下一帧画面（B帧），新一帧的数据开始写入缓冲区，写到一半的时候，垂直同步信号来了，于是缓冲区的数据被输出到显示器。但问题是，这时缓冲区的数据，是由一半A帧和一半B帧数据合成的。因此最终显示器上显示出来的画面就不是一副完整的画面，这就是“画面撕裂”现象出现的原因，如下图。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/698554-66bc0d60d4a305c8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕撕裂"></p>
<p>那怎样才能解决画面撕裂的问题呢？简单来说只要让帧缓冲区里的数据始终保持一副完整的画面就可以了。从技术角度出发，其实就是利用刚刚提到的垂直同步信号。</p>
<p>具体说起来就是，当显卡生成了一副完整画面并写入了帧缓冲区之后，暂停！然后开始等待垂直同步信号，当得到垂直同步信号后，再继续渲染下一帧写入缓冲区。这样就可以保证在缓冲区的数据始终是一副完整的画面，不会出现前后帧混合的问题。</p>
<h4 id="卡顿产生原因"><a href="#卡顿产生原因" class="headerlink" title="卡顿产生原因"></a>卡顿产生原因</h4><p>但是呢，垂直同步机制带来了一个新的问题 —— 掉帧。所谓的掉帧，跟垂直同步有一定关系，因为垂直同步机制决定了如果在一个时钟周期内CPU或者GPU没有完成各自的任务的话，就会将帧缓冲区里的内容直接丢弃！掉帧并不能完全怪罪于垂直同步机制，更重要的原因是我们作为开发者没有进行足够的优化，将过重的任务派发到了CPU或者GPU上，下图(from：<a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="external">iOS 保持界面流畅的技巧</a>)是掉帧的图示，表明CPU或者GPU任意一个没能在时钟周期内完成自己的任务的话都会导致卡顿掉帧。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/698554-75e20f80bb5101f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="卡顿"></p>
<h3 id="行之有效的优化点"><a href="#行之有效的优化点" class="headerlink" title="行之有效的优化点"></a>行之有效的优化点</h3><ol>
<li><h4 id="提前布局"><a href="#提前布局" class="headerlink" title="提前布局"></a>提前布局</h4><p>提前布局可以说是最重要的优化点了。其实在从服务端拿到 JSON 数据的时候，关于视图的布局就已经确定了，包括每个控件的frame、cell的高度以及文本排版结果等等，在这个时候完全可以在后台线程计算并封装为对应的布局对象XXXTableViewCellLayout，每个cellLayout的内存占用并不是很多，所以直接全部缓存到内存中。当列表滚动到某个cell的时候，直接拿到对应的cellLayout配置这个cell的对应属性即可。当然，该有的计算是免不了的，只是提前算好并缓存，免去了在滚动的时候计算和重复的计算。通过这一个优化，将本来的fps50的列表优化到了55、56左右，可以说从肉眼上已经看不出有卡顿掉帧了。</p>
<p>​</p>
<p><img src="http://upload-images.jianshu.io/upload_images/698554-6b21937ce6754567.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cellLayout示例图"></p>
<p>上图是项目中某个cellLayout的部分代码，可以看到里面存的就是所有控件的frame和文本的排版结果而已，里面没有任何的黑科技，只是将本来在滚动中才做的事情提前了而已。</p>
<p>​</p>
</li>
<li><h4 id="按页加载缓存"><a href="#按页加载缓存" class="headerlink" title="按页加载缓存"></a>按页加载缓存</h4><ul>
<li><p>现状分析：90%的APP有tableview，90%的tableview里有上拉刷新和下拉加载。以我司的项目<strong>ZAKER</strong>中的热点新闻界面为例，简单流程大概是这样的：①应用启动的时候会将磁盘中所有的新闻一次性读取出来显示到屏幕上； ②在每次下拉刷新和上拉加载的时候会将内存中所有新闻缓存到磁盘中，也即全量读写。这意味着大部分的新闻数据会反复写入到磁盘中，这样的写入是冗余的，因为前面的这些新闻数据并没有发生改变。</p>
<p>​</p>
</li>
<li><p>改进方案：所以优化的方法就是将这些列表数组进行分割，分割成一页一页，每次写入的数据量很小，而且避免了冗余写入的问题。现在的流程变为：①启动时只读取第一批新闻显示在屏幕中；②下拉刷新和上拉加载的时候只把当前服务器返回的一批新闻写入缓存中；③在上拉加载的时候会先查看磁盘中是否有未读的缓存，若有则读取缓存，否则才从服务器下载一批新的文章。</p>
<p>​</p>
</li>
<li><p>直观图示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/698554-ba7a27262a9e0931.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="按页缓存"></p>
<p>可以看到，优化之前整个新闻列表以及其他配置都在一个文件里，刷新10几次之后文件大小达到2MB，并且随着不断刷新而越来越大；优化之后，其他的配置还是在刚刚的文件中，但是不断增长的新闻数组被分割成一页一页的文件，每一页里面有10多条的新闻数据，同时有一个configure文件保存这些页的信息以及页的顺序。根据测试人员的反馈，进行按页加载缓存优化能减少5%~8%的CPU占用，使用的内存也有一定的下降。还是有很明显的优化效果的。</p>
<p>​</p>
</li>
</ul>
</li>
<li><h4 id="后台线程处理图片"><a href="#后台线程处理图片" class="headerlink" title="后台线程处理图片"></a>后台线程处理图片</h4><p>圆形头像、图片裁圆角等处理可以说是非常常见的需求了，包括从iOS11的系统各处都能看到，整体的页面控件都变得更加圆润了。但是，对图片处理必然是消耗资源的，实现过图片圆角效果的应该都知道，最简单的就是 layer.cornerRadius+layer.masksToBounds 的方式，但是这种做法在tableview中往往会是滚动变得卡顿，因为这种实现方式会触发离屏渲染，屏幕外缓冲区跟当前屏幕缓冲区上下文切换是很耗性能的，所以离屏渲染往往会造成卡顿(参考：<a href="http://www.jianshu.com/p/6d24a4c29e18" target="_blank" rel="external">iOS 离屏渲染的研究</a>)。</p>
<p>那要怎么处理图片呢？可以使用Core Graphics，CoreGraphic通常是线程安全的，所以可以进行异步绘制，显示的时候再放回主线程。我们在项目中实现了一个后台处理图片的框架，核心代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NSBlockOperation *transformOperation = [[NSBlockOperation alloc] init];</div><div class="line">    [transformOperation addExecutionBlock:^&#123;        </div><div class="line">        // 此处处理图片</div><div class="line">      	...</div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">          	    // 主线程设置图片</div><div class="line">                [self setImage:transformedImage forState:UIControlStateNormal];</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<p>​</p>
<p>​</p>
</li>
<li><h4 id="更加高效的控件"><a href="#更加高效的控件" class="headerlink" title="更加高效的控件"></a>更加高效的控件</h4><p>还可以直接从开源库中选用更加高效的控件替换项目中性能没那么好的控件。项目中将之前的TTTAttributedLabel、M80AttributedLabel全部替换为YYLabel，开启YYLabel的displaysAsynchronously、ignoreCommonProperties属性可以异步绘制文本以及忽略不需要的属性。更加追求性能的话，可以结合第1点的提前布局机制，在提前布局的阶段生成好YYLabel渲染时用到的textLayout，显示的时候直接赋值textLayout就可以了。</p>
<p>​</p>
</li>
<li><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>还有一些比较微小的优化，对性能可以说没有多大的影响，但是可以在开发阶段稍加留意，养成良好的习惯。</p>
<ul>
<li>尽量减少视图层级，合并多余的视图。同样以 <strong>ZAKER</strong> 为例，用户显示时的蓝V标签、达人标签以及楼主图片等几个视图，之前是用不同的view来展示的，优化过程将这几个view合并为一个view，一个view管理这些相似的事物，也可以减少某些相同逻辑的代码。</li>
<li>减少频繁的addSubview、removeSubview，remove之后视图的实例对象会被释放，再add的时候会再次调用初始化函数。可以用hidden属性隐藏不显示的视图。</li>
</ul>
</li>
</ol>
<h3 id="接下来的方向"><a href="#接下来的方向" class="headerlink" title="接下来的方向"></a>接下来的方向</h3><ol>
<li><h4 id="异步绘制"><a href="#异步绘制" class="headerlink" title="异步绘制"></a>异步绘制</h4><p>从开始接触我们就一直在被告知，UIKit的东西是绝对不能在后台线程调用的，一定得在主线程调用，所以主线程也被叫做UI线程。在后台线程调用UIKit的东西有一定几率导致崩溃，或者出现视图不显示、显示错乱等等问题。但是呢，根据刚刚所说的，Core Graphics的那一套东西是线程安全的，所以可以通过Core Graphics在后台将视图渲染到一张图片上，显示的时候在主线程将这张图片设置到相应位置上。Facebook著名的AsyncDisplayKit的核心实现应该也是基于这个原理，接下来的优化可以尝试这个方案。</p>
<p>​</p>
</li>
<li><h4 id="Metal"><a href="#Metal" class="headerlink" title="Metal"></a>Metal</h4><p>根据Apple官方说法，Metal框架被设计用来实现两个目标: 3D 图形渲染和并行计算。这两者有很多共同点。它们都在数量庞大的数据上并行运行特殊的代码，并可以在GPU上执行。目前正在研究学习阶段，看项目中是否能利用Metal进行一定的优化。</p>
<p>​</p>
</li>
<li><h4 id="APM"><a href="#APM" class="headerlink" title="APM??"></a>APM??</h4><p>Application Performance Management(APM)：应用程序性能管理， 通过对应用的可靠性、稳定性等方面的监控，进而达到可以快速修复问题、提高用户体验的目的。目前比较有代表性的 APM 产品有：听云、阿里百川、腾讯bugly等，现在也在考虑自己研发一套APM系统，先从比较简单的指标入手，先对卡顿和崩溃这两个指标着手，做的顺利的话再逐步扩展别的指标的检测管理。</p>
</li>
</ol>
<p>以上。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="ruanpapa & 又吉君" />
          <p class="site-author-name" itemprop="name">ruanpapa & 又吉君</p>
          <p class="site-description motion-element" itemprop="description">ruanpapa和又吉君写字的地方</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/VernonVan" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ruanpapa & 又吉君</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"vernonvan"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  












  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("fRSRDUvIyCVcsgLOHArGl58q-gzGzoHsz", "0mGpmjuTsGuu9JEKGaU6YX9j");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  


</body>
</html>
