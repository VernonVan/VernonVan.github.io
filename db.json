{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/uploads/avatar.jpg","path":"uploads/avatar.jpg","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1484627277000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1484627277000},{"_id":"themes/next/.gitignore","hash":"5f09fca02e030b7676c1d312cd88ce8fbccf381c","modified":1484627277000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1484627277000},{"_id":"themes/next/.javascript_ignore","hash":"f9ea3c5395f8feb225a24e2c32baa79afda30c16","modified":1484627277000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1484627277000},{"_id":"themes/next/README.en.md","hash":"3b0c7998cf17f9cf9e1a5bfcd65679a43a00c817","modified":1484627277000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1484627277000},{"_id":"themes/next/_config.yml","hash":"b7011ba22068abacaafc46d01760d543583679ca","modified":1491012876000},{"_id":"themes/next/bower.json","hash":"5abc236d9cc2512f5457ed57c1fba76669eb7399","modified":1484627277000},{"_id":"themes/next/gulpfile.coffee","hash":"61ef0606a8134894d7ac796bc8d0fa4ba6a94483","modified":1484627277000},{"_id":"themes/next/package.json","hash":"877cb98025e59015532c4c9a04a33e2af4ad56f9","modified":1484627277000},{"_id":"source/categories/index.md","hash":"88a08137c471c454d17be60256a2327c3783f555","modified":1490758147000},{"_id":"source/_drafts/PPRoundedAvatar-高性能的异步裁剪圆角头像.md","hash":"ba014c4e9759c9acfcff3adbb968e225e9a902dd","modified":1490757009000},{"_id":"source/_drafts/iOS开发相关命令整理.md","hash":"1544479b6aaafe23c675437dd87204a919742ec2","modified":1521021445000},{"_id":"source/_posts/Clang之旅-使用Xcode开发Clang插件.md","hash":"ff8f4dd1e48be60bc925826db3a2dc573871ec7f","modified":1524021768022},{"_id":"source/_posts/Clang之旅-实现一个自定义检查规范的Clang插件.md","hash":"f12cb78edff37c6d8027bca7457eb342d09d0820","modified":1524021801021},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1516544240019},{"_id":"source/_posts/Clang之旅-添加自定义的attribute.md","hash":"d81c2840c36881da96cce297ee69a374167e5d04","modified":1524021784372},{"_id":"source/_posts/2017年终总结.md","hash":"a4453a0473af4f272790b4753eaa1db9c15eb25f","modified":1515548445000},{"_id":"source/_posts/Swift的lazy关键字–延迟加载.md","hash":"637457675f2a19fb79d7c0d4fea5636ac97cb20c","modified":1490852530000},{"_id":"source/_posts/PPRoundedAvatar-高性能的异步裁剪圆角头像控件.md","hash":"10a7cef1c96a57547e56e9401f084508499fbf31","modified":1491391291000},{"_id":"source/_posts/iOS性能优化探讨.md","hash":"09ae0206ab9529e955d66f4d206cae1f167e6de9","modified":1507972059000},{"_id":"source/_posts/ruanpapa和又吉君的日常之一.md","hash":"2562acaca0637ebd1c89c1f5ab8dac4624d58039","modified":1491785544000},{"_id":"source/_posts/iOS表情键盘的完整实现.md","hash":"507c902848db0bded9d12285ab456877d65fd868","modified":1517899374000},{"_id":"source/_posts/ruanpapa和又吉君的日常之三.md","hash":"375c1429fab6401941cfa0a061871b30668352db","modified":1491877189000},{"_id":"source/_posts/ruanpapa和又吉君的日常之二.md","hash":"a311c19ed8c61b881475f4abf90f392ec05d2e5b","modified":1491877232000},{"_id":"source/_posts/ruanpapa和又吉君的日常之五.md","hash":"a7fed32875e0751ec420ea8cc456cacd2405af5c","modified":1493182531000},{"_id":"source/_posts/ruanpapa和又吉君的日常之六.md","hash":"811f5f34a1f89175151f76d2c7990e60c172291d","modified":1495714686000},{"_id":"source/_posts/ruanpapa和又吉君的日常之零.md","hash":"e65558f9ce0fcab3ba392d31a1b29bd2990cb2e6","modified":1491876030000},{"_id":"source/_posts/ruanpapa和又吉君的日常之四.md","hash":"6fefb0b63cbabac7553abe4ddfd9179be19de644","modified":1493179202000},{"_id":"source/_posts/《指数基金投资指南》读后感.md","hash":"09e83a7ef348d51feb5cabc77e62b78d622a17db","modified":1520059596695},{"_id":"source/_posts/短暂而快乐-苏州行.md","hash":"4f7f6a585ec523c1b967c81b1745c9ba217da34e","modified":1494812223000},{"_id":"source/_posts/响应式编程与MVVM架构--理论篇.md","hash":"a3e8a5b2455d392b30ff596418faa4d207cec86d","modified":1508206707000},{"_id":"source/_posts/格式化Import.md","hash":"78b3ab6eb9675a0ba8495841a4def79cecacbe2e","modified":1517899363000},{"_id":"source/_posts/翻译关于Swift的编译时间优化.md","hash":"f5bd0eeef5b2d82ad936c84c580bdc876c3f7283","modified":1508833842000},{"_id":"source/tags/index.md","hash":"6a4041442b6e1a488885184c8a21e0abfec43e78","modified":1490853738000},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1484627277000},{"_id":"source/_posts/翻译用LLDB调试Swift代码.md","hash":"9f6cbc60791a037350897e63c7993a74b90bf216","modified":1517901218000},{"_id":"source/_posts/翻译杂志应用.md","hash":"f896a686a23bda824bf52b62e279c86d0a1c21c9","modified":1508833297000},{"_id":"themes/next/.git/config","hash":"bf7d1df65cf34d0f25a7184a58c37a09f72e4be7","modified":1484627277000},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1484624149000},{"_id":"themes/next/.git/packed-refs","hash":"12ca02d8374d9a441a6c8a6c9ed061432cb0a8c9","modified":1484627277000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1484627277000},{"_id":"themes/next/.git/index","hash":"c43ad51f56cb241d76f099579da8932e8216bd06","modified":1521562523043},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1484627277000},{"_id":"themes/next/languages/default.yml","hash":"767470a80dc257e23e14c3a78e8c52a46c9d6209","modified":1484627277000},{"_id":"themes/next/languages/de.yml","hash":"1fdea1f84b7f691f5b4dd4d2b43eeb27b10fa0c8","modified":1484627277000},{"_id":"themes/next/languages/en.yml","hash":"40057d6608e825d06e0864bac4dcd27ed88ada87","modified":1484627277000},{"_id":"themes/next/languages/fr-FR.yml","hash":"9fca01ef917d33ae2ae6bc04561ec6799dff5351","modified":1484627277000},{"_id":"themes/next/languages/ja.yml","hash":"49f12149edcc1892b26a6207328cda64da20116d","modified":1484627277000},{"_id":"themes/next/languages/pt-BR.yml","hash":"7742ba4c0d682cbe1d38305332ebc928abd754b5","modified":1484627277000},{"_id":"themes/next/languages/ko.yml","hash":"b6bc5d6b0c000deb44099b42d3aebb8c49dbfca9","modified":1484627277000},{"_id":"themes/next/languages/id.yml","hash":"34396bef27c4ab9e9a3c5d3e3aa94b0e3b3a7b0d","modified":1484627277000},{"_id":"themes/next/languages/pt.yml","hash":"6b660b117314cad93f08757601df3adb04c68beb","modified":1484627277000},{"_id":"themes/next/languages/zh-hk.yml","hash":"34c84c6d04447a25bd5eac576922a13947c000e2","modified":1484627277000},{"_id":"themes/next/languages/ru.yml","hash":"257d11e626cbe4b9b78785a764190b9278f95c28","modified":1484627277000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"f6c9fafa0f5f0050cd07ca2cf5e38fbae3e28145","modified":1484627277000},{"_id":"themes/next/languages/zh-tw.yml","hash":"c97a5c41149de9b17f33439b0ecf0eff6fdae50e","modified":1484627277000},{"_id":"themes/next/layout/_layout.swig","hash":"2fa3c74066843a859fac77803324a1de51044da9","modified":1484627277000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1484627277000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1484627277000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1484627277000},{"_id":"themes/next/layout/page.swig","hash":"3727fab9dadb967e9c2204edca787dc72264674a","modified":1484627277000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1484627277000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1484627277000},{"_id":"themes/next/layout/schedule.swig","hash":"1f1cdc268f4ef773fd3ae693bbdf7d0b2f45c3a3","modified":1484627277000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1484627277000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1484627277000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1484627277000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1484627277000},{"_id":"source/uploads/avatar.jpg","hash":"8fc76c75f02f3fa85500ae17044f8425d38ea8f2","modified":1490854048000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1484627277000},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1484624149000},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1484624149000},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1484624149000},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1484624149000},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1484624149000},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1484624149000},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1484624149000},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1484624149000},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1484624149000},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1484624149000},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1484624149000},{"_id":"themes/next/.git/logs/HEAD","hash":"2e72f33077081d2e8672ee3096220379300f8a0b","modified":1484627277000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1484627277000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1484627277000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"5864f5567ba5efeabcf6ea355013c0b603ee07f2","modified":1484627277000},{"_id":"themes/next/layout/_macro/post.swig","hash":"e6016def9b512188f4c2725399c9adc7bc41cdae","modified":1484627277000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"43d8830bb19da4fc7a5773866be19fa066b62645","modified":1484627277000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1484627277000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"78ccfc1dc915247c1fec3c86d742e0f4c2f6d99c","modified":1484627277000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1484627277000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1484627277000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1484627277000},{"_id":"themes/next/layout/_partials/header.swig","hash":"adab5c3f7b173f1b45454787f39dde07aea03483","modified":1484627277000},{"_id":"themes/next/layout/_partials/head.swig","hash":"ca56f92e2fa82b03853869f5073ee1a5626a4796","modified":1484627277000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"39d613e5a9f8389d4ea52d6082502af8e833b9f2","modified":1484627277000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1484627277000},{"_id":"themes/next/layout/_partials/search.swig","hash":"1431719d1dbba3f5ee385eebc46376d1a960b2d5","modified":1484627277000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1484627277000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1484627277000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1484627277000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"4512867d80d9eddfc3a0f5fea3c456f33aa9d522","modified":1484627277000},{"_id":"themes/next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1484627277000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1484627277000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1484627277000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1484627277000},{"_id":"themes/next/scripts/tags/note.js","hash":"6752925eedbdb939d8ec4d11bdfb75199f18dd70","modified":1484627277000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1484627277000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1484627277000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1484627277000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1484627277000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1484627277000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1484627277000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1484627277000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1484627277000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1484627277000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1484627277000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1484627277000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1484627277000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1484627277000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1484627277000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1484627277000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1484627277000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1484627277000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1484627277000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1484627277000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1484627277000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1484627277000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1484627277000},{"_id":"themes/next/source/images/avatar.jpg","hash":"8fc76c75f02f3fa85500ae17044f8425d38ea8f2","modified":1490854048000},{"_id":"themes/next/.git/refs/heads/master","hash":"2311b7302155cc3ec46e40ad16dc5c94e36328b4","modified":1484627277000},{"_id":"themes/next/layout/_components/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1484627277000},{"_id":"themes/next/layout/_components/algolia-search/dom.swig","hash":"636f1181dd5887a70b4a08ca8f655d4e46635792","modified":1484627277000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1484627277000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1484627277000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1484627277000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1484627277000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1484627277000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1484627277000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1484627277000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1484627277000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1484627277000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1484627277000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"394d9fff7951287cc90f52acc2d4cbfd1bae079d","modified":1484627277000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1484627277000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"4abc01bc870e1d7a783cdbd26166edc782a6a4f4","modified":1484627277000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1484627277000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1484627277000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"b460e27db3dcd4ab40b17d8926a5c4e624f293a9","modified":1484627277000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1484627277000},{"_id":"themes/next/layout/_scripts/third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1484627277000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1484627277000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1484627277000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1484627277000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1484627277000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c459aa6d607d8bcb747544e74f6ad0b8374aa3b1","modified":1484627277000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"fc185c6cec79593775d1c2440dbe2a71cfbe2e99","modified":1484627277000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"96b29f69b8b916b22f62c9959a117b5a968200a5","modified":1484627277000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1484627277000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1484627277000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1484627277000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1484627277000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1484627277000},{"_id":"themes/next/source/js/src/utils.js","hash":"384e17ff857f073060f5bf8c6e4f4b7353236331","modified":1484627277000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1484627277000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1484627277000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1484627277000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1484627277000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1484627277000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1484627277000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1484627277000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1484627277000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1484627277000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"c1072942459fa0880e8a33a1bd929176b62b4171","modified":1484627277000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1484627277000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1484627277000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1484627277000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1484627277000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1484627277000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1484627277000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1484627277000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1484627277000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1484627277000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1484627277000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1484627277000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1484627277000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1484627277000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1484627277000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1484627277000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1484627277000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1484627277000},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"2e72f33077081d2e8672ee3096220379300f8a0b","modified":1484627277000},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1484627277000},{"_id":"themes/next/layout/_scripts/third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1484627277000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1484627277000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1484627277000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1484627277000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1484627277000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"fb1d04ede838b52ca7541973f86c3810f1ad396e","modified":1484627277000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1484627277000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1484627277000},{"_id":"themes/next/layout/_scripts/third-party/comments/gentie.swig","hash":"03592d1d731592103a41ebb87437fe4b0a4c78ca","modified":1484627277000},{"_id":"themes/next/layout/_scripts/third-party/comments/youyan.swig","hash":"ea8078fa9e10be2bb042749d8b6a97adc38f914c","modified":1484627277000},{"_id":"themes/next/layout/_scripts/third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1484627277000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1484627277000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1484627277000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1484627277000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1484627277000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1484627277000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1484627277000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1484627277000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1484627277000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1484627277000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1484627277000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1484627277000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1484627277000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1484627277000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1484627277000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1484627277000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1484627277000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1484627277000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1484627277000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1484627277000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"ff9f163bb05c0709577040a875924d36c9ab99d6","modified":1484627277000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"dcf9fe43b2ef78b923118ba39efedb38760e76b1","modified":1484627277000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"1408209dfb9a22a0982a30bdbd14842c2b53f264","modified":1484627277000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1484627277000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9b63bd8effc7cf4b96acdea4d73add7df934a222","modified":1484627277000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1484627277000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"9ccee9189c910b8a264802d7b2ec305d12dedcd0","modified":1484627277000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1484627277000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1484627277000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1484627277000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1484627277000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1484627277000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1484627277000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1484627277000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1484627277000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1484627277000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1484627277000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1484627277000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1484627277000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1484627277000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1484627277000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1484627277000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1484627277000},{"_id":"themes/next/.git/objects/pack/pack-00f07f1de24eae5e11a6eafe2ba682e19a17d816.idx","hash":"9d5dbc105ad16f3b5a38b696e32be0282b529cf3","modified":1484627276000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1484627277000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1484627277000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1484627277000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1484627277000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1484627277000},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"2e72f33077081d2e8672ee3096220379300f8a0b","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4b7f81e1006e7acee3d1c840ccba155239f830cc","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"fdfadbb4483043c7e0afd541ee9712389e633517","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"7f1aab694caf603809e33cff82beea84cd0128fd","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"c6dab7661a6b8c678b21b7eb273cef7100f970f6","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"bfd806d0a9f21446a22df82ac02e37d0075cc3b5","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"eba491ae624b4c843c8be4c94a044085dad4ba0f","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/third-party/gentie.styl","hash":"586a3ec0f1015e7207cd6a2474362e068c341744","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"637c6b32c58ecf40041be6e911471cd82671919b","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"42348219db93a85d2ee23cb06cebd4d8ab121726","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"3eb73cee103b810fa56901577ecb9c9bb1793cff","modified":1484627277000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"74d0ba86f698165d13402670382a822c8736a556","modified":1484627277000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1484627277000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1484627277000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1484627277000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1484627277000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1484627277000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1484627277000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1484627277000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1484627277000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1484627277000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1484627277000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1484627277000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1484627277000},{"_id":"themes/next/.git/objects/pack/pack-00f07f1de24eae5e11a6eafe2ba682e19a17d816.pack","hash":"40c8757daa949da2de470b088593680ae25c22d1","modified":1484627276000},{"_id":"public/categories/index.html","hash":"a580a69b01840192eb2bae49e3334fa47519e729","modified":1524021829997},{"_id":"public/tags/index.html","hash":"3337cc4cff7923f1e165e30653cf1d1eaf20d1fa","modified":1524021829997},{"_id":"public/archives/page/3/index.html","hash":"5d098b234e8206433095b6d77bd4355e2af43491","modified":1524021829998},{"_id":"public/archives/2016/index.html","hash":"1e2dec91d13b03770162785be8a7049a91e6a738","modified":1524021829998},{"_id":"public/archives/2016/12/index.html","hash":"5e6ea9c76ed01c8298ba5594f9f1f19d4f21707e","modified":1524021829998},{"_id":"public/archives/2017/03/index.html","hash":"4f94991c848ecbda26cc2f480c7fef374a45f17a","modified":1524021829998},{"_id":"public/archives/2017/05/index.html","hash":"5b6274e8edb17d65501abea9f30401151f34fd80","modified":1524021829998},{"_id":"public/archives/2017/07/index.html","hash":"51de3638cd4bdc9d21bf56d0270be8f270fc94a0","modified":1524021829998},{"_id":"public/archives/2017/09/index.html","hash":"f0461c33df77320047a0c75e7467c0bcf4a1c4c7","modified":1524021829998},{"_id":"public/archives/2017/10/index.html","hash":"092baa8bdcd362569227d816c641621165b7e8d9","modified":1524021829998},{"_id":"public/archives/2017/12/index.html","hash":"e7c185aed88ca0dead6b5b177b2a81ddda685592","modified":1524021829998},{"_id":"public/archives/2018/01/index.html","hash":"51c5fc5ca8998168ff22b9c3a998034e14944cc4","modified":1524021829998},{"_id":"public/archives/2018/02/index.html","hash":"007b1f341570a73937291901beb2656482bbc296","modified":1524021829998},{"_id":"public/archives/2018/03/index.html","hash":"08502e2110a00fd577f1b13f2325a303ba064c5e","modified":1524021829998},{"_id":"public/categories/ruanpapa-技术贴/page/2/index.html","hash":"5c4cc92ea35fa75fe9a1c3f6858e7bf95358181a","modified":1524021829998},{"_id":"public/categories/投资理财/index.html","hash":"b325adc6b156f8a1b424da77171729407fdc3c0c","modified":1524021829998},{"_id":"public/tags/iOS/page/2/index.html","hash":"e6ebcb7da96e4e8a3225ddba9186b6200c7b46c5","modified":1524021829998},{"_id":"public/tags/clang-llvm/index.html","hash":"2a8478d4f178be6d8fa960891369f7ebdef7fe1f","modified":1524021829998},{"_id":"public/tags/Objective-C/index.html","hash":"a8240c5a3896143b0977f81643f66288e453e78d","modified":1524021829999},{"_id":"public/tags/Swift/index.html","hash":"aeb93a3ed66a805705ef7f8e8165ca2e3668e960","modified":1524021829999},{"_id":"public/tags/性能优化/index.html","hash":"51312d37f8448603eb6f23dea91c4ba8d1dd01ff","modified":1524021829999},{"_id":"public/tags/投资理财/index.html","hash":"e6d2e3046e67b3b9bee885c1c110bb849bfcba2d","modified":1524021829999},{"_id":"public/tags/基金定投/index.html","hash":"4cd46aa4981c82ef1ececbdacbf9ef536d1499f2","modified":1524021829999},{"_id":"public/tags/读后感/index.html","hash":"b49cbcc68f48e1970fdd6a8184b201343edc803f","modified":1524021829999},{"_id":"public/tags/Xcode/index.html","hash":"9af2af360d4e87c3b4e5a45b10cb04e484b1c471","modified":1524021829999},{"_id":"public/tags/架构/index.html","hash":"6a13341f08a30411340332f3bf7bf1975ffcf84a","modified":1524021829999},{"_id":"public/tags/翻译/index.html","hash":"7aa974a5b26ec90da8f8608767dc89bb4bd2e9bd","modified":1524021829999},{"_id":"public/2018/03/22/Clang之旅-添加自定义的attribute/index.html","hash":"ce4cf144932aa59ac46fef3580463b735c495cef","modified":1524021829999},{"_id":"public/2018/03/16/Clang之旅-使用Xcode开发Clang插件/index.html","hash":"1ef4427fe3f6a292c8465a08d12200d1d1ec0c5c","modified":1524021829999},{"_id":"public/2018/03/02/《指数基金投资指南》读后感/index.html","hash":"9f3e995dbf7390e4a40f6e400605da14efa9bb6f","modified":1524021829999},{"_id":"public/2018/02/06/翻译用LLDB调试Swift代码/index.html","hash":"873fd5e81a57a767d139c78e88bece783f272f7b","modified":1524021829999},{"_id":"public/2018/02/01/格式化Import/index.html","hash":"d5a61eb78a1ece38d6b64b4e945d411413175b9c","modified":1524021829999},{"_id":"public/2018/01/19/iOS表情键盘的完整实现/index.html","hash":"f869b9a12040d4eb8f606fcc88e0ffd748275ab6","modified":1524021830000},{"_id":"public/2017/12/30/2017年终总结/index.html","hash":"43305a9fb58d5eee389916775e4987ce963f0f94","modified":1524021830000},{"_id":"public/2017/10/22/翻译关于Swift的编译时间优化/index.html","hash":"5c95530da7a68c6542cc9ee8f87bf2b41942902d","modified":1524021830000},{"_id":"public/2017/10/12/响应式编程与MVVM架构--理论篇/index.html","hash":"2e88f15db444e8bc41820732b40e84a639a6a0cd","modified":1524021830000},{"_id":"public/2017/09/20/iOS性能优化探讨/index.html","hash":"13bbd6a24d5568615b738061d5480b0ec997ed93","modified":1524021830000},{"_id":"public/2017/07/21/翻译杂志应用/index.html","hash":"a77048c565fb0eb371949cc52fd297d1e47d4396","modified":1524021830000},{"_id":"public/2017/05/25/ruanpapa和又吉君的日常之六/index.html","hash":"af53cccec25e782dc9508037ef8fb62bf853fc4f","modified":1524021830000},{"_id":"public/2017/05/15/短暂而快乐-苏州行/index.html","hash":"f51fbc4ff090fd16dbd26021855d75d6163dc490","modified":1524021830000},{"_id":"public/2017/04/26/ruanpapa和又吉君的日常之五/index.html","hash":"6049ad7323e4de1fc314d70ace4e0a0edc6d2525","modified":1524021830000},{"_id":"public/2017/04/18/ruanpapa和又吉君的日常之四/index.html","hash":"2c383ddc2542f4cebc1944c8d3fbfa3268376cb9","modified":1524021830000},{"_id":"public/2017/04/11/ruanpapa和又吉君的日常之三/index.html","hash":"adc57e341e001df35a40ff95781e4ea4f454a3d0","modified":1524021830000},{"_id":"public/2017/04/10/ruanpapa和又吉君的日常之二/index.html","hash":"67a2c6b5076a7e5d6c6d6c25ce8c3cb89b30c944","modified":1524021830000},{"_id":"public/2017/04/01/PPRoundedAvatar-高性能的异步裁剪圆角头像控件/index.html","hash":"ae01b137a8f70d811b463cbf8daa6126893e2a94","modified":1524021830000},{"_id":"public/2017/04/01/ruanpapa和又吉君的日常之一/index.html","hash":"4945c31381325431b19c86671d90f35c5fd3216a","modified":1524021830001},{"_id":"public/2017/03/30/ruanpapa和又吉君的日常之零/index.html","hash":"da35a1bd69a21f0ecbf6b3a33d3bd24c224de1a7","modified":1524021830001},{"_id":"public/2016/12/28/Swift的lazy关键字–延迟加载/index.html","hash":"002cee0037fafc5902278238e862fe102a739483","modified":1524021830001},{"_id":"public/archives/index.html","hash":"6261e949fc56d32534eea2f534190e431089c9af","modified":1524021830001},{"_id":"public/archives/page/2/index.html","hash":"73d4dad76cb3b001b687f5832f256dc2ae7ce0c8","modified":1524021830001},{"_id":"public/archives/2017/index.html","hash":"18472f7053ab92b6cd7791f79204c072334fc66b","modified":1524021830001},{"_id":"public/archives/2017/page/2/index.html","hash":"9e9d0cd5a8357f96a464f59187b2f59951b1a3e4","modified":1524021830001},{"_id":"public/archives/2017/04/index.html","hash":"4d6f9a8c00b16ba6d5247216ac7545c79071e19f","modified":1524021830001},{"_id":"public/archives/2018/index.html","hash":"8f785154910fa1450c8cc9e63bf5987a4ac39963","modified":1524021830001},{"_id":"public/index.html","hash":"32ac3b9d7ae8043de752bb10698c47d2f3b1e8a1","modified":1524021830001},{"_id":"public/page/2/index.html","hash":"059aa44e0e4dc89af2b150a0d9dd210b68af83e4","modified":1524021830001},{"_id":"public/page/3/index.html","hash":"343955042abbffa71329fb8be9a2d39fc4314b86","modified":1524021830001},{"_id":"public/categories/ruanpapa-技术贴/index.html","hash":"dd67978e1ca94bce404a95e5ac1d656a705a46de","modified":1524021830001},{"_id":"public/categories/ruanpapa-又吉君的日常/index.html","hash":"f6166ac5fdbb5b5e9ec799d10de1f2e5ed3a2879","modified":1524021830002},{"_id":"public/tags/iOS/index.html","hash":"3bf8acf0da551b0f901716117ca081bd1fcd6d98","modified":1524021830002},{"_id":"public/archives/2018/04/index.html","hash":"a471d36c6c02fb222715d09c096da767d90284dd","modified":1524021830006},{"_id":"public/2018/04/17/Clang之旅-实现一个自定义检查规范的Clang插件/index.html","hash":"1e4b6a17034c91978e60d1212abaee108a8f564b","modified":1524021830006},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1524021830010},{"_id":"public/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1524021830010},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1524021830010},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1524021830010},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1524021830010},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1524021830010},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1524021830010},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1524021830010},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1524021830010},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1524021830010},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1524021830011},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1524021830011},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1524021830011},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1524021830011},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1524021830011},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1524021830011},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1524021830011},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1524021830011},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1524021830011},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1524021830011},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1524021830011},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1524021830011},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1524021830011},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1524021830011},{"_id":"public/uploads/avatar.jpg","hash":"8fc76c75f02f3fa85500ae17044f8425d38ea8f2","modified":1524021830503},{"_id":"public/images/avatar.jpg","hash":"8fc76c75f02f3fa85500ae17044f8425d38ea8f2","modified":1524021830504},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1524021830509},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1524021830509},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1524021830510},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1524021830510},{"_id":"public/js/src/algolia-search.js","hash":"96b29f69b8b916b22f62c9959a117b5a968200a5","modified":1524021830513},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1524021830513},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1524021830513},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1524021830514},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1524021830514},{"_id":"public/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1524021830514},{"_id":"public/js/src/utils.js","hash":"384e17ff857f073060f5bf8c6e4f4b7353236331","modified":1524021830514},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1524021830514},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1524021830514},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1524021830514},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1524021830514},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1524021830514},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1524021830514},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1524021830514},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1524021830515},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1524021830515},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1524021830515},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1524021830515},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1524021830515},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1524021830515},{"_id":"public/js/src/schemes/pisces.js","hash":"9ccee9189c910b8a264802d7b2ec305d12dedcd0","modified":1524021830515},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1524021830516},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1524021830516},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1524021830516},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1524021830516},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1524021830516},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1524021830516},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1524021830516},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1524021830516},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1524021830516},{"_id":"public/css/main.css","hash":"622e73dc194b916d1b46d7661486c475843ef905","modified":1524021830517},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1524021830517},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1524021830517},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1524021830517},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1524021830517},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1524021830517},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1524021830517},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1524021830517},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1524021830517},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1524021830517},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1524021830518},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1524021830518},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1524021830526}],"Category":[{"name":"ruanpapa--技术贴","_id":"cjg4j8vyb0004vfwx525bpdkn"},{"name":"ruanpapa&又吉君的日常","_id":"cjg4j8vyl000lvfwxzinl6pvs"},{"name":"投资理财","_id":"cjg4j8w2o001vvfwxjuf9vyei"}],"Data":[],"Page":[{"title":"分类","date":"2017-03-29T03:12:30.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2017-03-29 11:12:30\ntype: \"categories\"\ncomments: false\n---\n","updated":"2017-03-29T03:29:07.000Z","path":"categories/index.html","layout":"page","_id":"cjg4j8vy50000vfwxl7n1qfhn","content":"","excerpt":"","more":""},{"title":"所有标签","date":"2017-03-29T03:16:39.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 所有标签\ndate: 2017-03-29 11:16:39\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-03-30T06:02:18.000Z","path":"tags/index.html","layout":"page","_id":"cjg4j8w2l001tvfwxriuei2zq","content":"","excerpt":"","more":""}],"Post":[{"title":"PPRoundedAvatar--高性能的异步裁剪圆角头像","_content":"","source":"_drafts/PPRoundedAvatar-高性能的异步裁剪圆角头像.md","raw":"---\ntitle: PPRoundedAvatar--高性能的异步裁剪圆角头像\ntags:\n---\n","slug":"PPRoundedAvatar-高性能的异步裁剪圆角头像","published":0,"date":"2017-03-29T03:10:09.000Z","updated":"2017-03-29T03:10:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg4j8vy60001vfwxd62gxyp9","content":"","excerpt":"","more":""},{"title":"iOS开发相关命令整理","_content":"\n\n\n1. 查看本机安装的 SDK：\n\n   ```\n   xcodebuild -showsdks\n   ```\n\n![xcodebuild](http://upload-images.jianshu.io/upload_images/698554-8767d163320b30c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n2. 查看 .a 以及 .framework 支持的架构：\n\n   .framework 文件：\n\n   ```\n   lipo -info xxx.framework/xxxxFramework\n   ```\n\n   .a 文件： \n\n   ```\n   lipo -info xxx.a\n   ```\n\n   ![framew架构](https://upload-images.jianshu.io/upload_images/698554-e7004756972e1ccf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n\n3. 暂停正在执行的 make 命令：\n\n   暂停：```Command+Z ```\n\n   继续执行：```fg %1```\n\n","source":"_drafts/iOS开发相关命令整理.md","raw":"---\ntitle: iOS开发相关命令整理\ntags:\n- iOS\n- 命令\ncategories:\n- ruanpapa--技术贴\n---\n\n\n\n1. 查看本机安装的 SDK：\n\n   ```\n   xcodebuild -showsdks\n   ```\n\n![xcodebuild](http://upload-images.jianshu.io/upload_images/698554-8767d163320b30c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n2. 查看 .a 以及 .framework 支持的架构：\n\n   .framework 文件：\n\n   ```\n   lipo -info xxx.framework/xxxxFramework\n   ```\n\n   .a 文件： \n\n   ```\n   lipo -info xxx.a\n   ```\n\n   ![framew架构](https://upload-images.jianshu.io/upload_images/698554-e7004756972e1ccf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n\n3. 暂停正在执行的 make 命令：\n\n   暂停：```Command+Z ```\n\n   继续执行：```fg %1```\n\n","slug":"iOS开发相关命令整理","published":0,"date":"2018-03-08T07:47:03.000Z","updated":"2018-03-14T09:57:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg4j8vy90002vfwx0wp4r48z","content":"<ol>\n<li><p>查看本机安装的 SDK：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xcodebuild -showsdks</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-8767d163320b30c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"xcodebuild\"></p>\n<ol>\n<li><p>查看 .a 以及 .framework 支持的架构：</p>\n<p>.framework 文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">lipo -info xxx.framework/xxxxFramework</div></pre></td></tr></table></figure>\n<p>.a 文件： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">lipo -info xxx.a</div></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/698554-e7004756972e1ccf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"framew架构\"></p>\n</li>\n</ol>\n<ol>\n<li><p>暂停正在执行的 make 命令：</p>\n<p>暂停：<figure class=\"highlight plain\"><figcaption><span>```</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">继续执行：```fg %1</div></pre></td></tr></table></figure></p>\n</li>\n</ol>\n","excerpt":"","more":"<ol>\n<li><p>查看本机安装的 SDK：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xcodebuild -showsdks</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-8767d163320b30c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"xcodebuild\"></p>\n<ol>\n<li><p>查看 .a 以及 .framework 支持的架构：</p>\n<p>.framework 文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">lipo -info xxx.framework/xxxxFramework</div></pre></td></tr></table></figure>\n<p>.a 文件： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">lipo -info xxx.a</div></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/698554-e7004756972e1ccf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"framew架构\"></p>\n</li>\n</ol>\n<ol>\n<li><p>暂停正在执行的 make 命令：</p>\n<p>暂停：<figure class=\"highlight plain\"><figcaption><span>```</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">继续执行：```fg %1</div></pre></td></tr></table></figure></p>\n</li>\n</ol>\n"},{"title":"Clang 之旅--使用 Xcode 开发 Clang 插件","date":"2018-03-16T06:44:05.000Z","_content":"\n\n\nClang 之旅系列文章：\n[Clang 之旅--使用 Xcode 开发 Clang 插件](https://www.jianshu.com/p/e3f46d42643b)\n[Clang 之旅--[翻译]添加自定义的 attribute](https://www.jianshu.com/p/d277c42f4907)\n[Clang 之旅--实现一个自定义检查规范的 Clang 插件](https://www.jianshu.com/p/c27b77f70616)\n\n\n\n### 前言\n\n最近在跟老大的聊天中聊到了一个比较特殊的需求：是否有办法在编译阶段检查某个方法的参数与返回值的类型相同，如果类型不一致的话能抛出编译错误的提示。这似乎已经不是 Objective-C 或者 Swift 的语言语法本身所能解决的了，老大还指点了可以从编译器等底层中进行研究。于是，我踏进了 Clang 和 LLVM 的大门。\n\n我打算将 Clang 的研究心得分为几篇文章来写，这是 Clang 之旅的第一篇，主要讲如何用 Xcode 编译 Clang，以及实现一个简单的 Clang 插件并挂载到 Xcode 中参与编译流程，算是进入 Clang 的门槛。只是，这门槛就狠狠地让我吃了苦头，Google 找到好几篇博客讲怎么编译 Clang 的，但是也有一些年头了，版本比较旧，编译出来的 Clang 不能运行在现在的系统上；还有一些写的比较含糊，漏了某些关键步骤，导致花了好几个小时跟着教程做下来最后还是一堆 error；而且试错的成本还是比较高的，下载的源码有1G多（考虑从 Github 下载的速度🙄，需要挂个代理），完整编译出来有20G左右，我的15款 Macbook Pro 大概需要疯狂编译2个小时…...如果不能接受这些的话，还是别尝试了，很遗憾，你连见到 Clang 真容的机会都没有┑(￣Д ￣)┍\n\n![llvm大小](https://upload-images.jianshu.io/upload_images/698554-49318ad53d98d6ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n### 编译源码\n\n#### 准备工作\n\nClang 需要用 CMake 来编译，CMake 的安装方法可以参考这篇文章：[Mac 安装 CMake & CMake Command Line Tools](https://www.jianshu.com/p/7466c85d5d6b)，建议对 CMake 完全不了解的同学可以先补充一点 CMake 的基本知识，这样能更容易理解接下来要做的事情，CMake 的入门知识可以参考：[CMake 入门实战](http://www.hahack.com/codes/cmake/)\n\n\n\n#### 下载源码\n\n首先创建 LLVM 的源码路径及编译路径：\n\n```\ncd /opt\nsudo mkdir llvm\nsudo chown `whoami` llvm\t// 将 llvm 目录的所有者指定为当前用户\ncd llvm\nexport LLVM_HOME=`pwd`\t\t// 设置当前目录(/opt/llvm)为 LLVM_HOME 目录\n```\n\n接下来从 Github clone 源代码（注意这几条语句中的 release_60，在当前时间2018.3.18时，我试过了 release_33、release_39，编译出来的 Clang 插件在运行的时候都会报 NSUUID 的 Nullability 错误，应该是这些版本不支持 Objective-C 后来加的 Nullability 特性，所以我下载了当前最新的 release_60 分支。一般来说，最新分支是兼容已有特性的，所以优先下载最新分支，分支查看可以参照下图）：\n\n```\ngit clone -b release_60 git@github.com:llvm-mirror/llvm.git llvm\ngit clone -b release_60 git@github.com:llvm-mirror/clang.git llvm/tools/clang\ngit clone -b release_60 git@github.com:llvm-mirror/clang-tools-extra.git llvm/tools/clang/tools/extra\ngit clone -b release_60 git@github.com:llvm-mirror/compiler-rt.git llvm/projects/compiler-rt\n```\n\n![llvm最新分支.png](https://upload-images.jianshu.io/upload_images/698554-5e54bd18bac5a151.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n#### 编译源码\n\n生成 Xcode 工程（也可以直接用命令行编译，不过大家平时可能看习惯了 Xcode 工程，所以用 Xcode 编译比较习惯）\n\n```\nmkdir llvm_build; cd llvm_build\ncmake -G Xcode ../llvm -DCMAKE_BUILD_TYPE:STRING=MinSizeRel\n```\n\n生成的文件如下：\n\n![Xcode工程.png](https://upload-images.jianshu.io/upload_images/698554-975fe9e218257288.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n打开 Xcode 工程，选择自动创建 Schemes：\n\n![自动创建Schemes.png](https://upload-images.jianshu.io/upload_images/698554-dd7980d5fe52b689.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后编译 Clang 和 libClang（可以随时终止编译，再次点击编译会从上次停止的地方继续进行）：\n\n![编译Clang和libClang](https://upload-images.jianshu.io/upload_images/698554-cad3858632e8185b.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这里可能需要1个多小时才能完成编译，如无意外，编译成功！\n\n\n\n### 编写你的第一个插件\n\n这个插件实现的功能就是打印语法树上所有节点的类名以及父类名，创建 Clang 插件的整体步骤如下图：\n\n![创建插件.png](https://upload-images.jianshu.io/upload_images/698554-214742ce207ea7ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n首先修改源代码目录 /opt/llvm/llvm/tools/clang/tools 下的 CMakeLists.txt 文件，添加一个新的编译目标，直接在 CMakeLists.txt 的最后面添加上一行，如下图：\n![添加新的编译目标.png](https://upload-images.jianshu.io/upload_images/698554-db674e4e4ade824d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n然后在 tools 目录下添加 MyPlugin 文件夹，文件夹里面新增两个文件 CMakeLists.txt 和 MyPlugin.cpp，这里先不讲解具体文件中的内容，目的是想让插件跑起来，看到运行效果。\n\n   CMakeLists.txt 文件如下：\n\n   ```cmake\n   add_llvm_loadable_module(MyPlugin \n   MyPlugin.cpp\n   PLUGIN_TOOL clang\n   )\n\n   if(LLVM_ENABLE_PLUGINS AND (WIN32 OR CYGWIN))\n     target_link_libraries(MyPlugin PRIVATE\n       clangAST\n       clangBasic\n       clangFrontend\n       clangLex\n       LLVMSupport\n       )\n   endif()\n   ```\n\n   MyPlugin.cpp 文件如下：\n\n   ```c++\n   #include <iostream>\n   #include \"clang/AST/AST.h\"\n   #include \"clang/AST/ASTConsumer.h\"\n   #include \"clang/AST/RecursiveASTVisitor.h\"\n   #include \"clang/Frontend/CompilerInstance.h\"\n   #include \"clang/Frontend/FrontendPluginRegistry.h\"\n   using namespace clang;\n   using namespace std;\n   using namespace llvm;\n   namespace MyPlugin\n   {\n       class MyASTVisitor: public\n       RecursiveASTVisitor < MyASTVisitor >\n       {\n   private:\n           ASTContext *context;\n   public:\n           void setContext(ASTContext &context)\n           {\n               this->context = &context;\n           }\n\n           bool VisitDecl(Decl *decl)\n           {\n               if (isa < ObjCInterfaceDecl > (decl)) {\n                   ObjCInterfaceDecl *interDecl = (ObjCInterfaceDecl *)decl;\n                   if (interDecl->getSuperClass()) {\n                       string interName = interDecl->getNameAsString();\n                       string superClassName = interDecl->getSuperClass()->getNameAsString();\n\n                       cout << \"-------- ClassName:\" << interName << \" superClassName:\" << superClassName << endl;\n                   }\n               }\n\n               return true;\n           }\n       };\n       \n       class MyASTConsumer: public ASTConsumer\n       {\n   private:\n           MyASTVisitor visitor;\n           void HandleTranslationUnit(ASTContext &context)\n           {\n               visitor.setContext(context);\n               visitor.TraverseDecl(context.getTranslationUnitDecl());\n           }\n       };\n       class MyASTAction: public PluginASTAction\n       {\n   public:\n           unique_ptr < ASTConsumer > CreateASTConsumer(CompilerInstance & Compiler, StringRef InFile) {\n               return unique_ptr < MyASTConsumer > (new MyASTConsumer);\n           }\n           bool ParseArgs(const CompilerInstance &CI, const std::vector < std::string >& args)\n           {\n               return true;\n           }\n       };\n   }\n   static clang::FrontendPluginRegistry::Add\n   < MyPlugin::MyASTAction > X(\"MyPlugin\",\n                               \"MyPlugin desc\");\n   ```\n\n再次在 llvm_build 目录下 CMake 一下\n\n```cmake\ncmake -G Xcode ../llvm -DCMAKE_BUILD_TYPE:STRING=MinSizeRel\n```\n\n然后重新打开 LLVM.xcodeproj 工程，会发现多了一个 MyPlugin 的编译目标，选中进行编译。\n\n![编译myPlugin.png](https://upload-images.jianshu.io/upload_images/698554-a1ec081353964edc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n编译成功之后，就可以得到一个 MyPlugin.dylib 的 Clang 插件了~为了方便，我将 MyPlugin.dylib 放在桌面上：\n\n![MyPlugin插件.png](https://upload-images.jianshu.io/upload_images/698554-3b17229fdf5192e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n### 使用插件\n\n#### 命令行中使用插件\n\n首先用命令行对单文件测试一下刚刚生成的 Clang 插件是否正确，新建一个测试用文件 test.m 放在桌面，test.m 如下：\n\n```objective-c\n#import<UIKit/UIKit.h>\n@interface ViewController : UIViewController\n@end\n@implementation ViewController\n- (instancetype)init\n{\n\tif(self = [super init]){\n\t}\n\treturn self;\n}\n@end\n```\n\n现在我的 test.m 和 MyPlugin.dylib 都在桌面上了（当然也可以放在不同的目录下，只要在待会用到这两个文件的地方指定各自的绝对路径就行，这里是为了方便叙述）\n\n![文件结构](https://upload-images.jianshu.io/upload_images/698554-5bd1c283af274180.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n接着命令行 cd 到桌面，然后执行以下命令就可以看到结果了：\n\n```\n/opt/llvm/llvm_build/Debug/bin/clang -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.2.sdk -Xclang -load -Xclang ./MyPlugin.dylib -Xclang -add-plugin -Xclang MyPlugin -c ./test.m\n```\n\n> 注意：\n>\n> 1. 我编译出来的 clang 在 /opt/llvm/llvm_build/Debug/bin/clang 目录中，如果你与我的路径不一样则指定为你对应的路径\n>\n> 2. 在我写这篇文章时 Xcode 版本是9.2，对应的是 iPhoneSimulator11.2.sdk，你需要进入该目录查看你的 sdk 版本\n\n如无意外，命令行中会出现一大堆输出：\n\n![命令行输出](https://upload-images.jianshu.io/upload_images/698554-0c3a4024f8974640.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n#### Xcode 中使用插件\n\n接下来讲怎么样在 Xcode 使用我们刚刚编译出来的插件（随着 Xcode 变得封闭，插件挂载到 Xcode 上运行在未来的版本中可能会被禁止）。\n\n首先 hack Xcode，才能使 Xcode 指向我们自己编译的 Clang：\n\n下载 [XcodeHacking.zip](http://www.njiang.cn/uploads/2017/03/01/XcodeHacking.zip) 并解压，里面有 HackedBuildSystem.xcspec 和 HackedClang.xcplugin 两个文件，这里可能需要修改一下 HackedClang.xcplugin/Contents/Resources/HackedClang.xcspec 文件，将 ExecPath 的值修改为你编译出来的 Clang 的目录：\n![修改HackedClang.xcspec](https://upload-images.jianshu.io/upload_images/698554-cd4d800cbebe8e09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后 cd 到解压的 XcodeHacking 目录，将这两个文件用命令行移动到对应的目录下：\n\n   ```\n   sudo mv HackedClang.xcplugin `xcode-select -print-path`/../PlugIns/Xcode3Core.ideplugin/Contents/SharedSupport/Developer/Library/Xcode/Plug-ins\n   sudo mv HackedBuildSystem.xcspec `xcode-select -print-path`/Platforms/iPhoneSimulator.platform/Developer/Library/Xcode/Specifications\n   ```\n\n   ​\n\n\n然后重启 Xcode，点击 Target 的 Build Settings，修改 Compiler for C/C++/Objective-C 项为 Clang LLVM Trunk（不进行第1步中 hack Xcode 操作的话是不会有这个选项的）\n\n![Complier.png](https://upload-images.jianshu.io/upload_images/698554-4ad812d07429b0e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后修改 OTHER_CFLAGS 选项：\n![OTHER_CFLAGS.png](https://upload-images.jianshu.io/upload_images/698554-e50bcd49a7356985.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n   ```\n   -Xclang -load -Xclang /Users/Vernon/Desktop/MyPlugin.dylib -Xclang -add-plugin -Xclang MyPlugin\n   ```\n\n> 注意\n>\n> 1. 将 /Users/Vernon/Desktop/MyPlugin.dylib 修改为你生成的插件对应的目录\n> 2. 如果编译中出现一大堆系统库的 symbol not found 错误的话，可以在上述命令的最后手动指定你的 SDK 目录：-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.2.sdk\n\n\n\n最后编译你的项目，然后快捷键 Command+9 跳到 Show the Report navigator，选中刚刚的编译报告，注意下图中每个文件右上角都有可以点击展开的按钮，展开后就能看到我们插件的输出了（下图4为对应输出）。Nice~\n![查看结果](https://upload-images.jianshu.io/upload_images/698554-de614d7d87c219d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n### 结语\n\n文章不长，只是这看似简单的过程也花了我一个多星期的业余时间，写下这个系列文章一是为了记录自己这钻研的过程，以后也可查询，二是希望如果有人能看到这篇拙文可以省下一点时间，更快的踏进 LLVM 和 Clang 的世界探索。\n\n接下来会根据我的个人需求尝试给 Clang 添加自定义的 attribute，如果有所心得，会撰文分享，敬请期待~","source":"_posts/Clang之旅-使用Xcode开发Clang插件.md","raw":"---\ntitle: Clang 之旅--使用 Xcode 开发 Clang 插件\ndate: 2018-03-16 14:44:05\ntags: \n- iOS\n- clang & llvm\ncategories:\n- ruanpapa--技术贴\n---\n\n\n\nClang 之旅系列文章：\n[Clang 之旅--使用 Xcode 开发 Clang 插件](https://www.jianshu.com/p/e3f46d42643b)\n[Clang 之旅--[翻译]添加自定义的 attribute](https://www.jianshu.com/p/d277c42f4907)\n[Clang 之旅--实现一个自定义检查规范的 Clang 插件](https://www.jianshu.com/p/c27b77f70616)\n\n\n\n### 前言\n\n最近在跟老大的聊天中聊到了一个比较特殊的需求：是否有办法在编译阶段检查某个方法的参数与返回值的类型相同，如果类型不一致的话能抛出编译错误的提示。这似乎已经不是 Objective-C 或者 Swift 的语言语法本身所能解决的了，老大还指点了可以从编译器等底层中进行研究。于是，我踏进了 Clang 和 LLVM 的大门。\n\n我打算将 Clang 的研究心得分为几篇文章来写，这是 Clang 之旅的第一篇，主要讲如何用 Xcode 编译 Clang，以及实现一个简单的 Clang 插件并挂载到 Xcode 中参与编译流程，算是进入 Clang 的门槛。只是，这门槛就狠狠地让我吃了苦头，Google 找到好几篇博客讲怎么编译 Clang 的，但是也有一些年头了，版本比较旧，编译出来的 Clang 不能运行在现在的系统上；还有一些写的比较含糊，漏了某些关键步骤，导致花了好几个小时跟着教程做下来最后还是一堆 error；而且试错的成本还是比较高的，下载的源码有1G多（考虑从 Github 下载的速度🙄，需要挂个代理），完整编译出来有20G左右，我的15款 Macbook Pro 大概需要疯狂编译2个小时…...如果不能接受这些的话，还是别尝试了，很遗憾，你连见到 Clang 真容的机会都没有┑(￣Д ￣)┍\n\n![llvm大小](https://upload-images.jianshu.io/upload_images/698554-49318ad53d98d6ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n### 编译源码\n\n#### 准备工作\n\nClang 需要用 CMake 来编译，CMake 的安装方法可以参考这篇文章：[Mac 安装 CMake & CMake Command Line Tools](https://www.jianshu.com/p/7466c85d5d6b)，建议对 CMake 完全不了解的同学可以先补充一点 CMake 的基本知识，这样能更容易理解接下来要做的事情，CMake 的入门知识可以参考：[CMake 入门实战](http://www.hahack.com/codes/cmake/)\n\n\n\n#### 下载源码\n\n首先创建 LLVM 的源码路径及编译路径：\n\n```\ncd /opt\nsudo mkdir llvm\nsudo chown `whoami` llvm\t// 将 llvm 目录的所有者指定为当前用户\ncd llvm\nexport LLVM_HOME=`pwd`\t\t// 设置当前目录(/opt/llvm)为 LLVM_HOME 目录\n```\n\n接下来从 Github clone 源代码（注意这几条语句中的 release_60，在当前时间2018.3.18时，我试过了 release_33、release_39，编译出来的 Clang 插件在运行的时候都会报 NSUUID 的 Nullability 错误，应该是这些版本不支持 Objective-C 后来加的 Nullability 特性，所以我下载了当前最新的 release_60 分支。一般来说，最新分支是兼容已有特性的，所以优先下载最新分支，分支查看可以参照下图）：\n\n```\ngit clone -b release_60 git@github.com:llvm-mirror/llvm.git llvm\ngit clone -b release_60 git@github.com:llvm-mirror/clang.git llvm/tools/clang\ngit clone -b release_60 git@github.com:llvm-mirror/clang-tools-extra.git llvm/tools/clang/tools/extra\ngit clone -b release_60 git@github.com:llvm-mirror/compiler-rt.git llvm/projects/compiler-rt\n```\n\n![llvm最新分支.png](https://upload-images.jianshu.io/upload_images/698554-5e54bd18bac5a151.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n#### 编译源码\n\n生成 Xcode 工程（也可以直接用命令行编译，不过大家平时可能看习惯了 Xcode 工程，所以用 Xcode 编译比较习惯）\n\n```\nmkdir llvm_build; cd llvm_build\ncmake -G Xcode ../llvm -DCMAKE_BUILD_TYPE:STRING=MinSizeRel\n```\n\n生成的文件如下：\n\n![Xcode工程.png](https://upload-images.jianshu.io/upload_images/698554-975fe9e218257288.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n打开 Xcode 工程，选择自动创建 Schemes：\n\n![自动创建Schemes.png](https://upload-images.jianshu.io/upload_images/698554-dd7980d5fe52b689.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后编译 Clang 和 libClang（可以随时终止编译，再次点击编译会从上次停止的地方继续进行）：\n\n![编译Clang和libClang](https://upload-images.jianshu.io/upload_images/698554-cad3858632e8185b.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这里可能需要1个多小时才能完成编译，如无意外，编译成功！\n\n\n\n### 编写你的第一个插件\n\n这个插件实现的功能就是打印语法树上所有节点的类名以及父类名，创建 Clang 插件的整体步骤如下图：\n\n![创建插件.png](https://upload-images.jianshu.io/upload_images/698554-214742ce207ea7ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n首先修改源代码目录 /opt/llvm/llvm/tools/clang/tools 下的 CMakeLists.txt 文件，添加一个新的编译目标，直接在 CMakeLists.txt 的最后面添加上一行，如下图：\n![添加新的编译目标.png](https://upload-images.jianshu.io/upload_images/698554-db674e4e4ade824d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n然后在 tools 目录下添加 MyPlugin 文件夹，文件夹里面新增两个文件 CMakeLists.txt 和 MyPlugin.cpp，这里先不讲解具体文件中的内容，目的是想让插件跑起来，看到运行效果。\n\n   CMakeLists.txt 文件如下：\n\n   ```cmake\n   add_llvm_loadable_module(MyPlugin \n   MyPlugin.cpp\n   PLUGIN_TOOL clang\n   )\n\n   if(LLVM_ENABLE_PLUGINS AND (WIN32 OR CYGWIN))\n     target_link_libraries(MyPlugin PRIVATE\n       clangAST\n       clangBasic\n       clangFrontend\n       clangLex\n       LLVMSupport\n       )\n   endif()\n   ```\n\n   MyPlugin.cpp 文件如下：\n\n   ```c++\n   #include <iostream>\n   #include \"clang/AST/AST.h\"\n   #include \"clang/AST/ASTConsumer.h\"\n   #include \"clang/AST/RecursiveASTVisitor.h\"\n   #include \"clang/Frontend/CompilerInstance.h\"\n   #include \"clang/Frontend/FrontendPluginRegistry.h\"\n   using namespace clang;\n   using namespace std;\n   using namespace llvm;\n   namespace MyPlugin\n   {\n       class MyASTVisitor: public\n       RecursiveASTVisitor < MyASTVisitor >\n       {\n   private:\n           ASTContext *context;\n   public:\n           void setContext(ASTContext &context)\n           {\n               this->context = &context;\n           }\n\n           bool VisitDecl(Decl *decl)\n           {\n               if (isa < ObjCInterfaceDecl > (decl)) {\n                   ObjCInterfaceDecl *interDecl = (ObjCInterfaceDecl *)decl;\n                   if (interDecl->getSuperClass()) {\n                       string interName = interDecl->getNameAsString();\n                       string superClassName = interDecl->getSuperClass()->getNameAsString();\n\n                       cout << \"-------- ClassName:\" << interName << \" superClassName:\" << superClassName << endl;\n                   }\n               }\n\n               return true;\n           }\n       };\n       \n       class MyASTConsumer: public ASTConsumer\n       {\n   private:\n           MyASTVisitor visitor;\n           void HandleTranslationUnit(ASTContext &context)\n           {\n               visitor.setContext(context);\n               visitor.TraverseDecl(context.getTranslationUnitDecl());\n           }\n       };\n       class MyASTAction: public PluginASTAction\n       {\n   public:\n           unique_ptr < ASTConsumer > CreateASTConsumer(CompilerInstance & Compiler, StringRef InFile) {\n               return unique_ptr < MyASTConsumer > (new MyASTConsumer);\n           }\n           bool ParseArgs(const CompilerInstance &CI, const std::vector < std::string >& args)\n           {\n               return true;\n           }\n       };\n   }\n   static clang::FrontendPluginRegistry::Add\n   < MyPlugin::MyASTAction > X(\"MyPlugin\",\n                               \"MyPlugin desc\");\n   ```\n\n再次在 llvm_build 目录下 CMake 一下\n\n```cmake\ncmake -G Xcode ../llvm -DCMAKE_BUILD_TYPE:STRING=MinSizeRel\n```\n\n然后重新打开 LLVM.xcodeproj 工程，会发现多了一个 MyPlugin 的编译目标，选中进行编译。\n\n![编译myPlugin.png](https://upload-images.jianshu.io/upload_images/698554-a1ec081353964edc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n编译成功之后，就可以得到一个 MyPlugin.dylib 的 Clang 插件了~为了方便，我将 MyPlugin.dylib 放在桌面上：\n\n![MyPlugin插件.png](https://upload-images.jianshu.io/upload_images/698554-3b17229fdf5192e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n### 使用插件\n\n#### 命令行中使用插件\n\n首先用命令行对单文件测试一下刚刚生成的 Clang 插件是否正确，新建一个测试用文件 test.m 放在桌面，test.m 如下：\n\n```objective-c\n#import<UIKit/UIKit.h>\n@interface ViewController : UIViewController\n@end\n@implementation ViewController\n- (instancetype)init\n{\n\tif(self = [super init]){\n\t}\n\treturn self;\n}\n@end\n```\n\n现在我的 test.m 和 MyPlugin.dylib 都在桌面上了（当然也可以放在不同的目录下，只要在待会用到这两个文件的地方指定各自的绝对路径就行，这里是为了方便叙述）\n\n![文件结构](https://upload-images.jianshu.io/upload_images/698554-5bd1c283af274180.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n接着命令行 cd 到桌面，然后执行以下命令就可以看到结果了：\n\n```\n/opt/llvm/llvm_build/Debug/bin/clang -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.2.sdk -Xclang -load -Xclang ./MyPlugin.dylib -Xclang -add-plugin -Xclang MyPlugin -c ./test.m\n```\n\n> 注意：\n>\n> 1. 我编译出来的 clang 在 /opt/llvm/llvm_build/Debug/bin/clang 目录中，如果你与我的路径不一样则指定为你对应的路径\n>\n> 2. 在我写这篇文章时 Xcode 版本是9.2，对应的是 iPhoneSimulator11.2.sdk，你需要进入该目录查看你的 sdk 版本\n\n如无意外，命令行中会出现一大堆输出：\n\n![命令行输出](https://upload-images.jianshu.io/upload_images/698554-0c3a4024f8974640.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n#### Xcode 中使用插件\n\n接下来讲怎么样在 Xcode 使用我们刚刚编译出来的插件（随着 Xcode 变得封闭，插件挂载到 Xcode 上运行在未来的版本中可能会被禁止）。\n\n首先 hack Xcode，才能使 Xcode 指向我们自己编译的 Clang：\n\n下载 [XcodeHacking.zip](http://www.njiang.cn/uploads/2017/03/01/XcodeHacking.zip) 并解压，里面有 HackedBuildSystem.xcspec 和 HackedClang.xcplugin 两个文件，这里可能需要修改一下 HackedClang.xcplugin/Contents/Resources/HackedClang.xcspec 文件，将 ExecPath 的值修改为你编译出来的 Clang 的目录：\n![修改HackedClang.xcspec](https://upload-images.jianshu.io/upload_images/698554-cd4d800cbebe8e09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后 cd 到解压的 XcodeHacking 目录，将这两个文件用命令行移动到对应的目录下：\n\n   ```\n   sudo mv HackedClang.xcplugin `xcode-select -print-path`/../PlugIns/Xcode3Core.ideplugin/Contents/SharedSupport/Developer/Library/Xcode/Plug-ins\n   sudo mv HackedBuildSystem.xcspec `xcode-select -print-path`/Platforms/iPhoneSimulator.platform/Developer/Library/Xcode/Specifications\n   ```\n\n   ​\n\n\n然后重启 Xcode，点击 Target 的 Build Settings，修改 Compiler for C/C++/Objective-C 项为 Clang LLVM Trunk（不进行第1步中 hack Xcode 操作的话是不会有这个选项的）\n\n![Complier.png](https://upload-images.jianshu.io/upload_images/698554-4ad812d07429b0e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后修改 OTHER_CFLAGS 选项：\n![OTHER_CFLAGS.png](https://upload-images.jianshu.io/upload_images/698554-e50bcd49a7356985.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n   ```\n   -Xclang -load -Xclang /Users/Vernon/Desktop/MyPlugin.dylib -Xclang -add-plugin -Xclang MyPlugin\n   ```\n\n> 注意\n>\n> 1. 将 /Users/Vernon/Desktop/MyPlugin.dylib 修改为你生成的插件对应的目录\n> 2. 如果编译中出现一大堆系统库的 symbol not found 错误的话，可以在上述命令的最后手动指定你的 SDK 目录：-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.2.sdk\n\n\n\n最后编译你的项目，然后快捷键 Command+9 跳到 Show the Report navigator，选中刚刚的编译报告，注意下图中每个文件右上角都有可以点击展开的按钮，展开后就能看到我们插件的输出了（下图4为对应输出）。Nice~\n![查看结果](https://upload-images.jianshu.io/upload_images/698554-de614d7d87c219d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n### 结语\n\n文章不长，只是这看似简单的过程也花了我一个多星期的业余时间，写下这个系列文章一是为了记录自己这钻研的过程，以后也可查询，二是希望如果有人能看到这篇拙文可以省下一点时间，更快的踏进 LLVM 和 Clang 的世界探索。\n\n接下来会根据我的个人需求尝试给 Clang 添加自定义的 attribute，如果有所心得，会撰文分享，敬请期待~","slug":"Clang之旅-使用Xcode开发Clang插件","published":1,"updated":"2018-04-18T03:22:48.022Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg4j8vya0003vfwxdx1s8qcj","content":"<p>Clang 之旅系列文章：<br><a href=\"https://www.jianshu.com/p/e3f46d42643b\" target=\"_blank\" rel=\"external\">Clang 之旅–使用 Xcode 开发 Clang 插件</a><br><a href=\"https://www.jianshu.com/p/d277c42f4907\" target=\"_blank\" rel=\"external\">Clang 之旅–[翻译]添加自定义的 attribute</a><br><a href=\"https://www.jianshu.com/p/c27b77f70616\" target=\"_blank\" rel=\"external\">Clang 之旅–实现一个自定义检查规范的 Clang 插件</a></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>最近在跟老大的聊天中聊到了一个比较特殊的需求：是否有办法在编译阶段检查某个方法的参数与返回值的类型相同，如果类型不一致的话能抛出编译错误的提示。这似乎已经不是 Objective-C 或者 Swift 的语言语法本身所能解决的了，老大还指点了可以从编译器等底层中进行研究。于是，我踏进了 Clang 和 LLVM 的大门。</p>\n<p>我打算将 Clang 的研究心得分为几篇文章来写，这是 Clang 之旅的第一篇，主要讲如何用 Xcode 编译 Clang，以及实现一个简单的 Clang 插件并挂载到 Xcode 中参与编译流程，算是进入 Clang 的门槛。只是，这门槛就狠狠地让我吃了苦头，Google 找到好几篇博客讲怎么编译 Clang 的，但是也有一些年头了，版本比较旧，编译出来的 Clang 不能运行在现在的系统上；还有一些写的比较含糊，漏了某些关键步骤，导致花了好几个小时跟着教程做下来最后还是一堆 error；而且试错的成本还是比较高的，下载的源码有1G多（考虑从 Github 下载的速度🙄，需要挂个代理），完整编译出来有20G左右，我的15款 Macbook Pro 大概需要疯狂编译2个小时……如果不能接受这些的话，还是别尝试了，很遗憾，你连见到 Clang 真容的机会都没有┑(￣Д ￣)┍</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/698554-49318ad53d98d6ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"llvm大小\"></p>\n<h3 id=\"编译源码\"><a href=\"#编译源码\" class=\"headerlink\" title=\"编译源码\"></a>编译源码</h3><h4 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h4><p>Clang 需要用 CMake 来编译，CMake 的安装方法可以参考这篇文章：<a href=\"https://www.jianshu.com/p/7466c85d5d6b\" target=\"_blank\" rel=\"external\">Mac 安装 CMake &amp; CMake Command Line Tools</a>，建议对 CMake 完全不了解的同学可以先补充一点 CMake 的基本知识，这样能更容易理解接下来要做的事情，CMake 的入门知识可以参考：<a href=\"http://www.hahack.com/codes/cmake/\" target=\"_blank\" rel=\"external\">CMake 入门实战</a></p>\n<h4 id=\"下载源码\"><a href=\"#下载源码\" class=\"headerlink\" title=\"下载源码\"></a>下载源码</h4><p>首先创建 LLVM 的源码路径及编译路径：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd /opt</div><div class=\"line\">sudo mkdir llvm</div><div class=\"line\">sudo chown `whoami` llvm\t// 将 llvm 目录的所有者指定为当前用户</div><div class=\"line\">cd llvm</div><div class=\"line\">export LLVM_HOME=`pwd`\t\t// 设置当前目录(/opt/llvm)为 LLVM_HOME 目录</div></pre></td></tr></table></figure>\n<p>接下来从 Github clone 源代码（注意这几条语句中的 release_60，在当前时间2018.3.18时，我试过了 release_33、release_39，编译出来的 Clang 插件在运行的时候都会报 NSUUID 的 Nullability 错误，应该是这些版本不支持 Objective-C 后来加的 Nullability 特性，所以我下载了当前最新的 release_60 分支。一般来说，最新分支是兼容已有特性的，所以优先下载最新分支，分支查看可以参照下图）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone -b release_60 git@github.com:llvm-mirror/llvm.git llvm</div><div class=\"line\">git clone -b release_60 git@github.com:llvm-mirror/clang.git llvm/tools/clang</div><div class=\"line\">git clone -b release_60 git@github.com:llvm-mirror/clang-tools-extra.git llvm/tools/clang/tools/extra</div><div class=\"line\">git clone -b release_60 git@github.com:llvm-mirror/compiler-rt.git llvm/projects/compiler-rt</div></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/698554-5e54bd18bac5a151.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"llvm最新分支.png\"></p>\n<h4 id=\"编译源码-1\"><a href=\"#编译源码-1\" class=\"headerlink\" title=\"编译源码\"></a>编译源码</h4><p>生成 Xcode 工程（也可以直接用命令行编译，不过大家平时可能看习惯了 Xcode 工程，所以用 Xcode 编译比较习惯）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir llvm_build; cd llvm_build</div><div class=\"line\">cmake -G Xcode ../llvm -DCMAKE_BUILD_TYPE:STRING=MinSizeRel</div></pre></td></tr></table></figure>\n<p>生成的文件如下：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/698554-975fe9e218257288.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Xcode工程.png\"></p>\n<p>打开 Xcode 工程，选择自动创建 Schemes：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/698554-dd7980d5fe52b689.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"自动创建Schemes.png\"></p>\n<p>然后编译 Clang 和 libClang（可以随时终止编译，再次点击编译会从上次停止的地方继续进行）：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/698554-cad3858632e8185b.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"编译Clang和libClang\"></p>\n<p>这里可能需要1个多小时才能完成编译，如无意外，编译成功！</p>\n<h3 id=\"编写你的第一个插件\"><a href=\"#编写你的第一个插件\" class=\"headerlink\" title=\"编写你的第一个插件\"></a>编写你的第一个插件</h3><p>这个插件实现的功能就是打印语法树上所有节点的类名以及父类名，创建 Clang 插件的整体步骤如下图：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/698554-214742ce207ea7ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"创建插件.png\"></p>\n<p>首先修改源代码目录 /opt/llvm/llvm/tools/clang/tools 下的 CMakeLists.txt 文件，添加一个新的编译目标，直接在 CMakeLists.txt 的最后面添加上一行，如下图：<br><img src=\"https://upload-images.jianshu.io/upload_images/698554-db674e4e4ade824d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"添加新的编译目标.png\"></p>\n<p>然后在 tools 目录下添加 MyPlugin 文件夹，文件夹里面新增两个文件 CMakeLists.txt 和 MyPlugin.cpp，这里先不讲解具体文件中的内容，目的是想让插件跑起来，看到运行效果。</p>\n<p>   CMakeLists.txt 文件如下：</p>\n   <figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">add_llvm_loadable_module(MyPlugin </div><div class=\"line\">MyPlugin.cpp</div><div class=\"line\">PLUGIN_TOOL clang</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span>(LLVM_ENABLE_PLUGINS <span class=\"keyword\">AND</span> (WIN32 <span class=\"keyword\">OR</span> CYGWIN))</div><div class=\"line\">  <span class=\"keyword\">target_link_libraries</span>(MyPlugin PRIVATE</div><div class=\"line\">    clangAST</div><div class=\"line\">    clangBasic</div><div class=\"line\">    clangFrontend</div><div class=\"line\">    clangLex</div><div class=\"line\">    LLVMSupport</div><div class=\"line\">    )</div><div class=\"line\"><span class=\"keyword\">endif</span>()</div></pre></td></tr></table></figure>\n<p>   MyPlugin.cpp 文件如下：</p>\n   <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"clang/AST/AST.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"clang/AST/ASTConsumer.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"clang/AST/RecursiveASTVisitor.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"clang/Frontend/CompilerInstance.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"clang/Frontend/FrontendPluginRegistry.h\"</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> clang;</div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> llvm;</div><div class=\"line\"><span class=\"keyword\">namespace</span> MyPlugin</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">class</span> MyASTVisitor: <span class=\"keyword\">public</span></div><div class=\"line\">    RecursiveASTVisitor &lt; MyASTVisitor &gt;</div><div class=\"line\">    &#123;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">        ASTContext *context;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setContext</span><span class=\"params\">(ASTContext &amp;context)</span></span></div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>-&gt;context = &amp;context;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">VisitDecl</span><span class=\"params\">(Decl *decl)</span></span></div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (isa &lt; ObjCInterfaceDecl &gt; (decl)) &#123;</div><div class=\"line\">                ObjCInterfaceDecl *interDecl = (ObjCInterfaceDecl *)decl;</div><div class=\"line\">                <span class=\"keyword\">if</span> (interDecl-&gt;getSuperClass()) &#123;</div><div class=\"line\">                    <span class=\"built_in\">string</span> interName = interDecl-&gt;getNameAsString();</div><div class=\"line\">                    <span class=\"built_in\">string</span> superClassName = interDecl-&gt;getSuperClass()-&gt;getNameAsString();</div><div class=\"line\"></div><div class=\"line\">                    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"-------- ClassName:\"</span> &lt;&lt; interName &lt;&lt; <span class=\"string\">\" superClassName:\"</span> &lt;&lt; superClassName &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">class</span> MyASTConsumer: <span class=\"keyword\">public</span> ASTConsumer</div><div class=\"line\">    &#123;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">        MyASTVisitor visitor;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">HandleTranslationUnit</span><span class=\"params\">(ASTContext &amp;context)</span></span></div><div class=\"line\">        &#123;</div><div class=\"line\">            visitor.setContext(context);</div><div class=\"line\">            visitor.TraverseDecl(context.getTranslationUnitDecl());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"keyword\">class</span> MyASTAction: <span class=\"keyword\">public</span> PluginASTAction</div><div class=\"line\">    &#123;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">        <span class=\"built_in\">unique_ptr</span> &lt; ASTConsumer &gt; CreateASTConsumer(CompilerInstance &amp; Compiler, StringRef InFile) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">unique_ptr</span> &lt; MyASTConsumer &gt; (<span class=\"keyword\">new</span> MyASTConsumer);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ParseArgs</span><span class=\"params\">(<span class=\"keyword\">const</span> CompilerInstance &amp;CI, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span> &lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &gt;&amp; args)</span></span></div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">static</span> clang::FrontendPluginRegistry::Add</div><div class=\"line\">&lt; MyPlugin::MyASTAction &gt; X(<span class=\"string\">\"MyPlugin\"</span>,</div><div class=\"line\">                            <span class=\"string\">\"MyPlugin desc\"</span>);</div></pre></td></tr></table></figure>\n<p>再次在 llvm_build 目录下 CMake 一下</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cmake -G Xcode ../llvm -DCMAKE_BUILD_TYPE:<span class=\"keyword\">STRING</span>=MinSizeRel</div></pre></td></tr></table></figure>\n<p>然后重新打开 LLVM.xcodeproj 工程，会发现多了一个 MyPlugin 的编译目标，选中进行编译。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/698554-a1ec081353964edc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"编译myPlugin.png\"></p>\n<p>编译成功之后，就可以得到一个 MyPlugin.dylib 的 Clang 插件了~为了方便，我将 MyPlugin.dylib 放在桌面上：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/698554-3b17229fdf5192e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"MyPlugin插件.png\"></p>\n<h3 id=\"使用插件\"><a href=\"#使用插件\" class=\"headerlink\" title=\"使用插件\"></a>使用插件</h3><h4 id=\"命令行中使用插件\"><a href=\"#命令行中使用插件\" class=\"headerlink\" title=\"命令行中使用插件\"></a>命令行中使用插件</h4><p>首先用命令行对单文件测试一下刚刚生成的 Clang 插件是否正确，新建一个测试用文件 test.m 放在桌面，test.m 如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import&lt;UIKit/UIKit.h&gt;</div><div class=\"line\">@interface ViewController : UIViewController</div><div class=\"line\">@end</div><div class=\"line\">@implementation ViewController</div><div class=\"line\">- (instancetype)init</div><div class=\"line\">&#123;</div><div class=\"line\">\tif(self = [super init])&#123;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn self;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>现在我的 test.m 和 MyPlugin.dylib 都在桌面上了（当然也可以放在不同的目录下，只要在待会用到这两个文件的地方指定各自的绝对路径就行，这里是为了方便叙述）</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/698554-5bd1c283af274180.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"文件结构\"></p>\n<p>接着命令行 cd 到桌面，然后执行以下命令就可以看到结果了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/opt/llvm/llvm_build/Debug/bin/clang -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.2.sdk -Xclang -load -Xclang ./MyPlugin.dylib -Xclang -add-plugin -Xclang MyPlugin -c ./test.m</div></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：</p>\n<ol>\n<li><p>我编译出来的 clang 在 /opt/llvm/llvm_build/Debug/bin/clang 目录中，如果你与我的路径不一样则指定为你对应的路径</p>\n</li>\n<li><p>在我写这篇文章时 Xcode 版本是9.2，对应的是 iPhoneSimulator11.2.sdk，你需要进入该目录查看你的 sdk 版本</p>\n</li>\n</ol>\n</blockquote>\n<p>如无意外，命令行中会出现一大堆输出：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/698554-0c3a4024f8974640.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"命令行输出\"></p>\n<h4 id=\"Xcode-中使用插件\"><a href=\"#Xcode-中使用插件\" class=\"headerlink\" title=\"Xcode 中使用插件\"></a>Xcode 中使用插件</h4><p>接下来讲怎么样在 Xcode 使用我们刚刚编译出来的插件（随着 Xcode 变得封闭，插件挂载到 Xcode 上运行在未来的版本中可能会被禁止）。</p>\n<p>首先 hack Xcode，才能使 Xcode 指向我们自己编译的 Clang：</p>\n<p>下载 <a href=\"http://www.njiang.cn/uploads/2017/03/01/XcodeHacking.zip\" target=\"_blank\" rel=\"external\">XcodeHacking.zip</a> 并解压，里面有 HackedBuildSystem.xcspec 和 HackedClang.xcplugin 两个文件，这里可能需要修改一下 HackedClang.xcplugin/Contents/Resources/HackedClang.xcspec 文件，将 ExecPath 的值修改为你编译出来的 Clang 的目录：<br><img src=\"https://upload-images.jianshu.io/upload_images/698554-cd4d800cbebe8e09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"修改HackedClang.xcspec\"></p>\n<p>然后 cd 到解压的 XcodeHacking 目录，将这两个文件用命令行移动到对应的目录下：</p>\n   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo mv HackedClang.xcplugin `xcode-select -print-path`/../PlugIns/Xcode3Core.ideplugin/Contents/SharedSupport/Developer/Library/Xcode/Plug-ins</div><div class=\"line\">sudo mv HackedBuildSystem.xcspec `xcode-select -print-path`/Platforms/iPhoneSimulator.platform/Developer/Library/Xcode/Specifications</div></pre></td></tr></table></figure>\n<p>   ​</p>\n<p>然后重启 Xcode，点击 Target 的 Build Settings，修改 Compiler for C/C++/Objective-C 项为 Clang LLVM Trunk（不进行第1步中 hack Xcode 操作的话是不会有这个选项的）</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/698554-4ad812d07429b0e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Complier.png\"></p>\n<p>然后修改 OTHER_CFLAGS 选项：<br><img src=\"https://upload-images.jianshu.io/upload_images/698554-e50bcd49a7356985.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"OTHER_CFLAGS.png\"></p>\n   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-Xclang -load -Xclang /Users/Vernon/Desktop/MyPlugin.dylib -Xclang -add-plugin -Xclang MyPlugin</div></pre></td></tr></table></figure>\n<blockquote>\n<p>注意</p>\n<ol>\n<li>将 /Users/Vernon/Desktop/MyPlugin.dylib 修改为你生成的插件对应的目录</li>\n<li>如果编译中出现一大堆系统库的 symbol not found 错误的话，可以在上述命令的最后手动指定你的 SDK 目录：-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.2.sdk</li>\n</ol>\n</blockquote>\n<p>最后编译你的项目，然后快捷键 Command+9 跳到 Show the Report navigator，选中刚刚的编译报告，注意下图中每个文件右上角都有可以点击展开的按钮，展开后就能看到我们插件的输出了（下图4为对应输出）。Nice~<br><img src=\"https://upload-images.jianshu.io/upload_images/698554-de614d7d87c219d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"查看结果\"></p>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>文章不长，只是这看似简单的过程也花了我一个多星期的业余时间，写下这个系列文章一是为了记录自己这钻研的过程，以后也可查询，二是希望如果有人能看到这篇拙文可以省下一点时间，更快的踏进 LLVM 和 Clang 的世界探索。</p>\n<p>接下来会根据我的个人需求尝试给 Clang 添加自定义的 attribute，如果有所心得，会撰文分享，敬请期待~</p>\n","excerpt":"","more":"<p>Clang 之旅系列文章：<br><a href=\"https://www.jianshu.com/p/e3f46d42643b\">Clang 之旅–使用 Xcode 开发 Clang 插件</a><br><a href=\"https://www.jianshu.com/p/d277c42f4907\">Clang 之旅–[翻译]添加自定义的 attribute</a><br><a href=\"https://www.jianshu.com/p/c27b77f70616\">Clang 之旅–实现一个自定义检查规范的 Clang 插件</a></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>最近在跟老大的聊天中聊到了一个比较特殊的需求：是否有办法在编译阶段检查某个方法的参数与返回值的类型相同，如果类型不一致的话能抛出编译错误的提示。这似乎已经不是 Objective-C 或者 Swift 的语言语法本身所能解决的了，老大还指点了可以从编译器等底层中进行研究。于是，我踏进了 Clang 和 LLVM 的大门。</p>\n<p>我打算将 Clang 的研究心得分为几篇文章来写，这是 Clang 之旅的第一篇，主要讲如何用 Xcode 编译 Clang，以及实现一个简单的 Clang 插件并挂载到 Xcode 中参与编译流程，算是进入 Clang 的门槛。只是，这门槛就狠狠地让我吃了苦头，Google 找到好几篇博客讲怎么编译 Clang 的，但是也有一些年头了，版本比较旧，编译出来的 Clang 不能运行在现在的系统上；还有一些写的比较含糊，漏了某些关键步骤，导致花了好几个小时跟着教程做下来最后还是一堆 error；而且试错的成本还是比较高的，下载的源码有1G多（考虑从 Github 下载的速度🙄，需要挂个代理），完整编译出来有20G左右，我的15款 Macbook Pro 大概需要疯狂编译2个小时……如果不能接受这些的话，还是别尝试了，很遗憾，你连见到 Clang 真容的机会都没有┑(￣Д ￣)┍</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/698554-49318ad53d98d6ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"llvm大小\"></p>\n<h3 id=\"编译源码\"><a href=\"#编译源码\" class=\"headerlink\" title=\"编译源码\"></a>编译源码</h3><h4 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h4><p>Clang 需要用 CMake 来编译，CMake 的安装方法可以参考这篇文章：<a href=\"https://www.jianshu.com/p/7466c85d5d6b\">Mac 安装 CMake &amp; CMake Command Line Tools</a>，建议对 CMake 完全不了解的同学可以先补充一点 CMake 的基本知识，这样能更容易理解接下来要做的事情，CMake 的入门知识可以参考：<a href=\"http://www.hahack.com/codes/cmake/\">CMake 入门实战</a></p>\n<h4 id=\"下载源码\"><a href=\"#下载源码\" class=\"headerlink\" title=\"下载源码\"></a>下载源码</h4><p>首先创建 LLVM 的源码路径及编译路径：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd /opt</div><div class=\"line\">sudo mkdir llvm</div><div class=\"line\">sudo chown `whoami` llvm\t// 将 llvm 目录的所有者指定为当前用户</div><div class=\"line\">cd llvm</div><div class=\"line\">export LLVM_HOME=`pwd`\t\t// 设置当前目录(/opt/llvm)为 LLVM_HOME 目录</div></pre></td></tr></table></figure>\n<p>接下来从 Github clone 源代码（注意这几条语句中的 release_60，在当前时间2018.3.18时，我试过了 release_33、release_39，编译出来的 Clang 插件在运行的时候都会报 NSUUID 的 Nullability 错误，应该是这些版本不支持 Objective-C 后来加的 Nullability 特性，所以我下载了当前最新的 release_60 分支。一般来说，最新分支是兼容已有特性的，所以优先下载最新分支，分支查看可以参照下图）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone -b release_60 git@github.com:llvm-mirror/llvm.git llvm</div><div class=\"line\">git clone -b release_60 git@github.com:llvm-mirror/clang.git llvm/tools/clang</div><div class=\"line\">git clone -b release_60 git@github.com:llvm-mirror/clang-tools-extra.git llvm/tools/clang/tools/extra</div><div class=\"line\">git clone -b release_60 git@github.com:llvm-mirror/compiler-rt.git llvm/projects/compiler-rt</div></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/698554-5e54bd18bac5a151.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"llvm最新分支.png\"></p>\n<h4 id=\"编译源码-1\"><a href=\"#编译源码-1\" class=\"headerlink\" title=\"编译源码\"></a>编译源码</h4><p>生成 Xcode 工程（也可以直接用命令行编译，不过大家平时可能看习惯了 Xcode 工程，所以用 Xcode 编译比较习惯）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir llvm_build; cd llvm_build</div><div class=\"line\">cmake -G Xcode ../llvm -DCMAKE_BUILD_TYPE:STRING=MinSizeRel</div></pre></td></tr></table></figure>\n<p>生成的文件如下：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/698554-975fe9e218257288.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Xcode工程.png\"></p>\n<p>打开 Xcode 工程，选择自动创建 Schemes：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/698554-dd7980d5fe52b689.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"自动创建Schemes.png\"></p>\n<p>然后编译 Clang 和 libClang（可以随时终止编译，再次点击编译会从上次停止的地方继续进行）：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/698554-cad3858632e8185b.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"编译Clang和libClang\"></p>\n<p>这里可能需要1个多小时才能完成编译，如无意外，编译成功！</p>\n<h3 id=\"编写你的第一个插件\"><a href=\"#编写你的第一个插件\" class=\"headerlink\" title=\"编写你的第一个插件\"></a>编写你的第一个插件</h3><p>这个插件实现的功能就是打印语法树上所有节点的类名以及父类名，创建 Clang 插件的整体步骤如下图：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/698554-214742ce207ea7ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"创建插件.png\"></p>\n<p>首先修改源代码目录 /opt/llvm/llvm/tools/clang/tools 下的 CMakeLists.txt 文件，添加一个新的编译目标，直接在 CMakeLists.txt 的最后面添加上一行，如下图：<br><img src=\"https://upload-images.jianshu.io/upload_images/698554-db674e4e4ade824d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"添加新的编译目标.png\"></p>\n<p>然后在 tools 目录下添加 MyPlugin 文件夹，文件夹里面新增两个文件 CMakeLists.txt 和 MyPlugin.cpp，这里先不讲解具体文件中的内容，目的是想让插件跑起来，看到运行效果。</p>\n<p>   CMakeLists.txt 文件如下：</p>\n   <figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">add_llvm_loadable_module(MyPlugin </div><div class=\"line\">MyPlugin.cpp</div><div class=\"line\">PLUGIN_TOOL clang</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span>(LLVM_ENABLE_PLUGINS <span class=\"keyword\">AND</span> (WIN32 <span class=\"keyword\">OR</span> CYGWIN))</div><div class=\"line\">  <span class=\"keyword\">target_link_libraries</span>(MyPlugin PRIVATE</div><div class=\"line\">    clangAST</div><div class=\"line\">    clangBasic</div><div class=\"line\">    clangFrontend</div><div class=\"line\">    clangLex</div><div class=\"line\">    LLVMSupport</div><div class=\"line\">    )</div><div class=\"line\"><span class=\"keyword\">endif</span>()</div></pre></td></tr></table></figure>\n<p>   MyPlugin.cpp 文件如下：</p>\n   <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"clang/AST/AST.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"clang/AST/ASTConsumer.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"clang/AST/RecursiveASTVisitor.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"clang/Frontend/CompilerInstance.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"clang/Frontend/FrontendPluginRegistry.h\"</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> clang;</div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> llvm;</div><div class=\"line\"><span class=\"keyword\">namespace</span> MyPlugin</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">class</span> MyASTVisitor: <span class=\"keyword\">public</span></div><div class=\"line\">    RecursiveASTVisitor &lt; MyASTVisitor &gt;</div><div class=\"line\">    &#123;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">        ASTContext *context;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setContext</span><span class=\"params\">(ASTContext &amp;context)</span></div><div class=\"line\">        </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>-&gt;context = &amp;context;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">VisitDecl</span><span class=\"params\">(Decl *decl)</span></div><div class=\"line\">        </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (isa &lt; ObjCInterfaceDecl &gt; (decl)) &#123;</div><div class=\"line\">                ObjCInterfaceDecl *interDecl = (ObjCInterfaceDecl *)decl;</div><div class=\"line\">                <span class=\"keyword\">if</span> (interDecl-&gt;getSuperClass()) &#123;</div><div class=\"line\">                    <span class=\"built_in\">string</span> interName = interDecl-&gt;getNameAsString();</div><div class=\"line\">                    <span class=\"built_in\">string</span> superClassName = interDecl-&gt;getSuperClass()-&gt;getNameAsString();</div><div class=\"line\"></div><div class=\"line\">                    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"-------- ClassName:\"</span> &lt;&lt; interName &lt;&lt; <span class=\"string\">\" superClassName:\"</span> &lt;&lt; superClassName &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">class</span> MyASTConsumer: <span class=\"keyword\">public</span> ASTConsumer</div><div class=\"line\">    &#123;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">        MyASTVisitor visitor;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">HandleTranslationUnit</span><span class=\"params\">(ASTContext &amp;context)</span></div><div class=\"line\">        </span>&#123;</div><div class=\"line\">            visitor.setContext(context);</div><div class=\"line\">            visitor.TraverseDecl(context.getTranslationUnitDecl());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"keyword\">class</span> MyASTAction: <span class=\"keyword\">public</span> PluginASTAction</div><div class=\"line\">    &#123;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">        <span class=\"built_in\">unique_ptr</span> &lt; ASTConsumer &gt; CreateASTConsumer(CompilerInstance &amp; Compiler, StringRef InFile) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">unique_ptr</span> &lt; MyASTConsumer &gt; (<span class=\"keyword\">new</span> MyASTConsumer);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ParseArgs</span><span class=\"params\">(<span class=\"keyword\">const</span> CompilerInstance &amp;CI, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span> &lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &gt;&amp; args)</span></div><div class=\"line\">        </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">static</span> clang::FrontendPluginRegistry::Add</div><div class=\"line\">&lt; MyPlugin::MyASTAction &gt; X(<span class=\"string\">\"MyPlugin\"</span>,</div><div class=\"line\">                            <span class=\"string\">\"MyPlugin desc\"</span>);</div></pre></td></tr></table></figure>\n<p>再次在 llvm_build 目录下 CMake 一下</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cmake -G Xcode ../llvm -DCMAKE_BUILD_TYPE:<span class=\"keyword\">STRING</span>=MinSizeRel</div></pre></td></tr></table></figure>\n<p>然后重新打开 LLVM.xcodeproj 工程，会发现多了一个 MyPlugin 的编译目标，选中进行编译。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/698554-a1ec081353964edc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"编译myPlugin.png\"></p>\n<p>编译成功之后，就可以得到一个 MyPlugin.dylib 的 Clang 插件了~为了方便，我将 MyPlugin.dylib 放在桌面上：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/698554-3b17229fdf5192e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"MyPlugin插件.png\"></p>\n<h3 id=\"使用插件\"><a href=\"#使用插件\" class=\"headerlink\" title=\"使用插件\"></a>使用插件</h3><h4 id=\"命令行中使用插件\"><a href=\"#命令行中使用插件\" class=\"headerlink\" title=\"命令行中使用插件\"></a>命令行中使用插件</h4><p>首先用命令行对单文件测试一下刚刚生成的 Clang 插件是否正确，新建一个测试用文件 test.m 放在桌面，test.m 如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import&lt;UIKit/UIKit.h&gt;</div><div class=\"line\">@interface ViewController : UIViewController</div><div class=\"line\">@end</div><div class=\"line\">@implementation ViewController</div><div class=\"line\">- (instancetype)init</div><div class=\"line\">&#123;</div><div class=\"line\">\tif(self = [super init])&#123;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn self;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>现在我的 test.m 和 MyPlugin.dylib 都在桌面上了（当然也可以放在不同的目录下，只要在待会用到这两个文件的地方指定各自的绝对路径就行，这里是为了方便叙述）</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/698554-5bd1c283af274180.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"文件结构\"></p>\n<p>接着命令行 cd 到桌面，然后执行以下命令就可以看到结果了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/opt/llvm/llvm_build/Debug/bin/clang -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.2.sdk -Xclang -load -Xclang ./MyPlugin.dylib -Xclang -add-plugin -Xclang MyPlugin -c ./test.m</div></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：</p>\n<ol>\n<li><p>我编译出来的 clang 在 /opt/llvm/llvm_build/Debug/bin/clang 目录中，如果你与我的路径不一样则指定为你对应的路径</p>\n</li>\n<li><p>在我写这篇文章时 Xcode 版本是9.2，对应的是 iPhoneSimulator11.2.sdk，你需要进入该目录查看你的 sdk 版本</p>\n</li>\n</ol>\n</blockquote>\n<p>如无意外，命令行中会出现一大堆输出：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/698554-0c3a4024f8974640.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"命令行输出\"></p>\n<h4 id=\"Xcode-中使用插件\"><a href=\"#Xcode-中使用插件\" class=\"headerlink\" title=\"Xcode 中使用插件\"></a>Xcode 中使用插件</h4><p>接下来讲怎么样在 Xcode 使用我们刚刚编译出来的插件（随着 Xcode 变得封闭，插件挂载到 Xcode 上运行在未来的版本中可能会被禁止）。</p>\n<p>首先 hack Xcode，才能使 Xcode 指向我们自己编译的 Clang：</p>\n<p>下载 <a href=\"http://www.njiang.cn/uploads/2017/03/01/XcodeHacking.zip\">XcodeHacking.zip</a> 并解压，里面有 HackedBuildSystem.xcspec 和 HackedClang.xcplugin 两个文件，这里可能需要修改一下 HackedClang.xcplugin/Contents/Resources/HackedClang.xcspec 文件，将 ExecPath 的值修改为你编译出来的 Clang 的目录：<br><img src=\"https://upload-images.jianshu.io/upload_images/698554-cd4d800cbebe8e09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"修改HackedClang.xcspec\"></p>\n<p>然后 cd 到解压的 XcodeHacking 目录，将这两个文件用命令行移动到对应的目录下：</p>\n   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo mv HackedClang.xcplugin `xcode-select -print-path`/../PlugIns/Xcode3Core.ideplugin/Contents/SharedSupport/Developer/Library/Xcode/Plug-ins</div><div class=\"line\">sudo mv HackedBuildSystem.xcspec `xcode-select -print-path`/Platforms/iPhoneSimulator.platform/Developer/Library/Xcode/Specifications</div></pre></td></tr></table></figure>\n<p>   ​</p>\n<p>然后重启 Xcode，点击 Target 的 Build Settings，修改 Compiler for C/C++/Objective-C 项为 Clang LLVM Trunk（不进行第1步中 hack Xcode 操作的话是不会有这个选项的）</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/698554-4ad812d07429b0e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Complier.png\"></p>\n<p>然后修改 OTHER_CFLAGS 选项：<br><img src=\"https://upload-images.jianshu.io/upload_images/698554-e50bcd49a7356985.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"OTHER_CFLAGS.png\"></p>\n   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-Xclang -load -Xclang /Users/Vernon/Desktop/MyPlugin.dylib -Xclang -add-plugin -Xclang MyPlugin</div></pre></td></tr></table></figure>\n<blockquote>\n<p>注意</p>\n<ol>\n<li>将 /Users/Vernon/Desktop/MyPlugin.dylib 修改为你生成的插件对应的目录</li>\n<li>如果编译中出现一大堆系统库的 symbol not found 错误的话，可以在上述命令的最后手动指定你的 SDK 目录：-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.2.sdk</li>\n</ol>\n</blockquote>\n<p>最后编译你的项目，然后快捷键 Command+9 跳到 Show the Report navigator，选中刚刚的编译报告，注意下图中每个文件右上角都有可以点击展开的按钮，展开后就能看到我们插件的输出了（下图4为对应输出）。Nice~<br><img src=\"https://upload-images.jianshu.io/upload_images/698554-de614d7d87c219d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"查看结果\"></p>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>文章不长，只是这看似简单的过程也花了我一个多星期的业余时间，写下这个系列文章一是为了记录自己这钻研的过程，以后也可查询，二是希望如果有人能看到这篇拙文可以省下一点时间，更快的踏进 LLVM 和 Clang 的世界探索。</p>\n<p>接下来会根据我的个人需求尝试给 Clang 添加自定义的 attribute，如果有所心得，会撰文分享，敬请期待~</p>\n"},{"title":"Clang 之旅—[翻译]添加自定义的 attribute","date":"2018-03-22T03:05:35.000Z","_content":"\n\n\nClang 之旅系列文章：\n[Clang 之旅--使用 Xcode 开发 Clang 插件](https://www.jianshu.com/p/e3f46d42643b)\n[Clang 之旅--[翻译]添加自定义的 attribute](https://www.jianshu.com/p/d277c42f4907)\n[Clang 之旅--实现一个自定义检查规范的 Clang 插件](https://www.jianshu.com/p/c27b77f70616)\n\n\n\n### 前言\n\n这是 Clang 之旅系列的第二篇，自己想要完成的需求是：在编译阶段检查某个方法的参数与返回值的类型相同，如果类型不一致的话能抛出编译错误的提示。需要接触到 Clang 中关于 attribute 处理的代码，所以这篇先来翻译[官方文档](https://clang.llvm.org/docs/InternalsManual.html#how-to-add-an-attribute)中添加自定义的 attribute 这一节，不得不说，虽然 Clang 的文档可以说是很标杆了，但是总有一种看了后面忘了前面的感觉，可能是 Clang 比较庞大，涉及专有词汇比较多的原因，所以我会偏向意译多一点，试图用更加易懂的表达组织语言，也是加深自己的记忆吧。\n\n\n\n## 怎样添加 attribute\n\nattribute 是一种可以附加到程序结构中的数据形式，允许开发人员传递信息给编译器来实现各种需求。例如，attribute 可以用来改变在程序构造时生成的代码，或者用来提供额外的信息给静态分析。本文档讲解如何添加一个自定义的 attribute 到 Clang 中。现有 attribute 列表的文档可以在[这里](https://clang.llvm.org/docs/AttributeReference.html)找到。\n\n\n\n### attribute 基础知识\n\nClang 中的 attribute 涉及到三个阶段：解析 attribute 、从已解析的 attribute 转换成语法树上的 attribute、对 attribute 进行处理。\n\nattribute 的解析可以采用多种语法形式，例如 GNU、C++ 11 和 Microsoft 形式，还由 attribute 提供的其他信息来确定。最终，解析好的 attribute 用一个 `AttributeList` 对象来表示。这些解析好的 attribute 会链成一个 attribute 链，加到声明或者定义上。attribtue 的解析是由 Clang 自动完成的，除了那些关键字 attribute。关键字的解析和 `AttributeList` 对象的生成必须由我们手动完成。\n\n最后，`Sema::ProcessDeclAttributeList()` 带着 `Decl` 类型和 `AttributeList` 类型的参数被调用，此时解析好的 attribute 就会被转化成语法树上的 attribute。这个处理依赖于 attribute 的属性定义和语义要求。最后的结果就是语法树上的 attribute 对象可以从 `Decl` 对象获取到，也就是通过调用 `Decl::getAttr<T>()` 来获取。\n\n语法树上的 attribute 的结构同样也受到 Attr.td 文件中的定义所限制。这个定义会自动生成 attribute 的实现所用到的功能，包括生成 `clang::Attr` 的子类、解析器所用到的信息和某些 attribute 自动进行的语义分析等等。\n\n\n\n### include/clang/Basic/Attr.td\n\n添加新的 attribute 到 Clang 的第一个步骤就是把其定义添加到 [include/clang/Basic/Attr.td](http://llvm.org/viewvc/llvm-project/cfe/trunk/include/clang/Basic/Attr.td?view=markup)。这个定义必须从 `Attr` 或者其子类继承。大多数 attribute 会直接从 `InheritableAttr` 继承，`InheritableAttr` 指定了这个 attribute 可以通过它所关联的 `Decl` 稍后进行重声明。如果这个 attribute 是作用于类型而不是声明，那么这种 attribute 应该从 `TypeAttr` 派生，并且通常不会被赋予 AST 表示（注意本文档并不讲解生成类型所用的 attribute）。一个继承于 `IgnoredAttr` 的 attribute 会被解析，但是会在被使用的时候产生一个 \"被忽略的属性\" 的警告，这种处理方法在某个属性支持别的前端而不支持 Clang 的情况下是很有用的。\n\n这个定义能指定 attribute 的一些关键部分，比如 attribute 的名字、attribute 支持的拼写、attribute 的参数等等。`Attr` 类型中的大多数成员变量都不需要派生定义，缺省的就足够了。但是，每个 attribute 都需要至少指定 拼写列表、subject 列表和文档列表。\n\n\n\n##### 拼写\n\n所有 attribute 都需要指定一个拼写列表，表示拼写 attribute 的方式。比如某个 attribute 可能会包含关键字拼写， C++11 拼写和 GNU 拼写。空的拼写列表也是允许的并且可能对隐式创建的 attribute 有用。以下是支持的拼写的表格：\n\n| 拼写     | 描述                                                         |\n| :------- | :----------------------------------------------------------- |\n| GNU      | 用 GNU 风格 `__attribute__((attr))` 语法和位置拼写           |\n| CXX11    | 用 C++ 风格 `[[attr]]` 语法拼写。如果该 attribute 是由 Clang 所使用的，那么应该设置命名空间为 `\"clang\"` |\n| Declspec | 用 Microsoft 风格 ` __declspec(attr)` 语法拼写               |\n| Keyword  | 这个 attribute 用关键字的方式拼写，并且需要自定义解析        |\n| GCC      | 指定两种拼写：首先是 GNU 风格拼写；然后是 C++ 风格拼写，命名空间为 `gnu`。只能为支持 GCC 的 attribute 指定这个拼写。 |\n| Pragma   | attribute 用 `#pragma` 的形式拼写，并且需要在预处理器中执行自定义的处理。如果该 attribute 是由 Clang 所使用的，那么应该设置命名空间为 `\"clang\"`。需要注意这个拼写并不能被用于声明语句中。 |\n\n\n\n##### Subjects\n\n每个 attribute 都有一个或者多个 subject。如果 attribute 被使用到了一个不在 subject 列表上的 subject，就会自动显示诊断信息。 这个信息是警告还是错误是由 attribute 中的 `SubjectList` 决定的，默认的是警告。显示给用户的诊断信息将根据 subject 列表自动确定，但是也可以在 `SubjectList` 中指定自定义诊断参数。不符合 subject 列表导致的诊断信息要么是 `diag::warn_attribute_wrong_decl_type`，要么是 `diag::err_attribute_wrong_decl_type`。具体参数的枚举值可以从 [include/clang/Sema/AttributeList.h](http://llvm.org/viewvc/llvm-project/cfe/trunk/include/clang/Sema/AttributeList.h?view=markup) 找到。如果先前未使用的 `Decl` 节点被添加到 `SubjectList` 中，则可能需要更新用于自动确定 [utils/TableGen/ClangAttrEmitter.cpp](http://llvm.org/viewvc/llvm-project/cfe/trunk/utils/TableGen/ClangAttrEmitter.cpp?view=markup) 中的诊断参数的逻辑。\n\n所有在 SubjectList 中的 subject 要么是在 `DeclNodes.td` 中定义的 Decl 节点，要么就是在 `StmtNodes.td` 中定义的 statement 节点。不过，可以生成 `SubsetSubject` 对象来创建更加复杂的 subject。每个这样的对象都有一个它所属的基本对象（必须是一个 Decl 或 Stmt 节点，而不是一个 SubsetSubject 节点），还有一些自定义代码在确定某个 attribute 是否属于该对象时被调用。例如，一个 `NonBitField` SubsetSubject 关联到 `FieldDecl` 类，同时会测试给定的 FieldDecl 是否是一个位字段。当在 SubjectList 中指定了一个 SubsetSubject 时必须同时提供一个自定义的诊断信息参数。\n\nattribute 的 subject 列表会在 `HasCustomParsing` 设为 `1` 的情况下自动进行诊断检查。\n\n\n\n##### 文档\n\n所有的 attribute 都必须具有某种形式的文档。文档是通过每天运行的服务器端进程在公共服务器上生成的。通常来说，attribute 的文档是在 [include/clang/Basic/AttrDocs.td](http://llvm.org/viewvc/llvm-project/cfe/trunk/include/clang/Basic/AttdDocs.td?view=markup) 中单独定义的，以文档属性命名。\n\n如果 attribute 不是通用的，或者是隐式创建的没有对应拼写的 attribuet，则可以将文档列表变量设置为 `Undocumented`。否则，该 attribute 应将其文档添加到 AttrDocs.td。\n\n文档属性是从 `Documentation` tablegen 类型继承而来的，所有的派生类型都必须创建一个文档类别和设置文档本身内容。此外，它还可以为 attribute 指定一个自定义的标题，否则会选择默认的标题。\n\n现在有四种预先定义好的文档类别：`DocCatFunction` 对应函数的 attribute，`DocCatVariable` 对应到变量的 attribute，`DocCatType` 对应类型的 attribute，`DocCatStmt` 对应声明的 attribute。自定义文档类别应该用于具有类似功能的 attribute 组。自定义类别非常适合用来为组中的 attribute 提供概述信息。\n\n文档内容（包括 attribute 的内容或者类别的内容）是用 reStructuredText（RST）格式写的。\n\n在编写该 attribute 的文档之后，应该对其在本地对其进行测试，以确保在服务器上生成文档不会有问题。本地测试需要重新构建 clang-tblgen。要生成 attribute 文档，请执行以下命令：\n\n```\nclang-tblgen -gen-attr-docs -I /path/to/clang/include /path/to/clang/include/clang/Basic/Attr.td -o /path/to/clang/docs/AttributeReference.rst\n```\n\n在本地进行测试时，不要对 `AttributeReference.rst` 提交更改。该文件是由服务器自动生成的，并且对该文件所做的任何更改都将被覆盖。\n\n\n\n##### 参数\n\nattribute 可以选择指定可以传递给 attribute 的参数列表。attribute 的参数指定 attribute 的解析形式和语义形式。例如，如果 `Args` 是 `[StringArgument<\"Arg1\">, IntArgument<\"Arg2\">]`，那么 `__attribute__((myattribute(\"Hello\", 3)))` 就是一个合法的使用方式；这个 attribute 在解析时要求有两个参数：一个 string 类型一个 integer 类型。\n\n每个参数都有个名字和一个用来指定这个参数是否为可选的标志。参数关联的 C++ 类型由参数定义类型确定。如果现有参数类型不足，则可以创建新类型，但需要修改 [utils/TableGen/ClangAttrEmitter.cpp](http://llvm.org/viewvc/llvm-project/cfe/trunk/utils/TableGen/ClangAttrEmitter.cpp?view=markup) 才能正确支持该新类型。\n\n\n\n##### 其他属性\n\n`Attr` 的定义还具有其他变量来控制 attribute 的行为。其中有很多是用于特殊用途的，超出了本文档的范围，但有一些还是值得提上一嘴的。\n\n如果 attribute 的解析形式更加复杂或者和语义形式不同，则可以将 `HasCustomParsing` 变量设置为 `1`，并且可以针对特殊情况修改 [Parser::ParseGNUAttributeArgs()](http://llvm.org/viewvc/llvm-project/cfe/trunk/lib/Parse/ParseDecl.cpp?view=markup) 中的解析代码。请注意，这仅适用于具有 GNU 拼写的 attribute；__declspec 拼写的 attribute 现在是忽略这个标志的，并由 `Parser::ParseMicrosoftDeclSpec`  负责解析。 \n\n请注意，把 `HasCustomParsing` 设置为 `1` 将不再使用通用的 attribute 处理逻辑，需要额外的处理来确保该  attribute 能使用。\n\n如果该 attribute 不通过模板声明实例化，则将 `Clone` 成员变量设置为 0。默认情况下，所有的 attribute 都将通过模板进行实例化。\n\n不需要 AST 节点的 attribute 应该将 `ASTNode` 变量设置为 0 以避免污染 AST。请注意，从 `TypeAttr` 或 `IgnoredAttr` 继承的类都不会自动生成 AST 节点。所有其他属性默认会生成一个 AST 节点。该 AST 节点是 attribute 的语义表示。\n\n`LangOpts` 变量指定了 attribute 所需的语言选项列表。例如，所有的 CUDA-specific 的 attribuet 都将 `LangOpts` 字段指定为 `[CUDA]`，并且当 CUDA 语言选项未启用时，会发出“attribute ignored”的警告诊断。由于语言选项不是自动生成的节点，因此必须手动创建新的语言选项，并应指定 `LangOptions` 类所使用的拼写。\n\n可以基于 attribute 的拼写列表为该 attribute 生成自定义的存取器。例如，如果某个 attribute 有两种不同的拼写：'foo' 和 'bar'，则可以创建访问器：`[Accessor<\"isFoo\", [GNU<\"Foo\">]>, Accessor<\"isBar\",[GNU<\"Bar\">]>]`。这些存取器将在该 attribute 的语义形式上生成，不接受任何参数并返回一个布尔值。\n\n不需要自定义语义分析的 attribute 应该将 `SemaHandler` 变量设为 `0`。请注意，任何从 `IgnoredAttr` 继承的 attribute 都不会自动进行语义处理。所有其他 attribute 都使用默认的语义处理。没有语义处理的 attribute 都不会有解析好的 attribute `Kind` 枚举器。\n\n指定 Target 的 attribute 可能会与不同 Target 的 attribute 共用一个拼写。例如，ARM 和 msp430 Target 都有一个拼写为 `GNU<\"interrupt\">` 的 attribute，但各自有不同的解析方式和语义要求。为了支持这个特性，继承自 `TargetSpecificAttribute` 的 attribute 可以指定 `ParseKind` 变量。这个变量在共用拼写的所有参数之间应该是相同的，并且对应于解析 attribute 的 `Kind` 的枚举器。这允许 attribute 共用一种解析类型，但具有不同的语义属性。例如，`AttributeList::AT_Interrupt` 是共用的解析类型，但 ARMInterruptAttr 和 MSP430InterruptAttr 是各自的语义属性。\n\n默认情况下，当声明为 merging attribute 时，该 attributes 不会被复制。但是，如果在此合并阶段中可以复制某个 attribute，那么将 `DuplicatesAllowedWhileMerging` 变量设置为 `1`，该 attribute 就会被合并。\n\n默认情况下，attribute 的参数在上下文中被解析。如果应该在上下文中解析 attribute 的参数（类似于解析 `sizeof` 表达式的参数的方式），请将 `ParseArgumentsAsUnevaluated` 设置为 `1`。\n\n\n\n### 样板代码\n\n声明 attribute 的所有的语义处理都在文件 [lib/Sema/SemaDeclAttr.cpp](http://llvm.org/viewvc/llvm-project/cfe/trunk/lib/Sema/SemaDeclAttr.cpp?view=markup) 中，并且通常都从 `ProcessDeclAttribute()` 函数开始。如果这个 attribute 是一个“简单的” attribute，也就是说这个 attribute 除了自动生成的内容之外不需要自定义的语义处理，那么就添加 `handleSimpleAttribute<YourAttr>(S, D, Attr);` 函数到 switch 语句中。否则，编写一个新的 `handleYourAttr()` 函数，并将其添加到 switch 语句中。不要直接在 `case` 语句中实现处理逻辑。\n\n除非 attribute 的定义中另有规定，否则将自动处理解析 attribute 的常见语义检查，包括诊断不属于给定 `Decl` 的解析的 attribute、确保传递正确的最小数量的参数等等。\n\n如果 attribute 要加上额外的警告，那么在 [include/clang/Basic/DiagnosticGroups.td](http://llvm.org/viewvc/llvm-project/cfe/trunk/include/clang/Basic/DiagnosticGroups.td?view=markup) 文件中定义一个 `DiagGroup`。如果只有一个诊断信息的话，直接在 [DiagnosticSemaKinds.td](http://llvm.org/viewvc/llvm-project/cfe/trunk/include/clang/Basic/DiagnosticSemaKinds.td?view=markup) 文件中使用 `InGroup<DiagGroup<\"your-attribute\">>` 也是可以的。\n\n所有为你自定义的 attribute 所生成的诊断信息，包括自动生成的（比如 subject 和参数个数），都应该有一个对应的测试用例。\n\n\n\n### 语义处理\n\n大多数 attribute 被实现为对编译器有一定的影响。例如，修改生成代码的方式，或为分析过程添加额外的语义检查等，将 attribute 的定义和转换添加到该 attribute 的语义表示中，剩下的就是实现 attribute 的自定义逻辑。\n\n可以使用 `hasAttr<T>()` 方法来查询 `clang::Decl` 对象中是否有 attribute。可以使用 `getAttr<T>` 来获取一个指向 attribute 的指针。 \n\n","source":"_posts/Clang之旅-添加自定义的attribute.md","raw":"---\ntitle: Clang 之旅—[翻译]添加自定义的 attribute\ndate: 2018-03-22 11:05:35\ntags: \n- iOS\n- clang & llvm\ncategories:\n- ruanpapa--技术贴\n---\n\n\n\nClang 之旅系列文章：\n[Clang 之旅--使用 Xcode 开发 Clang 插件](https://www.jianshu.com/p/e3f46d42643b)\n[Clang 之旅--[翻译]添加自定义的 attribute](https://www.jianshu.com/p/d277c42f4907)\n[Clang 之旅--实现一个自定义检查规范的 Clang 插件](https://www.jianshu.com/p/c27b77f70616)\n\n\n\n### 前言\n\n这是 Clang 之旅系列的第二篇，自己想要完成的需求是：在编译阶段检查某个方法的参数与返回值的类型相同，如果类型不一致的话能抛出编译错误的提示。需要接触到 Clang 中关于 attribute 处理的代码，所以这篇先来翻译[官方文档](https://clang.llvm.org/docs/InternalsManual.html#how-to-add-an-attribute)中添加自定义的 attribute 这一节，不得不说，虽然 Clang 的文档可以说是很标杆了，但是总有一种看了后面忘了前面的感觉，可能是 Clang 比较庞大，涉及专有词汇比较多的原因，所以我会偏向意译多一点，试图用更加易懂的表达组织语言，也是加深自己的记忆吧。\n\n\n\n## 怎样添加 attribute\n\nattribute 是一种可以附加到程序结构中的数据形式，允许开发人员传递信息给编译器来实现各种需求。例如，attribute 可以用来改变在程序构造时生成的代码，或者用来提供额外的信息给静态分析。本文档讲解如何添加一个自定义的 attribute 到 Clang 中。现有 attribute 列表的文档可以在[这里](https://clang.llvm.org/docs/AttributeReference.html)找到。\n\n\n\n### attribute 基础知识\n\nClang 中的 attribute 涉及到三个阶段：解析 attribute 、从已解析的 attribute 转换成语法树上的 attribute、对 attribute 进行处理。\n\nattribute 的解析可以采用多种语法形式，例如 GNU、C++ 11 和 Microsoft 形式，还由 attribute 提供的其他信息来确定。最终，解析好的 attribute 用一个 `AttributeList` 对象来表示。这些解析好的 attribute 会链成一个 attribute 链，加到声明或者定义上。attribtue 的解析是由 Clang 自动完成的，除了那些关键字 attribute。关键字的解析和 `AttributeList` 对象的生成必须由我们手动完成。\n\n最后，`Sema::ProcessDeclAttributeList()` 带着 `Decl` 类型和 `AttributeList` 类型的参数被调用，此时解析好的 attribute 就会被转化成语法树上的 attribute。这个处理依赖于 attribute 的属性定义和语义要求。最后的结果就是语法树上的 attribute 对象可以从 `Decl` 对象获取到，也就是通过调用 `Decl::getAttr<T>()` 来获取。\n\n语法树上的 attribute 的结构同样也受到 Attr.td 文件中的定义所限制。这个定义会自动生成 attribute 的实现所用到的功能，包括生成 `clang::Attr` 的子类、解析器所用到的信息和某些 attribute 自动进行的语义分析等等。\n\n\n\n### include/clang/Basic/Attr.td\n\n添加新的 attribute 到 Clang 的第一个步骤就是把其定义添加到 [include/clang/Basic/Attr.td](http://llvm.org/viewvc/llvm-project/cfe/trunk/include/clang/Basic/Attr.td?view=markup)。这个定义必须从 `Attr` 或者其子类继承。大多数 attribute 会直接从 `InheritableAttr` 继承，`InheritableAttr` 指定了这个 attribute 可以通过它所关联的 `Decl` 稍后进行重声明。如果这个 attribute 是作用于类型而不是声明，那么这种 attribute 应该从 `TypeAttr` 派生，并且通常不会被赋予 AST 表示（注意本文档并不讲解生成类型所用的 attribute）。一个继承于 `IgnoredAttr` 的 attribute 会被解析，但是会在被使用的时候产生一个 \"被忽略的属性\" 的警告，这种处理方法在某个属性支持别的前端而不支持 Clang 的情况下是很有用的。\n\n这个定义能指定 attribute 的一些关键部分，比如 attribute 的名字、attribute 支持的拼写、attribute 的参数等等。`Attr` 类型中的大多数成员变量都不需要派生定义，缺省的就足够了。但是，每个 attribute 都需要至少指定 拼写列表、subject 列表和文档列表。\n\n\n\n##### 拼写\n\n所有 attribute 都需要指定一个拼写列表，表示拼写 attribute 的方式。比如某个 attribute 可能会包含关键字拼写， C++11 拼写和 GNU 拼写。空的拼写列表也是允许的并且可能对隐式创建的 attribute 有用。以下是支持的拼写的表格：\n\n| 拼写     | 描述                                                         |\n| :------- | :----------------------------------------------------------- |\n| GNU      | 用 GNU 风格 `__attribute__((attr))` 语法和位置拼写           |\n| CXX11    | 用 C++ 风格 `[[attr]]` 语法拼写。如果该 attribute 是由 Clang 所使用的，那么应该设置命名空间为 `\"clang\"` |\n| Declspec | 用 Microsoft 风格 ` __declspec(attr)` 语法拼写               |\n| Keyword  | 这个 attribute 用关键字的方式拼写，并且需要自定义解析        |\n| GCC      | 指定两种拼写：首先是 GNU 风格拼写；然后是 C++ 风格拼写，命名空间为 `gnu`。只能为支持 GCC 的 attribute 指定这个拼写。 |\n| Pragma   | attribute 用 `#pragma` 的形式拼写，并且需要在预处理器中执行自定义的处理。如果该 attribute 是由 Clang 所使用的，那么应该设置命名空间为 `\"clang\"`。需要注意这个拼写并不能被用于声明语句中。 |\n\n\n\n##### Subjects\n\n每个 attribute 都有一个或者多个 subject。如果 attribute 被使用到了一个不在 subject 列表上的 subject，就会自动显示诊断信息。 这个信息是警告还是错误是由 attribute 中的 `SubjectList` 决定的，默认的是警告。显示给用户的诊断信息将根据 subject 列表自动确定，但是也可以在 `SubjectList` 中指定自定义诊断参数。不符合 subject 列表导致的诊断信息要么是 `diag::warn_attribute_wrong_decl_type`，要么是 `diag::err_attribute_wrong_decl_type`。具体参数的枚举值可以从 [include/clang/Sema/AttributeList.h](http://llvm.org/viewvc/llvm-project/cfe/trunk/include/clang/Sema/AttributeList.h?view=markup) 找到。如果先前未使用的 `Decl` 节点被添加到 `SubjectList` 中，则可能需要更新用于自动确定 [utils/TableGen/ClangAttrEmitter.cpp](http://llvm.org/viewvc/llvm-project/cfe/trunk/utils/TableGen/ClangAttrEmitter.cpp?view=markup) 中的诊断参数的逻辑。\n\n所有在 SubjectList 中的 subject 要么是在 `DeclNodes.td` 中定义的 Decl 节点，要么就是在 `StmtNodes.td` 中定义的 statement 节点。不过，可以生成 `SubsetSubject` 对象来创建更加复杂的 subject。每个这样的对象都有一个它所属的基本对象（必须是一个 Decl 或 Stmt 节点，而不是一个 SubsetSubject 节点），还有一些自定义代码在确定某个 attribute 是否属于该对象时被调用。例如，一个 `NonBitField` SubsetSubject 关联到 `FieldDecl` 类，同时会测试给定的 FieldDecl 是否是一个位字段。当在 SubjectList 中指定了一个 SubsetSubject 时必须同时提供一个自定义的诊断信息参数。\n\nattribute 的 subject 列表会在 `HasCustomParsing` 设为 `1` 的情况下自动进行诊断检查。\n\n\n\n##### 文档\n\n所有的 attribute 都必须具有某种形式的文档。文档是通过每天运行的服务器端进程在公共服务器上生成的。通常来说，attribute 的文档是在 [include/clang/Basic/AttrDocs.td](http://llvm.org/viewvc/llvm-project/cfe/trunk/include/clang/Basic/AttdDocs.td?view=markup) 中单独定义的，以文档属性命名。\n\n如果 attribute 不是通用的，或者是隐式创建的没有对应拼写的 attribuet，则可以将文档列表变量设置为 `Undocumented`。否则，该 attribute 应将其文档添加到 AttrDocs.td。\n\n文档属性是从 `Documentation` tablegen 类型继承而来的，所有的派生类型都必须创建一个文档类别和设置文档本身内容。此外，它还可以为 attribute 指定一个自定义的标题，否则会选择默认的标题。\n\n现在有四种预先定义好的文档类别：`DocCatFunction` 对应函数的 attribute，`DocCatVariable` 对应到变量的 attribute，`DocCatType` 对应类型的 attribute，`DocCatStmt` 对应声明的 attribute。自定义文档类别应该用于具有类似功能的 attribute 组。自定义类别非常适合用来为组中的 attribute 提供概述信息。\n\n文档内容（包括 attribute 的内容或者类别的内容）是用 reStructuredText（RST）格式写的。\n\n在编写该 attribute 的文档之后，应该对其在本地对其进行测试，以确保在服务器上生成文档不会有问题。本地测试需要重新构建 clang-tblgen。要生成 attribute 文档，请执行以下命令：\n\n```\nclang-tblgen -gen-attr-docs -I /path/to/clang/include /path/to/clang/include/clang/Basic/Attr.td -o /path/to/clang/docs/AttributeReference.rst\n```\n\n在本地进行测试时，不要对 `AttributeReference.rst` 提交更改。该文件是由服务器自动生成的，并且对该文件所做的任何更改都将被覆盖。\n\n\n\n##### 参数\n\nattribute 可以选择指定可以传递给 attribute 的参数列表。attribute 的参数指定 attribute 的解析形式和语义形式。例如，如果 `Args` 是 `[StringArgument<\"Arg1\">, IntArgument<\"Arg2\">]`，那么 `__attribute__((myattribute(\"Hello\", 3)))` 就是一个合法的使用方式；这个 attribute 在解析时要求有两个参数：一个 string 类型一个 integer 类型。\n\n每个参数都有个名字和一个用来指定这个参数是否为可选的标志。参数关联的 C++ 类型由参数定义类型确定。如果现有参数类型不足，则可以创建新类型，但需要修改 [utils/TableGen/ClangAttrEmitter.cpp](http://llvm.org/viewvc/llvm-project/cfe/trunk/utils/TableGen/ClangAttrEmitter.cpp?view=markup) 才能正确支持该新类型。\n\n\n\n##### 其他属性\n\n`Attr` 的定义还具有其他变量来控制 attribute 的行为。其中有很多是用于特殊用途的，超出了本文档的范围，但有一些还是值得提上一嘴的。\n\n如果 attribute 的解析形式更加复杂或者和语义形式不同，则可以将 `HasCustomParsing` 变量设置为 `1`，并且可以针对特殊情况修改 [Parser::ParseGNUAttributeArgs()](http://llvm.org/viewvc/llvm-project/cfe/trunk/lib/Parse/ParseDecl.cpp?view=markup) 中的解析代码。请注意，这仅适用于具有 GNU 拼写的 attribute；__declspec 拼写的 attribute 现在是忽略这个标志的，并由 `Parser::ParseMicrosoftDeclSpec`  负责解析。 \n\n请注意，把 `HasCustomParsing` 设置为 `1` 将不再使用通用的 attribute 处理逻辑，需要额外的处理来确保该  attribute 能使用。\n\n如果该 attribute 不通过模板声明实例化，则将 `Clone` 成员变量设置为 0。默认情况下，所有的 attribute 都将通过模板进行实例化。\n\n不需要 AST 节点的 attribute 应该将 `ASTNode` 变量设置为 0 以避免污染 AST。请注意，从 `TypeAttr` 或 `IgnoredAttr` 继承的类都不会自动生成 AST 节点。所有其他属性默认会生成一个 AST 节点。该 AST 节点是 attribute 的语义表示。\n\n`LangOpts` 变量指定了 attribute 所需的语言选项列表。例如，所有的 CUDA-specific 的 attribuet 都将 `LangOpts` 字段指定为 `[CUDA]`，并且当 CUDA 语言选项未启用时，会发出“attribute ignored”的警告诊断。由于语言选项不是自动生成的节点，因此必须手动创建新的语言选项，并应指定 `LangOptions` 类所使用的拼写。\n\n可以基于 attribute 的拼写列表为该 attribute 生成自定义的存取器。例如，如果某个 attribute 有两种不同的拼写：'foo' 和 'bar'，则可以创建访问器：`[Accessor<\"isFoo\", [GNU<\"Foo\">]>, Accessor<\"isBar\",[GNU<\"Bar\">]>]`。这些存取器将在该 attribute 的语义形式上生成，不接受任何参数并返回一个布尔值。\n\n不需要自定义语义分析的 attribute 应该将 `SemaHandler` 变量设为 `0`。请注意，任何从 `IgnoredAttr` 继承的 attribute 都不会自动进行语义处理。所有其他 attribute 都使用默认的语义处理。没有语义处理的 attribute 都不会有解析好的 attribute `Kind` 枚举器。\n\n指定 Target 的 attribute 可能会与不同 Target 的 attribute 共用一个拼写。例如，ARM 和 msp430 Target 都有一个拼写为 `GNU<\"interrupt\">` 的 attribute，但各自有不同的解析方式和语义要求。为了支持这个特性，继承自 `TargetSpecificAttribute` 的 attribute 可以指定 `ParseKind` 变量。这个变量在共用拼写的所有参数之间应该是相同的，并且对应于解析 attribute 的 `Kind` 的枚举器。这允许 attribute 共用一种解析类型，但具有不同的语义属性。例如，`AttributeList::AT_Interrupt` 是共用的解析类型，但 ARMInterruptAttr 和 MSP430InterruptAttr 是各自的语义属性。\n\n默认情况下，当声明为 merging attribute 时，该 attributes 不会被复制。但是，如果在此合并阶段中可以复制某个 attribute，那么将 `DuplicatesAllowedWhileMerging` 变量设置为 `1`，该 attribute 就会被合并。\n\n默认情况下，attribute 的参数在上下文中被解析。如果应该在上下文中解析 attribute 的参数（类似于解析 `sizeof` 表达式的参数的方式），请将 `ParseArgumentsAsUnevaluated` 设置为 `1`。\n\n\n\n### 样板代码\n\n声明 attribute 的所有的语义处理都在文件 [lib/Sema/SemaDeclAttr.cpp](http://llvm.org/viewvc/llvm-project/cfe/trunk/lib/Sema/SemaDeclAttr.cpp?view=markup) 中，并且通常都从 `ProcessDeclAttribute()` 函数开始。如果这个 attribute 是一个“简单的” attribute，也就是说这个 attribute 除了自动生成的内容之外不需要自定义的语义处理，那么就添加 `handleSimpleAttribute<YourAttr>(S, D, Attr);` 函数到 switch 语句中。否则，编写一个新的 `handleYourAttr()` 函数，并将其添加到 switch 语句中。不要直接在 `case` 语句中实现处理逻辑。\n\n除非 attribute 的定义中另有规定，否则将自动处理解析 attribute 的常见语义检查，包括诊断不属于给定 `Decl` 的解析的 attribute、确保传递正确的最小数量的参数等等。\n\n如果 attribute 要加上额外的警告，那么在 [include/clang/Basic/DiagnosticGroups.td](http://llvm.org/viewvc/llvm-project/cfe/trunk/include/clang/Basic/DiagnosticGroups.td?view=markup) 文件中定义一个 `DiagGroup`。如果只有一个诊断信息的话，直接在 [DiagnosticSemaKinds.td](http://llvm.org/viewvc/llvm-project/cfe/trunk/include/clang/Basic/DiagnosticSemaKinds.td?view=markup) 文件中使用 `InGroup<DiagGroup<\"your-attribute\">>` 也是可以的。\n\n所有为你自定义的 attribute 所生成的诊断信息，包括自动生成的（比如 subject 和参数个数），都应该有一个对应的测试用例。\n\n\n\n### 语义处理\n\n大多数 attribute 被实现为对编译器有一定的影响。例如，修改生成代码的方式，或为分析过程添加额外的语义检查等，将 attribute 的定义和转换添加到该 attribute 的语义表示中，剩下的就是实现 attribute 的自定义逻辑。\n\n可以使用 `hasAttr<T>()` 方法来查询 `clang::Decl` 对象中是否有 attribute。可以使用 `getAttr<T>` 来获取一个指向 attribute 的指针。 \n\n","slug":"Clang之旅-添加自定义的attribute","published":1,"updated":"2018-04-18T03:23:04.372Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg4j8vyd0006vfwx9erdsspm","content":"<p>Clang 之旅系列文章：<br><a href=\"https://www.jianshu.com/p/e3f46d42643b\" target=\"_blank\" rel=\"external\">Clang 之旅–使用 Xcode 开发 Clang 插件</a><br><a href=\"https://www.jianshu.com/p/d277c42f4907\" target=\"_blank\" rel=\"external\">Clang 之旅–[翻译]添加自定义的 attribute</a><br><a href=\"https://www.jianshu.com/p/c27b77f70616\" target=\"_blank\" rel=\"external\">Clang 之旅–实现一个自定义检查规范的 Clang 插件</a></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>这是 Clang 之旅系列的第二篇，自己想要完成的需求是：在编译阶段检查某个方法的参数与返回值的类型相同，如果类型不一致的话能抛出编译错误的提示。需要接触到 Clang 中关于 attribute 处理的代码，所以这篇先来翻译<a href=\"https://clang.llvm.org/docs/InternalsManual.html#how-to-add-an-attribute\" target=\"_blank\" rel=\"external\">官方文档</a>中添加自定义的 attribute 这一节，不得不说，虽然 Clang 的文档可以说是很标杆了，但是总有一种看了后面忘了前面的感觉，可能是 Clang 比较庞大，涉及专有词汇比较多的原因，所以我会偏向意译多一点，试图用更加易懂的表达组织语言，也是加深自己的记忆吧。</p>\n<h2 id=\"怎样添加-attribute\"><a href=\"#怎样添加-attribute\" class=\"headerlink\" title=\"怎样添加 attribute\"></a>怎样添加 attribute</h2><p>attribute 是一种可以附加到程序结构中的数据形式，允许开发人员传递信息给编译器来实现各种需求。例如，attribute 可以用来改变在程序构造时生成的代码，或者用来提供额外的信息给静态分析。本文档讲解如何添加一个自定义的 attribute 到 Clang 中。现有 attribute 列表的文档可以在<a href=\"https://clang.llvm.org/docs/AttributeReference.html\" target=\"_blank\" rel=\"external\">这里</a>找到。</p>\n<h3 id=\"attribute-基础知识\"><a href=\"#attribute-基础知识\" class=\"headerlink\" title=\"attribute 基础知识\"></a>attribute 基础知识</h3><p>Clang 中的 attribute 涉及到三个阶段：解析 attribute 、从已解析的 attribute 转换成语法树上的 attribute、对 attribute 进行处理。</p>\n<p>attribute 的解析可以采用多种语法形式，例如 GNU、C++ 11 和 Microsoft 形式，还由 attribute 提供的其他信息来确定。最终，解析好的 attribute 用一个 <code>AttributeList</code> 对象来表示。这些解析好的 attribute 会链成一个 attribute 链，加到声明或者定义上。attribtue 的解析是由 Clang 自动完成的，除了那些关键字 attribute。关键字的解析和 <code>AttributeList</code> 对象的生成必须由我们手动完成。</p>\n<p>最后，<code>Sema::ProcessDeclAttributeList()</code> 带着 <code>Decl</code> 类型和 <code>AttributeList</code> 类型的参数被调用，此时解析好的 attribute 就会被转化成语法树上的 attribute。这个处理依赖于 attribute 的属性定义和语义要求。最后的结果就是语法树上的 attribute 对象可以从 <code>Decl</code> 对象获取到，也就是通过调用 <code>Decl::getAttr&lt;T&gt;()</code> 来获取。</p>\n<p>语法树上的 attribute 的结构同样也受到 Attr.td 文件中的定义所限制。这个定义会自动生成 attribute 的实现所用到的功能，包括生成 <code>clang::Attr</code> 的子类、解析器所用到的信息和某些 attribute 自动进行的语义分析等等。</p>\n<h3 id=\"include-clang-Basic-Attr-td\"><a href=\"#include-clang-Basic-Attr-td\" class=\"headerlink\" title=\"include/clang/Basic/Attr.td\"></a>include/clang/Basic/Attr.td</h3><p>添加新的 attribute 到 Clang 的第一个步骤就是把其定义添加到 <a href=\"http://llvm.org/viewvc/llvm-project/cfe/trunk/include/clang/Basic/Attr.td?view=markup\" target=\"_blank\" rel=\"external\">include/clang/Basic/Attr.td</a>。这个定义必须从 <code>Attr</code> 或者其子类继承。大多数 attribute 会直接从 <code>InheritableAttr</code> 继承，<code>InheritableAttr</code> 指定了这个 attribute 可以通过它所关联的 <code>Decl</code> 稍后进行重声明。如果这个 attribute 是作用于类型而不是声明，那么这种 attribute 应该从 <code>TypeAttr</code> 派生，并且通常不会被赋予 AST 表示（注意本文档并不讲解生成类型所用的 attribute）。一个继承于 <code>IgnoredAttr</code> 的 attribute 会被解析，但是会在被使用的时候产生一个 “被忽略的属性” 的警告，这种处理方法在某个属性支持别的前端而不支持 Clang 的情况下是很有用的。</p>\n<p>这个定义能指定 attribute 的一些关键部分，比如 attribute 的名字、attribute 支持的拼写、attribute 的参数等等。<code>Attr</code> 类型中的大多数成员变量都不需要派生定义，缺省的就足够了。但是，每个 attribute 都需要至少指定 拼写列表、subject 列表和文档列表。</p>\n<h5 id=\"拼写\"><a href=\"#拼写\" class=\"headerlink\" title=\"拼写\"></a>拼写</h5><p>所有 attribute 都需要指定一个拼写列表，表示拼写 attribute 的方式。比如某个 attribute 可能会包含关键字拼写， C++11 拼写和 GNU 拼写。空的拼写列表也是允许的并且可能对隐式创建的 attribute 有用。以下是支持的拼写的表格：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">拼写</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">GNU</td>\n<td style=\"text-align:left\">用 GNU 风格 <code>__attribute__((attr))</code> 语法和位置拼写</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CXX11</td>\n<td style=\"text-align:left\">用 C++ 风格 <code>[[attr]]</code> 语法拼写。如果该 attribute 是由 Clang 所使用的，那么应该设置命名空间为 <code>&quot;clang&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Declspec</td>\n<td style=\"text-align:left\">用 Microsoft 风格 <code>__declspec(attr)</code> 语法拼写</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Keyword</td>\n<td style=\"text-align:left\">这个 attribute 用关键字的方式拼写，并且需要自定义解析</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">GCC</td>\n<td style=\"text-align:left\">指定两种拼写：首先是 GNU 风格拼写；然后是 C++ 风格拼写，命名空间为 <code>gnu</code>。只能为支持 GCC 的 attribute 指定这个拼写。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Pragma</td>\n<td style=\"text-align:left\">attribute 用 <code>#pragma</code> 的形式拼写，并且需要在预处理器中执行自定义的处理。如果该 attribute 是由 Clang 所使用的，那么应该设置命名空间为 <code>&quot;clang&quot;</code>。需要注意这个拼写并不能被用于声明语句中。</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"Subjects\"><a href=\"#Subjects\" class=\"headerlink\" title=\"Subjects\"></a>Subjects</h5><p>每个 attribute 都有一个或者多个 subject。如果 attribute 被使用到了一个不在 subject 列表上的 subject，就会自动显示诊断信息。 这个信息是警告还是错误是由 attribute 中的 <code>SubjectList</code> 决定的，默认的是警告。显示给用户的诊断信息将根据 subject 列表自动确定，但是也可以在 <code>SubjectList</code> 中指定自定义诊断参数。不符合 subject 列表导致的诊断信息要么是 <code>diag::warn_attribute_wrong_decl_type</code>，要么是 <code>diag::err_attribute_wrong_decl_type</code>。具体参数的枚举值可以从 <a href=\"http://llvm.org/viewvc/llvm-project/cfe/trunk/include/clang/Sema/AttributeList.h?view=markup\" target=\"_blank\" rel=\"external\">include/clang/Sema/AttributeList.h</a> 找到。如果先前未使用的 <code>Decl</code> 节点被添加到 <code>SubjectList</code> 中，则可能需要更新用于自动确定 <a href=\"http://llvm.org/viewvc/llvm-project/cfe/trunk/utils/TableGen/ClangAttrEmitter.cpp?view=markup\" target=\"_blank\" rel=\"external\">utils/TableGen/ClangAttrEmitter.cpp</a> 中的诊断参数的逻辑。</p>\n<p>所有在 SubjectList 中的 subject 要么是在 <code>DeclNodes.td</code> 中定义的 Decl 节点，要么就是在 <code>StmtNodes.td</code> 中定义的 statement 节点。不过，可以生成 <code>SubsetSubject</code> 对象来创建更加复杂的 subject。每个这样的对象都有一个它所属的基本对象（必须是一个 Decl 或 Stmt 节点，而不是一个 SubsetSubject 节点），还有一些自定义代码在确定某个 attribute 是否属于该对象时被调用。例如，一个 <code>NonBitField</code> SubsetSubject 关联到 <code>FieldDecl</code> 类，同时会测试给定的 FieldDecl 是否是一个位字段。当在 SubjectList 中指定了一个 SubsetSubject 时必须同时提供一个自定义的诊断信息参数。</p>\n<p>attribute 的 subject 列表会在 <code>HasCustomParsing</code> 设为 <code>1</code> 的情况下自动进行诊断检查。</p>\n<h5 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h5><p>所有的 attribute 都必须具有某种形式的文档。文档是通过每天运行的服务器端进程在公共服务器上生成的。通常来说，attribute 的文档是在 <a href=\"http://llvm.org/viewvc/llvm-project/cfe/trunk/include/clang/Basic/AttdDocs.td?view=markup\" target=\"_blank\" rel=\"external\">include/clang/Basic/AttrDocs.td</a> 中单独定义的，以文档属性命名。</p>\n<p>如果 attribute 不是通用的，或者是隐式创建的没有对应拼写的 attribuet，则可以将文档列表变量设置为 <code>Undocumented</code>。否则，该 attribute 应将其文档添加到 AttrDocs.td。</p>\n<p>文档属性是从 <code>Documentation</code> tablegen 类型继承而来的，所有的派生类型都必须创建一个文档类别和设置文档本身内容。此外，它还可以为 attribute 指定一个自定义的标题，否则会选择默认的标题。</p>\n<p>现在有四种预先定义好的文档类别：<code>DocCatFunction</code> 对应函数的 attribute，<code>DocCatVariable</code> 对应到变量的 attribute，<code>DocCatType</code> 对应类型的 attribute，<code>DocCatStmt</code> 对应声明的 attribute。自定义文档类别应该用于具有类似功能的 attribute 组。自定义类别非常适合用来为组中的 attribute 提供概述信息。</p>\n<p>文档内容（包括 attribute 的内容或者类别的内容）是用 reStructuredText（RST）格式写的。</p>\n<p>在编写该 attribute 的文档之后，应该对其在本地对其进行测试，以确保在服务器上生成文档不会有问题。本地测试需要重新构建 clang-tblgen。要生成 attribute 文档，请执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang-tblgen -gen-attr-docs -I /path/to/clang/include /path/to/clang/include/clang/Basic/Attr.td -o /path/to/clang/docs/AttributeReference.rst</div></pre></td></tr></table></figure>\n<p>在本地进行测试时，不要对 <code>AttributeReference.rst</code> 提交更改。该文件是由服务器自动生成的，并且对该文件所做的任何更改都将被覆盖。</p>\n<h5 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h5><p>attribute 可以选择指定可以传递给 attribute 的参数列表。attribute 的参数指定 attribute 的解析形式和语义形式。例如，如果 <code>Args</code> 是 <code>[StringArgument&lt;&quot;Arg1&quot;&gt;, IntArgument&lt;&quot;Arg2&quot;&gt;]</code>，那么 <code>__attribute__((myattribute(&quot;Hello&quot;, 3)))</code> 就是一个合法的使用方式；这个 attribute 在解析时要求有两个参数：一个 string 类型一个 integer 类型。</p>\n<p>每个参数都有个名字和一个用来指定这个参数是否为可选的标志。参数关联的 C++ 类型由参数定义类型确定。如果现有参数类型不足，则可以创建新类型，但需要修改 <a href=\"http://llvm.org/viewvc/llvm-project/cfe/trunk/utils/TableGen/ClangAttrEmitter.cpp?view=markup\" target=\"_blank\" rel=\"external\">utils/TableGen/ClangAttrEmitter.cpp</a> 才能正确支持该新类型。</p>\n<h5 id=\"其他属性\"><a href=\"#其他属性\" class=\"headerlink\" title=\"其他属性\"></a>其他属性</h5><p><code>Attr</code> 的定义还具有其他变量来控制 attribute 的行为。其中有很多是用于特殊用途的，超出了本文档的范围，但有一些还是值得提上一嘴的。</p>\n<p>如果 attribute 的解析形式更加复杂或者和语义形式不同，则可以将 <code>HasCustomParsing</code> 变量设置为 <code>1</code>，并且可以针对特殊情况修改 <a href=\"http://llvm.org/viewvc/llvm-project/cfe/trunk/lib/Parse/ParseDecl.cpp?view=markup\" target=\"_blank\" rel=\"external\">Parser::ParseGNUAttributeArgs()</a> 中的解析代码。请注意，这仅适用于具有 GNU 拼写的 attribute；__declspec 拼写的 attribute 现在是忽略这个标志的，并由 <code>Parser::ParseMicrosoftDeclSpec</code>  负责解析。 </p>\n<p>请注意，把 <code>HasCustomParsing</code> 设置为 <code>1</code> 将不再使用通用的 attribute 处理逻辑，需要额外的处理来确保该  attribute 能使用。</p>\n<p>如果该 attribute 不通过模板声明实例化，则将 <code>Clone</code> 成员变量设置为 0。默认情况下，所有的 attribute 都将通过模板进行实例化。</p>\n<p>不需要 AST 节点的 attribute 应该将 <code>ASTNode</code> 变量设置为 0 以避免污染 AST。请注意，从 <code>TypeAttr</code> 或 <code>IgnoredAttr</code> 继承的类都不会自动生成 AST 节点。所有其他属性默认会生成一个 AST 节点。该 AST 节点是 attribute 的语义表示。</p>\n<p><code>LangOpts</code> 变量指定了 attribute 所需的语言选项列表。例如，所有的 CUDA-specific 的 attribuet 都将 <code>LangOpts</code> 字段指定为 <code>[CUDA]</code>，并且当 CUDA 语言选项未启用时，会发出“attribute ignored”的警告诊断。由于语言选项不是自动生成的节点，因此必须手动创建新的语言选项，并应指定 <code>LangOptions</code> 类所使用的拼写。</p>\n<p>可以基于 attribute 的拼写列表为该 attribute 生成自定义的存取器。例如，如果某个 attribute 有两种不同的拼写：’foo’ 和 ‘bar’，则可以创建访问器：<code>[Accessor&lt;&quot;isFoo&quot;, [GNU&lt;&quot;Foo&quot;&gt;]&gt;, Accessor&lt;&quot;isBar&quot;,[GNU&lt;&quot;Bar&quot;&gt;]&gt;]</code>。这些存取器将在该 attribute 的语义形式上生成，不接受任何参数并返回一个布尔值。</p>\n<p>不需要自定义语义分析的 attribute 应该将 <code>SemaHandler</code> 变量设为 <code>0</code>。请注意，任何从 <code>IgnoredAttr</code> 继承的 attribute 都不会自动进行语义处理。所有其他 attribute 都使用默认的语义处理。没有语义处理的 attribute 都不会有解析好的 attribute <code>Kind</code> 枚举器。</p>\n<p>指定 Target 的 attribute 可能会与不同 Target 的 attribute 共用一个拼写。例如，ARM 和 msp430 Target 都有一个拼写为 <code>GNU&lt;&quot;interrupt&quot;&gt;</code> 的 attribute，但各自有不同的解析方式和语义要求。为了支持这个特性，继承自 <code>TargetSpecificAttribute</code> 的 attribute 可以指定 <code>ParseKind</code> 变量。这个变量在共用拼写的所有参数之间应该是相同的，并且对应于解析 attribute 的 <code>Kind</code> 的枚举器。这允许 attribute 共用一种解析类型，但具有不同的语义属性。例如，<code>AttributeList::AT_Interrupt</code> 是共用的解析类型，但 ARMInterruptAttr 和 MSP430InterruptAttr 是各自的语义属性。</p>\n<p>默认情况下，当声明为 merging attribute 时，该 attributes 不会被复制。但是，如果在此合并阶段中可以复制某个 attribute，那么将 <code>DuplicatesAllowedWhileMerging</code> 变量设置为 <code>1</code>，该 attribute 就会被合并。</p>\n<p>默认情况下，attribute 的参数在上下文中被解析。如果应该在上下文中解析 attribute 的参数（类似于解析 <code>sizeof</code> 表达式的参数的方式），请将 <code>ParseArgumentsAsUnevaluated</code> 设置为 <code>1</code>。</p>\n<h3 id=\"样板代码\"><a href=\"#样板代码\" class=\"headerlink\" title=\"样板代码\"></a>样板代码</h3><p>声明 attribute 的所有的语义处理都在文件 <a href=\"http://llvm.org/viewvc/llvm-project/cfe/trunk/lib/Sema/SemaDeclAttr.cpp?view=markup\" target=\"_blank\" rel=\"external\">lib/Sema/SemaDeclAttr.cpp</a> 中，并且通常都从 <code>ProcessDeclAttribute()</code> 函数开始。如果这个 attribute 是一个“简单的” attribute，也就是说这个 attribute 除了自动生成的内容之外不需要自定义的语义处理，那么就添加 <code>handleSimpleAttribute&lt;YourAttr&gt;(S, D, Attr);</code> 函数到 switch 语句中。否则，编写一个新的 <code>handleYourAttr()</code> 函数，并将其添加到 switch 语句中。不要直接在 <code>case</code> 语句中实现处理逻辑。</p>\n<p>除非 attribute 的定义中另有规定，否则将自动处理解析 attribute 的常见语义检查，包括诊断不属于给定 <code>Decl</code> 的解析的 attribute、确保传递正确的最小数量的参数等等。</p>\n<p>如果 attribute 要加上额外的警告，那么在 <a href=\"http://llvm.org/viewvc/llvm-project/cfe/trunk/include/clang/Basic/DiagnosticGroups.td?view=markup\" target=\"_blank\" rel=\"external\">include/clang/Basic/DiagnosticGroups.td</a> 文件中定义一个 <code>DiagGroup</code>。如果只有一个诊断信息的话，直接在 <a href=\"http://llvm.org/viewvc/llvm-project/cfe/trunk/include/clang/Basic/DiagnosticSemaKinds.td?view=markup\" target=\"_blank\" rel=\"external\">DiagnosticSemaKinds.td</a> 文件中使用 <code>InGroup&lt;DiagGroup&lt;&quot;your-attribute&quot;&gt;&gt;</code> 也是可以的。</p>\n<p>所有为你自定义的 attribute 所生成的诊断信息，包括自动生成的（比如 subject 和参数个数），都应该有一个对应的测试用例。</p>\n<h3 id=\"语义处理\"><a href=\"#语义处理\" class=\"headerlink\" title=\"语义处理\"></a>语义处理</h3><p>大多数 attribute 被实现为对编译器有一定的影响。例如，修改生成代码的方式，或为分析过程添加额外的语义检查等，将 attribute 的定义和转换添加到该 attribute 的语义表示中，剩下的就是实现 attribute 的自定义逻辑。</p>\n<p>可以使用 <code>hasAttr&lt;T&gt;()</code> 方法来查询 <code>clang::Decl</code> 对象中是否有 attribute。可以使用 <code>getAttr&lt;T&gt;</code> 来获取一个指向 attribute 的指针。 </p>\n","excerpt":"","more":"<p>Clang 之旅系列文章：<br><a href=\"https://www.jianshu.com/p/e3f46d42643b\">Clang 之旅–使用 Xcode 开发 Clang 插件</a><br><a href=\"https://www.jianshu.com/p/d277c42f4907\">Clang 之旅–[翻译]添加自定义的 attribute</a><br><a href=\"https://www.jianshu.com/p/c27b77f70616\">Clang 之旅–实现一个自定义检查规范的 Clang 插件</a></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>这是 Clang 之旅系列的第二篇，自己想要完成的需求是：在编译阶段检查某个方法的参数与返回值的类型相同，如果类型不一致的话能抛出编译错误的提示。需要接触到 Clang 中关于 attribute 处理的代码，所以这篇先来翻译<a href=\"https://clang.llvm.org/docs/InternalsManual.html#how-to-add-an-attribute\">官方文档</a>中添加自定义的 attribute 这一节，不得不说，虽然 Clang 的文档可以说是很标杆了，但是总有一种看了后面忘了前面的感觉，可能是 Clang 比较庞大，涉及专有词汇比较多的原因，所以我会偏向意译多一点，试图用更加易懂的表达组织语言，也是加深自己的记忆吧。</p>\n<h2 id=\"怎样添加-attribute\"><a href=\"#怎样添加-attribute\" class=\"headerlink\" title=\"怎样添加 attribute\"></a>怎样添加 attribute</h2><p>attribute 是一种可以附加到程序结构中的数据形式，允许开发人员传递信息给编译器来实现各种需求。例如，attribute 可以用来改变在程序构造时生成的代码，或者用来提供额外的信息给静态分析。本文档讲解如何添加一个自定义的 attribute 到 Clang 中。现有 attribute 列表的文档可以在<a href=\"https://clang.llvm.org/docs/AttributeReference.html\">这里</a>找到。</p>\n<h3 id=\"attribute-基础知识\"><a href=\"#attribute-基础知识\" class=\"headerlink\" title=\"attribute 基础知识\"></a>attribute 基础知识</h3><p>Clang 中的 attribute 涉及到三个阶段：解析 attribute 、从已解析的 attribute 转换成语法树上的 attribute、对 attribute 进行处理。</p>\n<p>attribute 的解析可以采用多种语法形式，例如 GNU、C++ 11 和 Microsoft 形式，还由 attribute 提供的其他信息来确定。最终，解析好的 attribute 用一个 <code>AttributeList</code> 对象来表示。这些解析好的 attribute 会链成一个 attribute 链，加到声明或者定义上。attribtue 的解析是由 Clang 自动完成的，除了那些关键字 attribute。关键字的解析和 <code>AttributeList</code> 对象的生成必须由我们手动完成。</p>\n<p>最后，<code>Sema::ProcessDeclAttributeList()</code> 带着 <code>Decl</code> 类型和 <code>AttributeList</code> 类型的参数被调用，此时解析好的 attribute 就会被转化成语法树上的 attribute。这个处理依赖于 attribute 的属性定义和语义要求。最后的结果就是语法树上的 attribute 对象可以从 <code>Decl</code> 对象获取到，也就是通过调用 <code>Decl::getAttr&lt;T&gt;()</code> 来获取。</p>\n<p>语法树上的 attribute 的结构同样也受到 Attr.td 文件中的定义所限制。这个定义会自动生成 attribute 的实现所用到的功能，包括生成 <code>clang::Attr</code> 的子类、解析器所用到的信息和某些 attribute 自动进行的语义分析等等。</p>\n<h3 id=\"include-clang-Basic-Attr-td\"><a href=\"#include-clang-Basic-Attr-td\" class=\"headerlink\" title=\"include/clang/Basic/Attr.td\"></a>include/clang/Basic/Attr.td</h3><p>添加新的 attribute 到 Clang 的第一个步骤就是把其定义添加到 <a href=\"http://llvm.org/viewvc/llvm-project/cfe/trunk/include/clang/Basic/Attr.td?view=markup\">include/clang/Basic/Attr.td</a>。这个定义必须从 <code>Attr</code> 或者其子类继承。大多数 attribute 会直接从 <code>InheritableAttr</code> 继承，<code>InheritableAttr</code> 指定了这个 attribute 可以通过它所关联的 <code>Decl</code> 稍后进行重声明。如果这个 attribute 是作用于类型而不是声明，那么这种 attribute 应该从 <code>TypeAttr</code> 派生，并且通常不会被赋予 AST 表示（注意本文档并不讲解生成类型所用的 attribute）。一个继承于 <code>IgnoredAttr</code> 的 attribute 会被解析，但是会在被使用的时候产生一个 “被忽略的属性” 的警告，这种处理方法在某个属性支持别的前端而不支持 Clang 的情况下是很有用的。</p>\n<p>这个定义能指定 attribute 的一些关键部分，比如 attribute 的名字、attribute 支持的拼写、attribute 的参数等等。<code>Attr</code> 类型中的大多数成员变量都不需要派生定义，缺省的就足够了。但是，每个 attribute 都需要至少指定 拼写列表、subject 列表和文档列表。</p>\n<h5 id=\"拼写\"><a href=\"#拼写\" class=\"headerlink\" title=\"拼写\"></a>拼写</h5><p>所有 attribute 都需要指定一个拼写列表，表示拼写 attribute 的方式。比如某个 attribute 可能会包含关键字拼写， C++11 拼写和 GNU 拼写。空的拼写列表也是允许的并且可能对隐式创建的 attribute 有用。以下是支持的拼写的表格：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">拼写</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">GNU</td>\n<td style=\"text-align:left\">用 GNU 风格 <code>__attribute__((attr))</code> 语法和位置拼写</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CXX11</td>\n<td style=\"text-align:left\">用 C++ 风格 <code>[[attr]]</code> 语法拼写。如果该 attribute 是由 Clang 所使用的，那么应该设置命名空间为 <code>&quot;clang&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Declspec</td>\n<td style=\"text-align:left\">用 Microsoft 风格 <code>__declspec(attr)</code> 语法拼写</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Keyword</td>\n<td style=\"text-align:left\">这个 attribute 用关键字的方式拼写，并且需要自定义解析</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">GCC</td>\n<td style=\"text-align:left\">指定两种拼写：首先是 GNU 风格拼写；然后是 C++ 风格拼写，命名空间为 <code>gnu</code>。只能为支持 GCC 的 attribute 指定这个拼写。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Pragma</td>\n<td style=\"text-align:left\">attribute 用 <code>#pragma</code> 的形式拼写，并且需要在预处理器中执行自定义的处理。如果该 attribute 是由 Clang 所使用的，那么应该设置命名空间为 <code>&quot;clang&quot;</code>。需要注意这个拼写并不能被用于声明语句中。</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"Subjects\"><a href=\"#Subjects\" class=\"headerlink\" title=\"Subjects\"></a>Subjects</h5><p>每个 attribute 都有一个或者多个 subject。如果 attribute 被使用到了一个不在 subject 列表上的 subject，就会自动显示诊断信息。 这个信息是警告还是错误是由 attribute 中的 <code>SubjectList</code> 决定的，默认的是警告。显示给用户的诊断信息将根据 subject 列表自动确定，但是也可以在 <code>SubjectList</code> 中指定自定义诊断参数。不符合 subject 列表导致的诊断信息要么是 <code>diag::warn_attribute_wrong_decl_type</code>，要么是 <code>diag::err_attribute_wrong_decl_type</code>。具体参数的枚举值可以从 <a href=\"http://llvm.org/viewvc/llvm-project/cfe/trunk/include/clang/Sema/AttributeList.h?view=markup\">include/clang/Sema/AttributeList.h</a> 找到。如果先前未使用的 <code>Decl</code> 节点被添加到 <code>SubjectList</code> 中，则可能需要更新用于自动确定 <a href=\"http://llvm.org/viewvc/llvm-project/cfe/trunk/utils/TableGen/ClangAttrEmitter.cpp?view=markup\">utils/TableGen/ClangAttrEmitter.cpp</a> 中的诊断参数的逻辑。</p>\n<p>所有在 SubjectList 中的 subject 要么是在 <code>DeclNodes.td</code> 中定义的 Decl 节点，要么就是在 <code>StmtNodes.td</code> 中定义的 statement 节点。不过，可以生成 <code>SubsetSubject</code> 对象来创建更加复杂的 subject。每个这样的对象都有一个它所属的基本对象（必须是一个 Decl 或 Stmt 节点，而不是一个 SubsetSubject 节点），还有一些自定义代码在确定某个 attribute 是否属于该对象时被调用。例如，一个 <code>NonBitField</code> SubsetSubject 关联到 <code>FieldDecl</code> 类，同时会测试给定的 FieldDecl 是否是一个位字段。当在 SubjectList 中指定了一个 SubsetSubject 时必须同时提供一个自定义的诊断信息参数。</p>\n<p>attribute 的 subject 列表会在 <code>HasCustomParsing</code> 设为 <code>1</code> 的情况下自动进行诊断检查。</p>\n<h5 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h5><p>所有的 attribute 都必须具有某种形式的文档。文档是通过每天运行的服务器端进程在公共服务器上生成的。通常来说，attribute 的文档是在 <a href=\"http://llvm.org/viewvc/llvm-project/cfe/trunk/include/clang/Basic/AttdDocs.td?view=markup\">include/clang/Basic/AttrDocs.td</a> 中单独定义的，以文档属性命名。</p>\n<p>如果 attribute 不是通用的，或者是隐式创建的没有对应拼写的 attribuet，则可以将文档列表变量设置为 <code>Undocumented</code>。否则，该 attribute 应将其文档添加到 AttrDocs.td。</p>\n<p>文档属性是从 <code>Documentation</code> tablegen 类型继承而来的，所有的派生类型都必须创建一个文档类别和设置文档本身内容。此外，它还可以为 attribute 指定一个自定义的标题，否则会选择默认的标题。</p>\n<p>现在有四种预先定义好的文档类别：<code>DocCatFunction</code> 对应函数的 attribute，<code>DocCatVariable</code> 对应到变量的 attribute，<code>DocCatType</code> 对应类型的 attribute，<code>DocCatStmt</code> 对应声明的 attribute。自定义文档类别应该用于具有类似功能的 attribute 组。自定义类别非常适合用来为组中的 attribute 提供概述信息。</p>\n<p>文档内容（包括 attribute 的内容或者类别的内容）是用 reStructuredText（RST）格式写的。</p>\n<p>在编写该 attribute 的文档之后，应该对其在本地对其进行测试，以确保在服务器上生成文档不会有问题。本地测试需要重新构建 clang-tblgen。要生成 attribute 文档，请执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang-tblgen -gen-attr-docs -I /path/to/clang/include /path/to/clang/include/clang/Basic/Attr.td -o /path/to/clang/docs/AttributeReference.rst</div></pre></td></tr></table></figure>\n<p>在本地进行测试时，不要对 <code>AttributeReference.rst</code> 提交更改。该文件是由服务器自动生成的，并且对该文件所做的任何更改都将被覆盖。</p>\n<h5 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h5><p>attribute 可以选择指定可以传递给 attribute 的参数列表。attribute 的参数指定 attribute 的解析形式和语义形式。例如，如果 <code>Args</code> 是 <code>[StringArgument&lt;&quot;Arg1&quot;&gt;, IntArgument&lt;&quot;Arg2&quot;&gt;]</code>，那么 <code>__attribute__((myattribute(&quot;Hello&quot;, 3)))</code> 就是一个合法的使用方式；这个 attribute 在解析时要求有两个参数：一个 string 类型一个 integer 类型。</p>\n<p>每个参数都有个名字和一个用来指定这个参数是否为可选的标志。参数关联的 C++ 类型由参数定义类型确定。如果现有参数类型不足，则可以创建新类型，但需要修改 <a href=\"http://llvm.org/viewvc/llvm-project/cfe/trunk/utils/TableGen/ClangAttrEmitter.cpp?view=markup\">utils/TableGen/ClangAttrEmitter.cpp</a> 才能正确支持该新类型。</p>\n<h5 id=\"其他属性\"><a href=\"#其他属性\" class=\"headerlink\" title=\"其他属性\"></a>其他属性</h5><p><code>Attr</code> 的定义还具有其他变量来控制 attribute 的行为。其中有很多是用于特殊用途的，超出了本文档的范围，但有一些还是值得提上一嘴的。</p>\n<p>如果 attribute 的解析形式更加复杂或者和语义形式不同，则可以将 <code>HasCustomParsing</code> 变量设置为 <code>1</code>，并且可以针对特殊情况修改 <a href=\"http://llvm.org/viewvc/llvm-project/cfe/trunk/lib/Parse/ParseDecl.cpp?view=markup\">Parser::ParseGNUAttributeArgs()</a> 中的解析代码。请注意，这仅适用于具有 GNU 拼写的 attribute；__declspec 拼写的 attribute 现在是忽略这个标志的，并由 <code>Parser::ParseMicrosoftDeclSpec</code>  负责解析。 </p>\n<p>请注意，把 <code>HasCustomParsing</code> 设置为 <code>1</code> 将不再使用通用的 attribute 处理逻辑，需要额外的处理来确保该  attribute 能使用。</p>\n<p>如果该 attribute 不通过模板声明实例化，则将 <code>Clone</code> 成员变量设置为 0。默认情况下，所有的 attribute 都将通过模板进行实例化。</p>\n<p>不需要 AST 节点的 attribute 应该将 <code>ASTNode</code> 变量设置为 0 以避免污染 AST。请注意，从 <code>TypeAttr</code> 或 <code>IgnoredAttr</code> 继承的类都不会自动生成 AST 节点。所有其他属性默认会生成一个 AST 节点。该 AST 节点是 attribute 的语义表示。</p>\n<p><code>LangOpts</code> 变量指定了 attribute 所需的语言选项列表。例如，所有的 CUDA-specific 的 attribuet 都将 <code>LangOpts</code> 字段指定为 <code>[CUDA]</code>，并且当 CUDA 语言选项未启用时，会发出“attribute ignored”的警告诊断。由于语言选项不是自动生成的节点，因此必须手动创建新的语言选项，并应指定 <code>LangOptions</code> 类所使用的拼写。</p>\n<p>可以基于 attribute 的拼写列表为该 attribute 生成自定义的存取器。例如，如果某个 attribute 有两种不同的拼写：’foo’ 和 ‘bar’，则可以创建访问器：<code>[Accessor&lt;&quot;isFoo&quot;, [GNU&lt;&quot;Foo&quot;&gt;]&gt;, Accessor&lt;&quot;isBar&quot;,[GNU&lt;&quot;Bar&quot;&gt;]&gt;]</code>。这些存取器将在该 attribute 的语义形式上生成，不接受任何参数并返回一个布尔值。</p>\n<p>不需要自定义语义分析的 attribute 应该将 <code>SemaHandler</code> 变量设为 <code>0</code>。请注意，任何从 <code>IgnoredAttr</code> 继承的 attribute 都不会自动进行语义处理。所有其他 attribute 都使用默认的语义处理。没有语义处理的 attribute 都不会有解析好的 attribute <code>Kind</code> 枚举器。</p>\n<p>指定 Target 的 attribute 可能会与不同 Target 的 attribute 共用一个拼写。例如，ARM 和 msp430 Target 都有一个拼写为 <code>GNU&lt;&quot;interrupt&quot;&gt;</code> 的 attribute，但各自有不同的解析方式和语义要求。为了支持这个特性，继承自 <code>TargetSpecificAttribute</code> 的 attribute 可以指定 <code>ParseKind</code> 变量。这个变量在共用拼写的所有参数之间应该是相同的，并且对应于解析 attribute 的 <code>Kind</code> 的枚举器。这允许 attribute 共用一种解析类型，但具有不同的语义属性。例如，<code>AttributeList::AT_Interrupt</code> 是共用的解析类型，但 ARMInterruptAttr 和 MSP430InterruptAttr 是各自的语义属性。</p>\n<p>默认情况下，当声明为 merging attribute 时，该 attributes 不会被复制。但是，如果在此合并阶段中可以复制某个 attribute，那么将 <code>DuplicatesAllowedWhileMerging</code> 变量设置为 <code>1</code>，该 attribute 就会被合并。</p>\n<p>默认情况下，attribute 的参数在上下文中被解析。如果应该在上下文中解析 attribute 的参数（类似于解析 <code>sizeof</code> 表达式的参数的方式），请将 <code>ParseArgumentsAsUnevaluated</code> 设置为 <code>1</code>。</p>\n<h3 id=\"样板代码\"><a href=\"#样板代码\" class=\"headerlink\" title=\"样板代码\"></a>样板代码</h3><p>声明 attribute 的所有的语义处理都在文件 <a href=\"http://llvm.org/viewvc/llvm-project/cfe/trunk/lib/Sema/SemaDeclAttr.cpp?view=markup\">lib/Sema/SemaDeclAttr.cpp</a> 中，并且通常都从 <code>ProcessDeclAttribute()</code> 函数开始。如果这个 attribute 是一个“简单的” attribute，也就是说这个 attribute 除了自动生成的内容之外不需要自定义的语义处理，那么就添加 <code>handleSimpleAttribute&lt;YourAttr&gt;(S, D, Attr);</code> 函数到 switch 语句中。否则，编写一个新的 <code>handleYourAttr()</code> 函数，并将其添加到 switch 语句中。不要直接在 <code>case</code> 语句中实现处理逻辑。</p>\n<p>除非 attribute 的定义中另有规定，否则将自动处理解析 attribute 的常见语义检查，包括诊断不属于给定 <code>Decl</code> 的解析的 attribute、确保传递正确的最小数量的参数等等。</p>\n<p>如果 attribute 要加上额外的警告，那么在 <a href=\"http://llvm.org/viewvc/llvm-project/cfe/trunk/include/clang/Basic/DiagnosticGroups.td?view=markup\">include/clang/Basic/DiagnosticGroups.td</a> 文件中定义一个 <code>DiagGroup</code>。如果只有一个诊断信息的话，直接在 <a href=\"http://llvm.org/viewvc/llvm-project/cfe/trunk/include/clang/Basic/DiagnosticSemaKinds.td?view=markup\">DiagnosticSemaKinds.td</a> 文件中使用 <code>InGroup&lt;DiagGroup&lt;&quot;your-attribute&quot;&gt;&gt;</code> 也是可以的。</p>\n<p>所有为你自定义的 attribute 所生成的诊断信息，包括自动生成的（比如 subject 和参数个数），都应该有一个对应的测试用例。</p>\n<h3 id=\"语义处理\"><a href=\"#语义处理\" class=\"headerlink\" title=\"语义处理\"></a>语义处理</h3><p>大多数 attribute 被实现为对编译器有一定的影响。例如，修改生成代码的方式，或为分析过程添加额外的语义检查等，将 attribute 的定义和转换添加到该 attribute 的语义表示中，剩下的就是实现 attribute 的自定义逻辑。</p>\n<p>可以使用 <code>hasAttr&lt;T&gt;()</code> 方法来查询 <code>clang::Decl</code> 对象中是否有 attribute。可以使用 <code>getAttr&lt;T&gt;</code> 来获取一个指向 attribute 的指针。 </p>\n"},{"title":"2017年终总结","date":"2017-12-30T06:13:29.000Z","_content":"\n\n\n这几天被“18岁”、“网易云音乐年度听歌报告”、“支付宝年度账单”各种刷屏，大家都玩的不亦乐乎，毕竟也是年底了，辛苦工作学习了一年了，也该是时候放松一下了。自己通常都不是太喜欢凑热闹的，偏安一隅，躲在自己的小角落，写下刚刚过去的2017年发生的大事小情，顺便展望一下明年。这也是我第一次提笔写下自己的年终总结，也希望自己以后都能坚持这件事情。\n\n\n\n## 工作\n\n过去的这一年，最先想说的还是工作上的事情，毕竟今年告别用了16年的学生身份。\n\n前半年一直是实习生身份，上下班都是步行回学校，完全没有觉得生活有发生什么变化。公司给了大量的时间自己学习与熟悉技术，所以上班并没有感到什么压力，下了班回去宿舍，打打球，这里溜达溜达，那里吹吹水，偶尔抽出时间处理论文、入党、毕业的事宜，一切如故。\n\n接下来顺利转了正，到现在也半年了，这半年是技术快速进步的一段时间，也开始接触比较复杂的需求。以前常常能在社区看到大家吐槽做业务的程序员是最底层的，我倒是不这么认为，我觉得凡事都需要循序渐进，不是每个人都能一入门就玩核心算法、深度学习、底层架构这些高深的东西的，相反，当前任何公司绝大部分的都是这些业务需求，做需求的能力扎实了，到哪里都不愁找不到工作。正如我在入职的职业规划上写的：希望自己在未来的一、两年内能尽量的做各种需求。\n\n但是只停留在术而不去钻研道的话，这样职业生涯也不会太长久，自己也在空余时间接触了一下clang+llvm、逆向工程等比较高深的技术，铩羽而归算不上，反正还没有什么实际产出，还需要的前期知识、铺垫比较多，我会慢慢补上。同时自己也一直对金融这一块比较有兴趣，平时经常驻足新浪财经、虎嗅等各种财经类的网站，尤其自己也是搞技术的，互联网+金融，完全是一片广阔的天地。\n\n\n\n## 生活\n\n今年最重要的是什么呢？那当然是，我收获了一个全世界最可爱的女朋友啦~\\(≧▽≦)/。1月10号初识，3月7号正式在一起，不知不觉竟然携手走过了快一年了。这一年里，有过很多个阶段。从各自试探，到互生好感，再到每天甜甜腻腻，再到现在更多了一份理性。期间有因为小事吵吵闹闹，也有三观的激烈碰撞，异地总是比较辛苦的，但是能经受的住异地的考验，那得来的才更加难能可贵。\n\n这一年也是我真正独立生活的第一年，很庆幸自己还是保持了一些良好的习惯，房间总是会打扫收拾，周末的时候会自己煮饭，平时会进行阅读学习，偶尔还会去跑步。不过跑步运动这一段时间真的是松懈了，总觉得跑起来动力不足，时常跑了没几公里就觉得够了，然后就停下了脚步，新的一年，还是希望自己能把运动的好习惯重拾起来。\n\n\n\n## 上一年定下的目标\n\n- 写**5**篇高质量的技术文章（完成度60%）：今年的产出只有3篇技术文章，实在是太少了，也是因为自己今年比较多私人事情，明年还是要更多的进行产出。不过今年倒是打理了自己的博客、掘金、简书等账号，更多的将自己的产出放到社交平台上互动，尤其是掘金，竟然已经有了2000个关注者了，但是自己心里清楚离大牛还有很远的距离，要多多努力了。\n- 开发并维护1个开源库（完成）：呃。。。看着Github上稀稀拉拉的contributions，实在拿不出手啊。\n- 翻译5篇技术文章 3/5（完成度60%）：[iOS的Core Text教程：制作一个杂志应用](https://vernonvan.github.io/2017/07/21/%E7%BF%BB%E8%AF%91%E6%9D%82%E5%BF%97%E5%BA%94%E7%94%A8/)、iPhone X 网页设计(校对)、[关于Swift的编译时间优化](https://vernonvan.github.io/2017/10/22/%E7%BF%BB%E8%AF%91%E5%85%B3%E4%BA%8ESwift%E7%9A%84%E7%BC%96%E8%AF%91%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96/)。\n- 看15本书（完成）（《南京大屠杀》、《激荡三十年》、《史蒂夫乔布斯传》、《穷查理宝典》、《100个Swift2开发必备Tip》、《亮剑》、《数学之美》、《浪潮之巅》、《欧神文集01》、《ASO优化道与术》、《在你身边，为你设计Ⅱ》、《腾讯传》、《欧神文集02》、《iOS应用逆向工程》、《欧神文集03、04、05》）：今年的阅读还是达标的，有自己感兴趣的人物传记、历史等方面的书籍，也有一些是技术书籍、投资入门方面的一些书。\n- 开始接触理财与投资产品\n\n\n\n\n## 我想要的2018\n\n- 写6篇技术文章，并更多的在社区中互动。\n- 开发一个独立APP\n- 技术方面还是深耕iOS：逆向工程、图像处理，拓展方面的打算入门一下机器学习、区块链的基础知识\n- 看12本书，而且得保证看了的书都写一篇读后感，否则不能算上这本书。\n- 争取能做到Github的contributions能亮起来一半吧。。。\n\n\n\n\n\n\n\n","source":"_posts/2017年终总结.md","raw":"---\ntitle: 2017年终总结\ndate: 2017-12-30 14:13:29\ntags:\ncategories:\n- ruanpapa&又吉君的日常\n---\n\n\n\n这几天被“18岁”、“网易云音乐年度听歌报告”、“支付宝年度账单”各种刷屏，大家都玩的不亦乐乎，毕竟也是年底了，辛苦工作学习了一年了，也该是时候放松一下了。自己通常都不是太喜欢凑热闹的，偏安一隅，躲在自己的小角落，写下刚刚过去的2017年发生的大事小情，顺便展望一下明年。这也是我第一次提笔写下自己的年终总结，也希望自己以后都能坚持这件事情。\n\n\n\n## 工作\n\n过去的这一年，最先想说的还是工作上的事情，毕竟今年告别用了16年的学生身份。\n\n前半年一直是实习生身份，上下班都是步行回学校，完全没有觉得生活有发生什么变化。公司给了大量的时间自己学习与熟悉技术，所以上班并没有感到什么压力，下了班回去宿舍，打打球，这里溜达溜达，那里吹吹水，偶尔抽出时间处理论文、入党、毕业的事宜，一切如故。\n\n接下来顺利转了正，到现在也半年了，这半年是技术快速进步的一段时间，也开始接触比较复杂的需求。以前常常能在社区看到大家吐槽做业务的程序员是最底层的，我倒是不这么认为，我觉得凡事都需要循序渐进，不是每个人都能一入门就玩核心算法、深度学习、底层架构这些高深的东西的，相反，当前任何公司绝大部分的都是这些业务需求，做需求的能力扎实了，到哪里都不愁找不到工作。正如我在入职的职业规划上写的：希望自己在未来的一、两年内能尽量的做各种需求。\n\n但是只停留在术而不去钻研道的话，这样职业生涯也不会太长久，自己也在空余时间接触了一下clang+llvm、逆向工程等比较高深的技术，铩羽而归算不上，反正还没有什么实际产出，还需要的前期知识、铺垫比较多，我会慢慢补上。同时自己也一直对金融这一块比较有兴趣，平时经常驻足新浪财经、虎嗅等各种财经类的网站，尤其自己也是搞技术的，互联网+金融，完全是一片广阔的天地。\n\n\n\n## 生活\n\n今年最重要的是什么呢？那当然是，我收获了一个全世界最可爱的女朋友啦~\\(≧▽≦)/。1月10号初识，3月7号正式在一起，不知不觉竟然携手走过了快一年了。这一年里，有过很多个阶段。从各自试探，到互生好感，再到每天甜甜腻腻，再到现在更多了一份理性。期间有因为小事吵吵闹闹，也有三观的激烈碰撞，异地总是比较辛苦的，但是能经受的住异地的考验，那得来的才更加难能可贵。\n\n这一年也是我真正独立生活的第一年，很庆幸自己还是保持了一些良好的习惯，房间总是会打扫收拾，周末的时候会自己煮饭，平时会进行阅读学习，偶尔还会去跑步。不过跑步运动这一段时间真的是松懈了，总觉得跑起来动力不足，时常跑了没几公里就觉得够了，然后就停下了脚步，新的一年，还是希望自己能把运动的好习惯重拾起来。\n\n\n\n## 上一年定下的目标\n\n- 写**5**篇高质量的技术文章（完成度60%）：今年的产出只有3篇技术文章，实在是太少了，也是因为自己今年比较多私人事情，明年还是要更多的进行产出。不过今年倒是打理了自己的博客、掘金、简书等账号，更多的将自己的产出放到社交平台上互动，尤其是掘金，竟然已经有了2000个关注者了，但是自己心里清楚离大牛还有很远的距离，要多多努力了。\n- 开发并维护1个开源库（完成）：呃。。。看着Github上稀稀拉拉的contributions，实在拿不出手啊。\n- 翻译5篇技术文章 3/5（完成度60%）：[iOS的Core Text教程：制作一个杂志应用](https://vernonvan.github.io/2017/07/21/%E7%BF%BB%E8%AF%91%E6%9D%82%E5%BF%97%E5%BA%94%E7%94%A8/)、iPhone X 网页设计(校对)、[关于Swift的编译时间优化](https://vernonvan.github.io/2017/10/22/%E7%BF%BB%E8%AF%91%E5%85%B3%E4%BA%8ESwift%E7%9A%84%E7%BC%96%E8%AF%91%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96/)。\n- 看15本书（完成）（《南京大屠杀》、《激荡三十年》、《史蒂夫乔布斯传》、《穷查理宝典》、《100个Swift2开发必备Tip》、《亮剑》、《数学之美》、《浪潮之巅》、《欧神文集01》、《ASO优化道与术》、《在你身边，为你设计Ⅱ》、《腾讯传》、《欧神文集02》、《iOS应用逆向工程》、《欧神文集03、04、05》）：今年的阅读还是达标的，有自己感兴趣的人物传记、历史等方面的书籍，也有一些是技术书籍、投资入门方面的一些书。\n- 开始接触理财与投资产品\n\n\n\n\n## 我想要的2018\n\n- 写6篇技术文章，并更多的在社区中互动。\n- 开发一个独立APP\n- 技术方面还是深耕iOS：逆向工程、图像处理，拓展方面的打算入门一下机器学习、区块链的基础知识\n- 看12本书，而且得保证看了的书都写一篇读后感，否则不能算上这本书。\n- 争取能做到Github的contributions能亮起来一半吧。。。\n\n\n\n\n\n\n\n","slug":"2017年终总结","published":1,"updated":"2018-01-10T01:40:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg4j8vye0007vfwxihd1fasg","content":"<p>这几天被“18岁”、“网易云音乐年度听歌报告”、“支付宝年度账单”各种刷屏，大家都玩的不亦乐乎，毕竟也是年底了，辛苦工作学习了一年了，也该是时候放松一下了。自己通常都不是太喜欢凑热闹的，偏安一隅，躲在自己的小角落，写下刚刚过去的2017年发生的大事小情，顺便展望一下明年。这也是我第一次提笔写下自己的年终总结，也希望自己以后都能坚持这件事情。</p>\n<h2 id=\"工作\"><a href=\"#工作\" class=\"headerlink\" title=\"工作\"></a>工作</h2><p>过去的这一年，最先想说的还是工作上的事情，毕竟今年告别用了16年的学生身份。</p>\n<p>前半年一直是实习生身份，上下班都是步行回学校，完全没有觉得生活有发生什么变化。公司给了大量的时间自己学习与熟悉技术，所以上班并没有感到什么压力，下了班回去宿舍，打打球，这里溜达溜达，那里吹吹水，偶尔抽出时间处理论文、入党、毕业的事宜，一切如故。</p>\n<p>接下来顺利转了正，到现在也半年了，这半年是技术快速进步的一段时间，也开始接触比较复杂的需求。以前常常能在社区看到大家吐槽做业务的程序员是最底层的，我倒是不这么认为，我觉得凡事都需要循序渐进，不是每个人都能一入门就玩核心算法、深度学习、底层架构这些高深的东西的，相反，当前任何公司绝大部分的都是这些业务需求，做需求的能力扎实了，到哪里都不愁找不到工作。正如我在入职的职业规划上写的：希望自己在未来的一、两年内能尽量的做各种需求。</p>\n<p>但是只停留在术而不去钻研道的话，这样职业生涯也不会太长久，自己也在空余时间接触了一下clang+llvm、逆向工程等比较高深的技术，铩羽而归算不上，反正还没有什么实际产出，还需要的前期知识、铺垫比较多，我会慢慢补上。同时自己也一直对金融这一块比较有兴趣，平时经常驻足新浪财经、虎嗅等各种财经类的网站，尤其自己也是搞技术的，互联网+金融，完全是一片广阔的天地。</p>\n<h2 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h2><p>今年最重要的是什么呢？那当然是，我收获了一个全世界最可爱的女朋友啦~(≧▽≦)/。1月10号初识，3月7号正式在一起，不知不觉竟然携手走过了快一年了。这一年里，有过很多个阶段。从各自试探，到互生好感，再到每天甜甜腻腻，再到现在更多了一份理性。期间有因为小事吵吵闹闹，也有三观的激烈碰撞，异地总是比较辛苦的，但是能经受的住异地的考验，那得来的才更加难能可贵。</p>\n<p>这一年也是我真正独立生活的第一年，很庆幸自己还是保持了一些良好的习惯，房间总是会打扫收拾，周末的时候会自己煮饭，平时会进行阅读学习，偶尔还会去跑步。不过跑步运动这一段时间真的是松懈了，总觉得跑起来动力不足，时常跑了没几公里就觉得够了，然后就停下了脚步，新的一年，还是希望自己能把运动的好习惯重拾起来。</p>\n<h2 id=\"上一年定下的目标\"><a href=\"#上一年定下的目标\" class=\"headerlink\" title=\"上一年定下的目标\"></a>上一年定下的目标</h2><ul>\n<li>写<strong>5</strong>篇高质量的技术文章（完成度60%）：今年的产出只有3篇技术文章，实在是太少了，也是因为自己今年比较多私人事情，明年还是要更多的进行产出。不过今年倒是打理了自己的博客、掘金、简书等账号，更多的将自己的产出放到社交平台上互动，尤其是掘金，竟然已经有了2000个关注者了，但是自己心里清楚离大牛还有很远的距离，要多多努力了。</li>\n<li>开发并维护1个开源库（完成）：呃。。。看着Github上稀稀拉拉的contributions，实在拿不出手啊。</li>\n<li>翻译5篇技术文章 3/5（完成度60%）：<a href=\"https://vernonvan.github.io/2017/07/21/%E7%BF%BB%E8%AF%91%E6%9D%82%E5%BF%97%E5%BA%94%E7%94%A8/\" target=\"_blank\" rel=\"external\">iOS的Core Text教程：制作一个杂志应用</a>、iPhone X 网页设计(校对)、<a href=\"https://vernonvan.github.io/2017/10/22/%E7%BF%BB%E8%AF%91%E5%85%B3%E4%BA%8ESwift%E7%9A%84%E7%BC%96%E8%AF%91%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96/\" target=\"_blank\" rel=\"external\">关于Swift的编译时间优化</a>。</li>\n<li>看15本书（完成）（《南京大屠杀》、《激荡三十年》、《史蒂夫乔布斯传》、《穷查理宝典》、《100个Swift2开发必备Tip》、《亮剑》、《数学之美》、《浪潮之巅》、《欧神文集01》、《ASO优化道与术》、《在你身边，为你设计Ⅱ》、《腾讯传》、《欧神文集02》、《iOS应用逆向工程》、《欧神文集03、04、05》）：今年的阅读还是达标的，有自己感兴趣的人物传记、历史等方面的书籍，也有一些是技术书籍、投资入门方面的一些书。</li>\n<li>开始接触理财与投资产品</li>\n</ul>\n<h2 id=\"我想要的2018\"><a href=\"#我想要的2018\" class=\"headerlink\" title=\"我想要的2018\"></a>我想要的2018</h2><ul>\n<li>写6篇技术文章，并更多的在社区中互动。</li>\n<li>开发一个独立APP</li>\n<li>技术方面还是深耕iOS：逆向工程、图像处理，拓展方面的打算入门一下机器学习、区块链的基础知识</li>\n<li>看12本书，而且得保证看了的书都写一篇读后感，否则不能算上这本书。</li>\n<li>争取能做到Github的contributions能亮起来一半吧。。。</li>\n</ul>\n","excerpt":"","more":"<p>这几天被“18岁”、“网易云音乐年度听歌报告”、“支付宝年度账单”各种刷屏，大家都玩的不亦乐乎，毕竟也是年底了，辛苦工作学习了一年了，也该是时候放松一下了。自己通常都不是太喜欢凑热闹的，偏安一隅，躲在自己的小角落，写下刚刚过去的2017年发生的大事小情，顺便展望一下明年。这也是我第一次提笔写下自己的年终总结，也希望自己以后都能坚持这件事情。</p>\n<h2 id=\"工作\"><a href=\"#工作\" class=\"headerlink\" title=\"工作\"></a>工作</h2><p>过去的这一年，最先想说的还是工作上的事情，毕竟今年告别用了16年的学生身份。</p>\n<p>前半年一直是实习生身份，上下班都是步行回学校，完全没有觉得生活有发生什么变化。公司给了大量的时间自己学习与熟悉技术，所以上班并没有感到什么压力，下了班回去宿舍，打打球，这里溜达溜达，那里吹吹水，偶尔抽出时间处理论文、入党、毕业的事宜，一切如故。</p>\n<p>接下来顺利转了正，到现在也半年了，这半年是技术快速进步的一段时间，也开始接触比较复杂的需求。以前常常能在社区看到大家吐槽做业务的程序员是最底层的，我倒是不这么认为，我觉得凡事都需要循序渐进，不是每个人都能一入门就玩核心算法、深度学习、底层架构这些高深的东西的，相反，当前任何公司绝大部分的都是这些业务需求，做需求的能力扎实了，到哪里都不愁找不到工作。正如我在入职的职业规划上写的：希望自己在未来的一、两年内能尽量的做各种需求。</p>\n<p>但是只停留在术而不去钻研道的话，这样职业生涯也不会太长久，自己也在空余时间接触了一下clang+llvm、逆向工程等比较高深的技术，铩羽而归算不上，反正还没有什么实际产出，还需要的前期知识、铺垫比较多，我会慢慢补上。同时自己也一直对金融这一块比较有兴趣，平时经常驻足新浪财经、虎嗅等各种财经类的网站，尤其自己也是搞技术的，互联网+金融，完全是一片广阔的天地。</p>\n<h2 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h2><p>今年最重要的是什么呢？那当然是，我收获了一个全世界最可爱的女朋友啦~(≧▽≦)/。1月10号初识，3月7号正式在一起，不知不觉竟然携手走过了快一年了。这一年里，有过很多个阶段。从各自试探，到互生好感，再到每天甜甜腻腻，再到现在更多了一份理性。期间有因为小事吵吵闹闹，也有三观的激烈碰撞，异地总是比较辛苦的，但是能经受的住异地的考验，那得来的才更加难能可贵。</p>\n<p>这一年也是我真正独立生活的第一年，很庆幸自己还是保持了一些良好的习惯，房间总是会打扫收拾，周末的时候会自己煮饭，平时会进行阅读学习，偶尔还会去跑步。不过跑步运动这一段时间真的是松懈了，总觉得跑起来动力不足，时常跑了没几公里就觉得够了，然后就停下了脚步，新的一年，还是希望自己能把运动的好习惯重拾起来。</p>\n<h2 id=\"上一年定下的目标\"><a href=\"#上一年定下的目标\" class=\"headerlink\" title=\"上一年定下的目标\"></a>上一年定下的目标</h2><ul>\n<li>写<strong>5</strong>篇高质量的技术文章（完成度60%）：今年的产出只有3篇技术文章，实在是太少了，也是因为自己今年比较多私人事情，明年还是要更多的进行产出。不过今年倒是打理了自己的博客、掘金、简书等账号，更多的将自己的产出放到社交平台上互动，尤其是掘金，竟然已经有了2000个关注者了，但是自己心里清楚离大牛还有很远的距离，要多多努力了。</li>\n<li>开发并维护1个开源库（完成）：呃。。。看着Github上稀稀拉拉的contributions，实在拿不出手啊。</li>\n<li>翻译5篇技术文章 3/5（完成度60%）：<a href=\"https://vernonvan.github.io/2017/07/21/%E7%BF%BB%E8%AF%91%E6%9D%82%E5%BF%97%E5%BA%94%E7%94%A8/\">iOS的Core Text教程：制作一个杂志应用</a>、iPhone X 网页设计(校对)、<a href=\"https://vernonvan.github.io/2017/10/22/%E7%BF%BB%E8%AF%91%E5%85%B3%E4%BA%8ESwift%E7%9A%84%E7%BC%96%E8%AF%91%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96/\">关于Swift的编译时间优化</a>。</li>\n<li>看15本书（完成）（《南京大屠杀》、《激荡三十年》、《史蒂夫乔布斯传》、《穷查理宝典》、《100个Swift2开发必备Tip》、《亮剑》、《数学之美》、《浪潮之巅》、《欧神文集01》、《ASO优化道与术》、《在你身边，为你设计Ⅱ》、《腾讯传》、《欧神文集02》、《iOS应用逆向工程》、《欧神文集03、04、05》）：今年的阅读还是达标的，有自己感兴趣的人物传记、历史等方面的书籍，也有一些是技术书籍、投资入门方面的一些书。</li>\n<li>开始接触理财与投资产品</li>\n</ul>\n<h2 id=\"我想要的2018\"><a href=\"#我想要的2018\" class=\"headerlink\" title=\"我想要的2018\"></a>我想要的2018</h2><ul>\n<li>写6篇技术文章，并更多的在社区中互动。</li>\n<li>开发一个独立APP</li>\n<li>技术方面还是深耕iOS：逆向工程、图像处理，拓展方面的打算入门一下机器学习、区块链的基础知识</li>\n<li>看12本书，而且得保证看了的书都写一篇读后感，否则不能算上这本书。</li>\n<li>争取能做到Github的contributions能亮起来一半吧。。。</li>\n</ul>\n"},{"title":"Clang 之旅--实现一个自定义检查规范的 Clang 插件","date":"2018-04-17T07:55:23.000Z","_content":"\n\n\nClang 之旅系列文章：\n[Clang 之旅--使用 Xcode 开发 Clang 插件](https://www.jianshu.com/p/e3f46d42643b)\n[Clang 之旅--[翻译]添加自定义的 attribute](https://www.jianshu.com/p/d277c42f4907)\n[Clang 之旅--实现一个自定义检查规范的 Clang 插件](https://www.jianshu.com/p/c27b77f70616)\n\n\n\n### 前言\n\n在 Clang 之旅系列文章[开篇](https://www.jianshu.com/p/e3f46d42643b)的时候，我说到过自己接触 Clang 的直接原因就是想实现一个自定义的检查需求：是否有办法在编译阶段检查某个方法的参数与返回值的类型相同，如果类型不一致的话能抛出编译错误的提示。现在我已经根据自己的需求完成了这个插件，这篇文章会讲解这个插件的实现思路，对应的代码在这里：https://github.com/VernonVan/SameTypeClangPlugin\n\n\n\n### 具化需求 \n\n首先我先将需求具化一下，之前说的比较宽泛。\n\n试想我们有这么一个函数 `modelOfClass`：\n\n```objective-c\n- (__kindof NSObject *)modelOfClass:(Class)modelClass \n{\n    if ([modelClass isKindOfClass:[NSString class]]) {\n        return [[NSString alloc] init];\n    } else if ([modelClass isKindOfClass:[NSArray class]]) {\n        return [[NSArray alloc] init];\n    }\n    return nil;\n}\n```\n\n`modelOfClass` 接受一个 `Class` 类型的参数，然后会根据 `Class` 对应的类进行不同的操作，最终返回处理好的 `Class` 对应类的实例对象。我们用 `__kindof NSObject *` 返回值类型来保证返回的一定是 `NSObject` 或者其子类，能保证的也只有这样而已。但是，存在这样一种错误的调用方式，但是却能通过编译：\n\n```objective-c\n@property (nonatomic, strong) NSString *myString;\n@property (nonatomic, strong) NSArray *myArray;\n\n- (void)someMethod\n{\n    self.myString = [self modelOfClass:[NSString class]];\n    self.myArray = [self modelOfClass:[NSString class]];\n}\n```\n\n可以发现，`someMethod` 中有两行 `modelOfClass` 的函数调用。第一行调用是正确的，`NSString *` 类型的属性 `myString` 调用时传入的是 `[NSString class]`；第二行调用是错误的，`NSArray *` 类型的属性 `myArray` 调用时传入的是 `[NSString class]`。也就是说，在 Objective-C 语言中，并没有一种办法能够检查函数调用时参数类型和返回值类型是完全一致的。\n\n\n\n这个需求是从我所在公司的项目中抽象简化出来的，大家看不出来这个函数究竟是用来干什么的，可能会觉得这个需求并不常见，没有什么通用性。但是这篇文章希望读者看了之后能以小见大，举一反三，更重要的是学到怎么样使用通用的方式，根据自己的需求实现自定义检查规范的 Clang 插件。\n\n\n\n### 最终效果\n\n我们来看看最终实现的效果：\n\n![演示效果](https://upload-images.jianshu.io/upload_images/698554-c7aa746724799734.GIF?imageMogr2/auto-orient/strip)\n\n最终实现了上面所说的类型检查，同时还给出了对应的修改方法（FixIt），点击修改就能改成正确的参数类型🎉🎉🎉 下面就来说说具体是怎么实现的。\n\n\n\n### 抽象语法树（Abstract syntax tree）\n\n抽象语法树，英文简称为 AST，是编译过程中语法分析阶段的产物，也是我们作为外部开发者与 Clang 进行交互的最重要的方式。所以我们最重要的就是学会怎么样阅读、分析语法树。\n\n\n\n在命令行中输入以下命令，打印 main.m 文件对应的语法树到命令行中：\n\n```\nclang -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.3.sdk -fmodules -fsyntax-only -Xclang -ast-dump main.m\n```\n\n> 在我写这篇文章时 Xcode 版本是9.3，对应的是 iPhoneSimulator11.3.sdk，你需要进入该目录查看你的 sdk 版本，然后修改 -isysroot 命令后的 sdk 路径\n\n\n\n打印出来的语法树如下图：\n\n![AST](https://upload-images.jianshu.io/upload_images/698554-f509375dfc159afe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n编译前端 Clang 首先进行词法分析（Lexical Analysis），把源文件的字符流拆分一个一个的 token；然后 token 进入语法分析（Semantic Analysis），将这些 token 组合成语法树。左边的缩进代表了语法树节点的从属关系，语法树上的每一个节点的名字都能在 Clang 源码中找到对应的类。\n\n从图中挑几个点来解释一下（对应图中的红色标注）：\n\n1. `ObjCImplementationDecl` 节点代表了 Objective-C 类中的 `@implementation` 部分的内容\n\n2. `ObjCMethodDecl` 节点代表了 Objective-C 中的函数定义，我们在 Clang 源码中查看一下对应类的定义\n\n   ![ObjCMethodDecl](https://upload-images.jianshu.io/upload_images/698554-3ece97359f29ec5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n   Clang 的文档注释可以说相当齐全了，`ObjCMethodDecl`  代表了一个类方法或者实例方法。所有的 `public:` 域中的方法都是我们可以用的，比如说  `Selector getSelector()` 可以获取该方法的 `Selector`，`ArrayRef<ParmVarDecl*> parameters()` 可以获取获取该方法的参数列表等等。\n\n3. 框中的语法块代表了源文件中 `self.myString = [self modelOfClass:[NSString class]];` 语句，`BinaryOperator` 代表了二元操作符（包括赋值的“=”），可以通过 `BinaryOperator` 类的 `Expr *getLHS()` 和 `Expr *getRHS()` 分别取得“=”左右两边的语句。\n\n> 详细的 AST 树的分析可以查看官方的教程：http://clang.llvm.org/docs/IntroductionToTheClangAST.html\n\n\n\n那么多种的 AST 节点中应该怎么只获取自己感兴趣的节点呢？\n\nClang 提供了 `ASTMatcher` 类供我们进行 AST 节点的查找过滤，有一篇专门解释罗列各种各样的 `ASTMatcher` 的[官方文档](http://clang.llvm.org/docs/LibASTMatchersReference.html)可以查看。\n\n![ASTMatcher](https://upload-images.jianshu.io/upload_images/698554-71f15a143a85a6e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n比如可以用 `objcPropertyDecl` 来匹配到 Objective-C 的类属性，`ASTMatcher` 可以用一种类似链式语法的方式将一系列的 Matcher 串起来，比如可以用 `cxxRecordDecl(unless(hasName(\"X\")))` 来匹配到满足类名不为 `X` 的所有 C++ 类。\n\n> 具体的 ASTMatcher 的使用方法可以查看这篇教程：https://eli.thegreenplace.net/2014/07/29/ast-matchers-and-clang-refactoring-tools\n\n\n\n### 实现思路\n\n基础知识铺垫完了，现在我们来拆解一下我们的需求。首先我们需要有一种方式标记需要进行这种检查的函数，总不至于所有函数调用我们都去检查一遍吧😹 这时候就可以想到可以通过 attribute 的方式标记函数！\n\n> 关于 attribute 的知识，可以查看孙源大神的这篇文章：[Clang Attributes 黑魔法小记](https://blog.sunnyxx.com/2016/05/14/clang-attributes/)，讲解了多种常见不常见的 attribute 的使用场景\n>\n> 另外一篇就是官方关于如何在 Clang 中添加自定义的 attribute 的文档：[How to add an attribute](https://clang.llvm.org/docs/InternalsManual.html#how-to-add-an-attribute)，我自己也翻译了这篇文档，请戳[中文版](https://www.jianshu.com/p/d277c42f4907)。\n\n这里不讲解怎么添加自定义的 attribute，比较简单，就是按最简单的模板添加的。添加完了之后，得在 `modelOfClass` 后面加上一句 `__attribute__((objc_same_type))`，代表 `modelOfClass` 在每次被调用时都会进行自定义的检查，这样才能出现上面演示效果图中的检查结果（objc_same_type 就是我所添加的 attribute 的名字）。\n\n```objective-c\n- (__kindof NSObject *)modelOfClass:(Class)modelClass __attribute__((objc_same_type))\n```\n\n#### \n\n具体该怎么检查呢？分成以下几个步骤：\n\n1. 首先判断语法树上的节点是否是赋值语句（Clang 中用 `BinaryOperator` 表征赋值语句）。如果是，进入第 2 步\n2. 用 `BinaryOperator` 的 `getLHS()` 、`getRHS()` 函数分别获得左右的表达式\n3. 如果左边表达式是 Objective-C 类的属性的话，获取该属性对应的类型 A。进入第 4 步\n4. 如果右边表达式是 Objective-C 的函数调用，且被调用的函数是有我们上面所定义 __attribute__((objc_same_type)) 的话（可以通过 `ObjCMethodDecl` 的 `attrs()` 方法获得 Objective-C 函数的所有的 attribute），获取该函数的参数对应的类型 B\n5. 对比 A 和 B 的类型是否一致，如果不一致，则弹出类型不一致的编译警告，并提出恰当的修改方法（如效果演示图所示）\n\n\n> 具体的实现代码和使用方法查看 Github：https://github.com/VernonVan/SameTypeClangPlugin\n\n\n\n### 结语\n\n最终花了不到 200 行代码就完成了这个小小的功能，但是却花了我将近一个月的业余时间，中间也做了很多无用功，在错误的道路上走了一段时间才发现自己做的完全是错的，幸好最后还是成功找到了正确的方法。不过，自己也收获了很多的技能点，比如说阅读源码的能力，得益于 LLVM 良好的代码设计和模块化，让我一个门外汉也能比较快速的从庞大的代码中找到自己想要的部分；比如说 CMake 构建工程的知识、C++ 语言以及查找阅读英文文档的能力。收获还是比较多的🍹🍹🍹\n\n接下来如果在 LLVM && Clang 这一块有其他的所得的话，会再撰文分享~","source":"_posts/Clang之旅-实现一个自定义检查规范的Clang插件.md","raw":"---\ntitle: Clang 之旅--实现一个自定义检查规范的 Clang 插件\ndate: 2018-04-17 15:55:23\ntags: \n- iOS\n- clang & llvm\ncategories:\n- ruanpapa--技术贴\n---\n\n\n\nClang 之旅系列文章：\n[Clang 之旅--使用 Xcode 开发 Clang 插件](https://www.jianshu.com/p/e3f46d42643b)\n[Clang 之旅--[翻译]添加自定义的 attribute](https://www.jianshu.com/p/d277c42f4907)\n[Clang 之旅--实现一个自定义检查规范的 Clang 插件](https://www.jianshu.com/p/c27b77f70616)\n\n\n\n### 前言\n\n在 Clang 之旅系列文章[开篇](https://www.jianshu.com/p/e3f46d42643b)的时候，我说到过自己接触 Clang 的直接原因就是想实现一个自定义的检查需求：是否有办法在编译阶段检查某个方法的参数与返回值的类型相同，如果类型不一致的话能抛出编译错误的提示。现在我已经根据自己的需求完成了这个插件，这篇文章会讲解这个插件的实现思路，对应的代码在这里：https://github.com/VernonVan/SameTypeClangPlugin\n\n\n\n### 具化需求 \n\n首先我先将需求具化一下，之前说的比较宽泛。\n\n试想我们有这么一个函数 `modelOfClass`：\n\n```objective-c\n- (__kindof NSObject *)modelOfClass:(Class)modelClass \n{\n    if ([modelClass isKindOfClass:[NSString class]]) {\n        return [[NSString alloc] init];\n    } else if ([modelClass isKindOfClass:[NSArray class]]) {\n        return [[NSArray alloc] init];\n    }\n    return nil;\n}\n```\n\n`modelOfClass` 接受一个 `Class` 类型的参数，然后会根据 `Class` 对应的类进行不同的操作，最终返回处理好的 `Class` 对应类的实例对象。我们用 `__kindof NSObject *` 返回值类型来保证返回的一定是 `NSObject` 或者其子类，能保证的也只有这样而已。但是，存在这样一种错误的调用方式，但是却能通过编译：\n\n```objective-c\n@property (nonatomic, strong) NSString *myString;\n@property (nonatomic, strong) NSArray *myArray;\n\n- (void)someMethod\n{\n    self.myString = [self modelOfClass:[NSString class]];\n    self.myArray = [self modelOfClass:[NSString class]];\n}\n```\n\n可以发现，`someMethod` 中有两行 `modelOfClass` 的函数调用。第一行调用是正确的，`NSString *` 类型的属性 `myString` 调用时传入的是 `[NSString class]`；第二行调用是错误的，`NSArray *` 类型的属性 `myArray` 调用时传入的是 `[NSString class]`。也就是说，在 Objective-C 语言中，并没有一种办法能够检查函数调用时参数类型和返回值类型是完全一致的。\n\n\n\n这个需求是从我所在公司的项目中抽象简化出来的，大家看不出来这个函数究竟是用来干什么的，可能会觉得这个需求并不常见，没有什么通用性。但是这篇文章希望读者看了之后能以小见大，举一反三，更重要的是学到怎么样使用通用的方式，根据自己的需求实现自定义检查规范的 Clang 插件。\n\n\n\n### 最终效果\n\n我们来看看最终实现的效果：\n\n![演示效果](https://upload-images.jianshu.io/upload_images/698554-c7aa746724799734.GIF?imageMogr2/auto-orient/strip)\n\n最终实现了上面所说的类型检查，同时还给出了对应的修改方法（FixIt），点击修改就能改成正确的参数类型🎉🎉🎉 下面就来说说具体是怎么实现的。\n\n\n\n### 抽象语法树（Abstract syntax tree）\n\n抽象语法树，英文简称为 AST，是编译过程中语法分析阶段的产物，也是我们作为外部开发者与 Clang 进行交互的最重要的方式。所以我们最重要的就是学会怎么样阅读、分析语法树。\n\n\n\n在命令行中输入以下命令，打印 main.m 文件对应的语法树到命令行中：\n\n```\nclang -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.3.sdk -fmodules -fsyntax-only -Xclang -ast-dump main.m\n```\n\n> 在我写这篇文章时 Xcode 版本是9.3，对应的是 iPhoneSimulator11.3.sdk，你需要进入该目录查看你的 sdk 版本，然后修改 -isysroot 命令后的 sdk 路径\n\n\n\n打印出来的语法树如下图：\n\n![AST](https://upload-images.jianshu.io/upload_images/698554-f509375dfc159afe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n编译前端 Clang 首先进行词法分析（Lexical Analysis），把源文件的字符流拆分一个一个的 token；然后 token 进入语法分析（Semantic Analysis），将这些 token 组合成语法树。左边的缩进代表了语法树节点的从属关系，语法树上的每一个节点的名字都能在 Clang 源码中找到对应的类。\n\n从图中挑几个点来解释一下（对应图中的红色标注）：\n\n1. `ObjCImplementationDecl` 节点代表了 Objective-C 类中的 `@implementation` 部分的内容\n\n2. `ObjCMethodDecl` 节点代表了 Objective-C 中的函数定义，我们在 Clang 源码中查看一下对应类的定义\n\n   ![ObjCMethodDecl](https://upload-images.jianshu.io/upload_images/698554-3ece97359f29ec5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n   Clang 的文档注释可以说相当齐全了，`ObjCMethodDecl`  代表了一个类方法或者实例方法。所有的 `public:` 域中的方法都是我们可以用的，比如说  `Selector getSelector()` 可以获取该方法的 `Selector`，`ArrayRef<ParmVarDecl*> parameters()` 可以获取获取该方法的参数列表等等。\n\n3. 框中的语法块代表了源文件中 `self.myString = [self modelOfClass:[NSString class]];` 语句，`BinaryOperator` 代表了二元操作符（包括赋值的“=”），可以通过 `BinaryOperator` 类的 `Expr *getLHS()` 和 `Expr *getRHS()` 分别取得“=”左右两边的语句。\n\n> 详细的 AST 树的分析可以查看官方的教程：http://clang.llvm.org/docs/IntroductionToTheClangAST.html\n\n\n\n那么多种的 AST 节点中应该怎么只获取自己感兴趣的节点呢？\n\nClang 提供了 `ASTMatcher` 类供我们进行 AST 节点的查找过滤，有一篇专门解释罗列各种各样的 `ASTMatcher` 的[官方文档](http://clang.llvm.org/docs/LibASTMatchersReference.html)可以查看。\n\n![ASTMatcher](https://upload-images.jianshu.io/upload_images/698554-71f15a143a85a6e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n比如可以用 `objcPropertyDecl` 来匹配到 Objective-C 的类属性，`ASTMatcher` 可以用一种类似链式语法的方式将一系列的 Matcher 串起来，比如可以用 `cxxRecordDecl(unless(hasName(\"X\")))` 来匹配到满足类名不为 `X` 的所有 C++ 类。\n\n> 具体的 ASTMatcher 的使用方法可以查看这篇教程：https://eli.thegreenplace.net/2014/07/29/ast-matchers-and-clang-refactoring-tools\n\n\n\n### 实现思路\n\n基础知识铺垫完了，现在我们来拆解一下我们的需求。首先我们需要有一种方式标记需要进行这种检查的函数，总不至于所有函数调用我们都去检查一遍吧😹 这时候就可以想到可以通过 attribute 的方式标记函数！\n\n> 关于 attribute 的知识，可以查看孙源大神的这篇文章：[Clang Attributes 黑魔法小记](https://blog.sunnyxx.com/2016/05/14/clang-attributes/)，讲解了多种常见不常见的 attribute 的使用场景\n>\n> 另外一篇就是官方关于如何在 Clang 中添加自定义的 attribute 的文档：[How to add an attribute](https://clang.llvm.org/docs/InternalsManual.html#how-to-add-an-attribute)，我自己也翻译了这篇文档，请戳[中文版](https://www.jianshu.com/p/d277c42f4907)。\n\n这里不讲解怎么添加自定义的 attribute，比较简单，就是按最简单的模板添加的。添加完了之后，得在 `modelOfClass` 后面加上一句 `__attribute__((objc_same_type))`，代表 `modelOfClass` 在每次被调用时都会进行自定义的检查，这样才能出现上面演示效果图中的检查结果（objc_same_type 就是我所添加的 attribute 的名字）。\n\n```objective-c\n- (__kindof NSObject *)modelOfClass:(Class)modelClass __attribute__((objc_same_type))\n```\n\n#### \n\n具体该怎么检查呢？分成以下几个步骤：\n\n1. 首先判断语法树上的节点是否是赋值语句（Clang 中用 `BinaryOperator` 表征赋值语句）。如果是，进入第 2 步\n2. 用 `BinaryOperator` 的 `getLHS()` 、`getRHS()` 函数分别获得左右的表达式\n3. 如果左边表达式是 Objective-C 类的属性的话，获取该属性对应的类型 A。进入第 4 步\n4. 如果右边表达式是 Objective-C 的函数调用，且被调用的函数是有我们上面所定义 __attribute__((objc_same_type)) 的话（可以通过 `ObjCMethodDecl` 的 `attrs()` 方法获得 Objective-C 函数的所有的 attribute），获取该函数的参数对应的类型 B\n5. 对比 A 和 B 的类型是否一致，如果不一致，则弹出类型不一致的编译警告，并提出恰当的修改方法（如效果演示图所示）\n\n\n> 具体的实现代码和使用方法查看 Github：https://github.com/VernonVan/SameTypeClangPlugin\n\n\n\n### 结语\n\n最终花了不到 200 行代码就完成了这个小小的功能，但是却花了我将近一个月的业余时间，中间也做了很多无用功，在错误的道路上走了一段时间才发现自己做的完全是错的，幸好最后还是成功找到了正确的方法。不过，自己也收获了很多的技能点，比如说阅读源码的能力，得益于 LLVM 良好的代码设计和模块化，让我一个门外汉也能比较快速的从庞大的代码中找到自己想要的部分；比如说 CMake 构建工程的知识、C++ 语言以及查找阅读英文文档的能力。收获还是比较多的🍹🍹🍹\n\n接下来如果在 LLVM && Clang 这一块有其他的所得的话，会再撰文分享~","slug":"Clang之旅-实现一个自定义检查规范的Clang插件","published":1,"updated":"2018-04-18T03:23:21.021Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg4j8vye0008vfwxku8rvfdb","content":"<p>Clang 之旅系列文章：<br><a href=\"https://www.jianshu.com/p/e3f46d42643b\" target=\"_blank\" rel=\"external\">Clang 之旅–使用 Xcode 开发 Clang 插件</a><br><a href=\"https://www.jianshu.com/p/d277c42f4907\" target=\"_blank\" rel=\"external\">Clang 之旅–[翻译]添加自定义的 attribute</a><br><a href=\"https://www.jianshu.com/p/c27b77f70616\" target=\"_blank\" rel=\"external\">Clang 之旅–实现一个自定义检查规范的 Clang 插件</a></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在 Clang 之旅系列文章<a href=\"https://www.jianshu.com/p/e3f46d42643b\" target=\"_blank\" rel=\"external\">开篇</a>的时候，我说到过自己接触 Clang 的直接原因就是想实现一个自定义的检查需求：是否有办法在编译阶段检查某个方法的参数与返回值的类型相同，如果类型不一致的话能抛出编译错误的提示。现在我已经根据自己的需求完成了这个插件，这篇文章会讲解这个插件的实现思路，对应的代码在这里：<a href=\"https://github.com/VernonVan/SameTypeClangPlugin\" target=\"_blank\" rel=\"external\">https://github.com/VernonVan/SameTypeClangPlugin</a></p>\n<h3 id=\"具化需求\"><a href=\"#具化需求\" class=\"headerlink\" title=\"具化需求\"></a>具化需求</h3><p>首先我先将需求具化一下，之前说的比较宽泛。</p>\n<p>试想我们有这么一个函数 <code>modelOfClass</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (__kindof NSObject *)modelOfClass:(Class)modelClass </div><div class=\"line\">&#123;</div><div class=\"line\">    if ([modelClass isKindOfClass:[NSString class]]) &#123;</div><div class=\"line\">        return [[NSString alloc] init];</div><div class=\"line\">    &#125; else if ([modelClass isKindOfClass:[NSArray class]]) &#123;</div><div class=\"line\">        return [[NSArray alloc] init];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return nil;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>modelOfClass</code> 接受一个 <code>Class</code> 类型的参数，然后会根据 <code>Class</code> 对应的类进行不同的操作，最终返回处理好的 <code>Class</code> 对应类的实例对象。我们用 <code>__kindof NSObject *</code> 返回值类型来保证返回的一定是 <code>NSObject</code> 或者其子类，能保证的也只有这样而已。但是，存在这样一种错误的调用方式，但是却能通过编译：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property (nonatomic, strong) NSString *myString;</div><div class=\"line\">@property (nonatomic, strong) NSArray *myArray;</div><div class=\"line\"></div><div class=\"line\">- (void)someMethod</div><div class=\"line\">&#123;</div><div class=\"line\">    self.myString = [self modelOfClass:[NSString class]];</div><div class=\"line\">    self.myArray = [self modelOfClass:[NSString class]];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以发现，<code>someMethod</code> 中有两行 <code>modelOfClass</code> 的函数调用。第一行调用是正确的，<code>NSString *</code> 类型的属性 <code>myString</code> 调用时传入的是 <code>[NSString class]</code>；第二行调用是错误的，<code>NSArray *</code> 类型的属性 <code>myArray</code> 调用时传入的是 <code>[NSString class]</code>。也就是说，在 Objective-C 语言中，并没有一种办法能够检查函数调用时参数类型和返回值类型是完全一致的。</p>\n<p>这个需求是从我所在公司的项目中抽象简化出来的，大家看不出来这个函数究竟是用来干什么的，可能会觉得这个需求并不常见，没有什么通用性。但是这篇文章希望读者看了之后能以小见大，举一反三，更重要的是学到怎么样使用通用的方式，根据自己的需求实现自定义检查规范的 Clang 插件。</p>\n<h3 id=\"最终效果\"><a href=\"#最终效果\" class=\"headerlink\" title=\"最终效果\"></a>最终效果</h3><p>我们来看看最终实现的效果：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/698554-c7aa746724799734.GIF?imageMogr2/auto-orient/strip\" alt=\"演示效果\"></p>\n<p>最终实现了上面所说的类型检查，同时还给出了对应的修改方法（FixIt），点击修改就能改成正确的参数类型🎉🎉🎉 下面就来说说具体是怎么实现的。</p>\n<h3 id=\"抽象语法树（Abstract-syntax-tree）\"><a href=\"#抽象语法树（Abstract-syntax-tree）\" class=\"headerlink\" title=\"抽象语法树（Abstract syntax tree）\"></a>抽象语法树（Abstract syntax tree）</h3><p>抽象语法树，英文简称为 AST，是编译过程中语法分析阶段的产物，也是我们作为外部开发者与 Clang 进行交互的最重要的方式。所以我们最重要的就是学会怎么样阅读、分析语法树。</p>\n<p>在命令行中输入以下命令，打印 main.m 文件对应的语法树到命令行中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.3.sdk -fmodules -fsyntax-only -Xclang -ast-dump main.m</div></pre></td></tr></table></figure>\n<blockquote>\n<p>在我写这篇文章时 Xcode 版本是9.3，对应的是 iPhoneSimulator11.3.sdk，你需要进入该目录查看你的 sdk 版本，然后修改 -isysroot 命令后的 sdk 路径</p>\n</blockquote>\n<p>打印出来的语法树如下图：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/698554-f509375dfc159afe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"AST\"></p>\n<p>编译前端 Clang 首先进行词法分析（Lexical Analysis），把源文件的字符流拆分一个一个的 token；然后 token 进入语法分析（Semantic Analysis），将这些 token 组合成语法树。左边的缩进代表了语法树节点的从属关系，语法树上的每一个节点的名字都能在 Clang 源码中找到对应的类。</p>\n<p>从图中挑几个点来解释一下（对应图中的红色标注）：</p>\n<ol>\n<li><p><code>ObjCImplementationDecl</code> 节点代表了 Objective-C 类中的 <code>@implementation</code> 部分的内容</p>\n</li>\n<li><p><code>ObjCMethodDecl</code> 节点代表了 Objective-C 中的函数定义，我们在 Clang 源码中查看一下对应类的定义</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/698554-3ece97359f29ec5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"ObjCMethodDecl\"></p>\n<p>Clang 的文档注释可以说相当齐全了，<code>ObjCMethodDecl</code>  代表了一个类方法或者实例方法。所有的 <code>public:</code> 域中的方法都是我们可以用的，比如说  <code>Selector getSelector()</code> 可以获取该方法的 <code>Selector</code>，<code>ArrayRef&lt;ParmVarDecl*&gt; parameters()</code> 可以获取获取该方法的参数列表等等。</p>\n</li>\n<li><p>框中的语法块代表了源文件中 <code>self.myString = [self modelOfClass:[NSString class]];</code> 语句，<code>BinaryOperator</code> 代表了二元操作符（包括赋值的“=”），可以通过 <code>BinaryOperator</code> 类的 <code>Expr *getLHS()</code> 和 <code>Expr *getRHS()</code> 分别取得“=”左右两边的语句。</p>\n</li>\n</ol>\n<blockquote>\n<p>详细的 AST 树的分析可以查看官方的教程：<a href=\"http://clang.llvm.org/docs/IntroductionToTheClangAST.html\" target=\"_blank\" rel=\"external\">http://clang.llvm.org/docs/IntroductionToTheClangAST.html</a></p>\n</blockquote>\n<p>那么多种的 AST 节点中应该怎么只获取自己感兴趣的节点呢？</p>\n<p>Clang 提供了 <code>ASTMatcher</code> 类供我们进行 AST 节点的查找过滤，有一篇专门解释罗列各种各样的 <code>ASTMatcher</code> 的<a href=\"http://clang.llvm.org/docs/LibASTMatchersReference.html\" target=\"_blank\" rel=\"external\">官方文档</a>可以查看。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/698554-71f15a143a85a6e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"ASTMatcher\"></p>\n<p>比如可以用 <code>objcPropertyDecl</code> 来匹配到 Objective-C 的类属性，<code>ASTMatcher</code> 可以用一种类似链式语法的方式将一系列的 Matcher 串起来，比如可以用 <code>cxxRecordDecl(unless(hasName(&quot;X&quot;)))</code> 来匹配到满足类名不为 <code>X</code> 的所有 C++ 类。</p>\n<blockquote>\n<p>具体的 ASTMatcher 的使用方法可以查看这篇教程：<a href=\"https://eli.thegreenplace.net/2014/07/29/ast-matchers-and-clang-refactoring-tools\" target=\"_blank\" rel=\"external\">https://eli.thegreenplace.net/2014/07/29/ast-matchers-and-clang-refactoring-tools</a></p>\n</blockquote>\n<h3 id=\"实现思路\"><a href=\"#实现思路\" class=\"headerlink\" title=\"实现思路\"></a>实现思路</h3><p>基础知识铺垫完了，现在我们来拆解一下我们的需求。首先我们需要有一种方式标记需要进行这种检查的函数，总不至于所有函数调用我们都去检查一遍吧😹 这时候就可以想到可以通过 attribute 的方式标记函数！</p>\n<blockquote>\n<p>关于 attribute 的知识，可以查看孙源大神的这篇文章：<a href=\"https://blog.sunnyxx.com/2016/05/14/clang-attributes/\" target=\"_blank\" rel=\"external\">Clang Attributes 黑魔法小记</a>，讲解了多种常见不常见的 attribute 的使用场景</p>\n<p>另外一篇就是官方关于如何在 Clang 中添加自定义的 attribute 的文档：<a href=\"https://clang.llvm.org/docs/InternalsManual.html#how-to-add-an-attribute\" target=\"_blank\" rel=\"external\">How to add an attribute</a>，我自己也翻译了这篇文档，请戳<a href=\"https://www.jianshu.com/p/d277c42f4907\" target=\"_blank\" rel=\"external\">中文版</a>。</p>\n</blockquote>\n<p>这里不讲解怎么添加自定义的 attribute，比较简单，就是按最简单的模板添加的。添加完了之后，得在 <code>modelOfClass</code> 后面加上一句 <code>__attribute__((objc_same_type))</code>，代表 <code>modelOfClass</code> 在每次被调用时都会进行自定义的检查，这样才能出现上面演示效果图中的检查结果（objc_same_type 就是我所添加的 attribute 的名字）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (__kindof NSObject *)modelOfClass:(Class)modelClass __attribute__((objc_same_type))</div></pre></td></tr></table></figure>\n<p>#### </p>\n<p>具体该怎么检查呢？分成以下几个步骤：</p>\n<ol>\n<li>首先判断语法树上的节点是否是赋值语句（Clang 中用 <code>BinaryOperator</code> 表征赋值语句）。如果是，进入第 2 步</li>\n<li>用 <code>BinaryOperator</code> 的 <code>getLHS()</code> 、<code>getRHS()</code> 函数分别获得左右的表达式</li>\n<li>如果左边表达式是 Objective-C 类的属性的话，获取该属性对应的类型 A。进入第 4 步</li>\n<li>如果右边表达式是 Objective-C 的函数调用，且被调用的函数是有我们上面所定义 <strong>attribute</strong>((objc_same_type)) 的话（可以通过 <code>ObjCMethodDecl</code> 的 <code>attrs()</code> 方法获得 Objective-C 函数的所有的 attribute），获取该函数的参数对应的类型 B</li>\n<li>对比 A 和 B 的类型是否一致，如果不一致，则弹出类型不一致的编译警告，并提出恰当的修改方法（如效果演示图所示）</li>\n</ol>\n<blockquote>\n<p>具体的实现代码和使用方法查看 Github：<a href=\"https://github.com/VernonVan/SameTypeClangPlugin\" target=\"_blank\" rel=\"external\">https://github.com/VernonVan/SameTypeClangPlugin</a></p>\n</blockquote>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>最终花了不到 200 行代码就完成了这个小小的功能，但是却花了我将近一个月的业余时间，中间也做了很多无用功，在错误的道路上走了一段时间才发现自己做的完全是错的，幸好最后还是成功找到了正确的方法。不过，自己也收获了很多的技能点，比如说阅读源码的能力，得益于 LLVM 良好的代码设计和模块化，让我一个门外汉也能比较快速的从庞大的代码中找到自己想要的部分；比如说 CMake 构建工程的知识、C++ 语言以及查找阅读英文文档的能力。收获还是比较多的🍹🍹🍹</p>\n<p>接下来如果在 LLVM &amp;&amp; Clang 这一块有其他的所得的话，会再撰文分享~</p>\n","excerpt":"","more":"<p>Clang 之旅系列文章：<br><a href=\"https://www.jianshu.com/p/e3f46d42643b\">Clang 之旅–使用 Xcode 开发 Clang 插件</a><br><a href=\"https://www.jianshu.com/p/d277c42f4907\">Clang 之旅–[翻译]添加自定义的 attribute</a><br><a href=\"https://www.jianshu.com/p/c27b77f70616\">Clang 之旅–实现一个自定义检查规范的 Clang 插件</a></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在 Clang 之旅系列文章<a href=\"https://www.jianshu.com/p/e3f46d42643b\">开篇</a>的时候，我说到过自己接触 Clang 的直接原因就是想实现一个自定义的检查需求：是否有办法在编译阶段检查某个方法的参数与返回值的类型相同，如果类型不一致的话能抛出编译错误的提示。现在我已经根据自己的需求完成了这个插件，这篇文章会讲解这个插件的实现思路，对应的代码在这里：<a href=\"https://github.com/VernonVan/SameTypeClangPlugin\">https://github.com/VernonVan/SameTypeClangPlugin</a></p>\n<h3 id=\"具化需求\"><a href=\"#具化需求\" class=\"headerlink\" title=\"具化需求\"></a>具化需求</h3><p>首先我先将需求具化一下，之前说的比较宽泛。</p>\n<p>试想我们有这么一个函数 <code>modelOfClass</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (__kindof NSObject *)modelOfClass:(Class)modelClass </div><div class=\"line\">&#123;</div><div class=\"line\">    if ([modelClass isKindOfClass:[NSString class]]) &#123;</div><div class=\"line\">        return [[NSString alloc] init];</div><div class=\"line\">    &#125; else if ([modelClass isKindOfClass:[NSArray class]]) &#123;</div><div class=\"line\">        return [[NSArray alloc] init];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return nil;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>modelOfClass</code> 接受一个 <code>Class</code> 类型的参数，然后会根据 <code>Class</code> 对应的类进行不同的操作，最终返回处理好的 <code>Class</code> 对应类的实例对象。我们用 <code>__kindof NSObject *</code> 返回值类型来保证返回的一定是 <code>NSObject</code> 或者其子类，能保证的也只有这样而已。但是，存在这样一种错误的调用方式，但是却能通过编译：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property (nonatomic, strong) NSString *myString;</div><div class=\"line\">@property (nonatomic, strong) NSArray *myArray;</div><div class=\"line\"></div><div class=\"line\">- (void)someMethod</div><div class=\"line\">&#123;</div><div class=\"line\">    self.myString = [self modelOfClass:[NSString class]];</div><div class=\"line\">    self.myArray = [self modelOfClass:[NSString class]];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以发现，<code>someMethod</code> 中有两行 <code>modelOfClass</code> 的函数调用。第一行调用是正确的，<code>NSString *</code> 类型的属性 <code>myString</code> 调用时传入的是 <code>[NSString class]</code>；第二行调用是错误的，<code>NSArray *</code> 类型的属性 <code>myArray</code> 调用时传入的是 <code>[NSString class]</code>。也就是说，在 Objective-C 语言中，并没有一种办法能够检查函数调用时参数类型和返回值类型是完全一致的。</p>\n<p>这个需求是从我所在公司的项目中抽象简化出来的，大家看不出来这个函数究竟是用来干什么的，可能会觉得这个需求并不常见，没有什么通用性。但是这篇文章希望读者看了之后能以小见大，举一反三，更重要的是学到怎么样使用通用的方式，根据自己的需求实现自定义检查规范的 Clang 插件。</p>\n<h3 id=\"最终效果\"><a href=\"#最终效果\" class=\"headerlink\" title=\"最终效果\"></a>最终效果</h3><p>我们来看看最终实现的效果：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/698554-c7aa746724799734.GIF?imageMogr2/auto-orient/strip\" alt=\"演示效果\"></p>\n<p>最终实现了上面所说的类型检查，同时还给出了对应的修改方法（FixIt），点击修改就能改成正确的参数类型🎉🎉🎉 下面就来说说具体是怎么实现的。</p>\n<h3 id=\"抽象语法树（Abstract-syntax-tree）\"><a href=\"#抽象语法树（Abstract-syntax-tree）\" class=\"headerlink\" title=\"抽象语法树（Abstract syntax tree）\"></a>抽象语法树（Abstract syntax tree）</h3><p>抽象语法树，英文简称为 AST，是编译过程中语法分析阶段的产物，也是我们作为外部开发者与 Clang 进行交互的最重要的方式。所以我们最重要的就是学会怎么样阅读、分析语法树。</p>\n<p>在命令行中输入以下命令，打印 main.m 文件对应的语法树到命令行中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.3.sdk -fmodules -fsyntax-only -Xclang -ast-dump main.m</div></pre></td></tr></table></figure>\n<blockquote>\n<p>在我写这篇文章时 Xcode 版本是9.3，对应的是 iPhoneSimulator11.3.sdk，你需要进入该目录查看你的 sdk 版本，然后修改 -isysroot 命令后的 sdk 路径</p>\n</blockquote>\n<p>打印出来的语法树如下图：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/698554-f509375dfc159afe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"AST\"></p>\n<p>编译前端 Clang 首先进行词法分析（Lexical Analysis），把源文件的字符流拆分一个一个的 token；然后 token 进入语法分析（Semantic Analysis），将这些 token 组合成语法树。左边的缩进代表了语法树节点的从属关系，语法树上的每一个节点的名字都能在 Clang 源码中找到对应的类。</p>\n<p>从图中挑几个点来解释一下（对应图中的红色标注）：</p>\n<ol>\n<li><p><code>ObjCImplementationDecl</code> 节点代表了 Objective-C 类中的 <code>@implementation</code> 部分的内容</p>\n</li>\n<li><p><code>ObjCMethodDecl</code> 节点代表了 Objective-C 中的函数定义，我们在 Clang 源码中查看一下对应类的定义</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/698554-3ece97359f29ec5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"ObjCMethodDecl\"></p>\n<p>Clang 的文档注释可以说相当齐全了，<code>ObjCMethodDecl</code>  代表了一个类方法或者实例方法。所有的 <code>public:</code> 域中的方法都是我们可以用的，比如说  <code>Selector getSelector()</code> 可以获取该方法的 <code>Selector</code>，<code>ArrayRef&lt;ParmVarDecl*&gt; parameters()</code> 可以获取获取该方法的参数列表等等。</p>\n</li>\n<li><p>框中的语法块代表了源文件中 <code>self.myString = [self modelOfClass:[NSString class]];</code> 语句，<code>BinaryOperator</code> 代表了二元操作符（包括赋值的“=”），可以通过 <code>BinaryOperator</code> 类的 <code>Expr *getLHS()</code> 和 <code>Expr *getRHS()</code> 分别取得“=”左右两边的语句。</p>\n</li>\n</ol>\n<blockquote>\n<p>详细的 AST 树的分析可以查看官方的教程：<a href=\"http://clang.llvm.org/docs/IntroductionToTheClangAST.html\">http://clang.llvm.org/docs/IntroductionToTheClangAST.html</a></p>\n</blockquote>\n<p>那么多种的 AST 节点中应该怎么只获取自己感兴趣的节点呢？</p>\n<p>Clang 提供了 <code>ASTMatcher</code> 类供我们进行 AST 节点的查找过滤，有一篇专门解释罗列各种各样的 <code>ASTMatcher</code> 的<a href=\"http://clang.llvm.org/docs/LibASTMatchersReference.html\">官方文档</a>可以查看。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/698554-71f15a143a85a6e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"ASTMatcher\"></p>\n<p>比如可以用 <code>objcPropertyDecl</code> 来匹配到 Objective-C 的类属性，<code>ASTMatcher</code> 可以用一种类似链式语法的方式将一系列的 Matcher 串起来，比如可以用 <code>cxxRecordDecl(unless(hasName(&quot;X&quot;)))</code> 来匹配到满足类名不为 <code>X</code> 的所有 C++ 类。</p>\n<blockquote>\n<p>具体的 ASTMatcher 的使用方法可以查看这篇教程：<a href=\"https://eli.thegreenplace.net/2014/07/29/ast-matchers-and-clang-refactoring-tools\">https://eli.thegreenplace.net/2014/07/29/ast-matchers-and-clang-refactoring-tools</a></p>\n</blockquote>\n<h3 id=\"实现思路\"><a href=\"#实现思路\" class=\"headerlink\" title=\"实现思路\"></a>实现思路</h3><p>基础知识铺垫完了，现在我们来拆解一下我们的需求。首先我们需要有一种方式标记需要进行这种检查的函数，总不至于所有函数调用我们都去检查一遍吧😹 这时候就可以想到可以通过 attribute 的方式标记函数！</p>\n<blockquote>\n<p>关于 attribute 的知识，可以查看孙源大神的这篇文章：<a href=\"https://blog.sunnyxx.com/2016/05/14/clang-attributes/\">Clang Attributes 黑魔法小记</a>，讲解了多种常见不常见的 attribute 的使用场景</p>\n<p>另外一篇就是官方关于如何在 Clang 中添加自定义的 attribute 的文档：<a href=\"https://clang.llvm.org/docs/InternalsManual.html#how-to-add-an-attribute\">How to add an attribute</a>，我自己也翻译了这篇文档，请戳<a href=\"https://www.jianshu.com/p/d277c42f4907\">中文版</a>。</p>\n</blockquote>\n<p>这里不讲解怎么添加自定义的 attribute，比较简单，就是按最简单的模板添加的。添加完了之后，得在 <code>modelOfClass</code> 后面加上一句 <code>__attribute__((objc_same_type))</code>，代表 <code>modelOfClass</code> 在每次被调用时都会进行自定义的检查，这样才能出现上面演示效果图中的检查结果（objc_same_type 就是我所添加的 attribute 的名字）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (__kindof NSObject *)modelOfClass:(Class)modelClass __attribute__((objc_same_type))</div></pre></td></tr></table></figure>\n<p>#### </p>\n<p>具体该怎么检查呢？分成以下几个步骤：</p>\n<ol>\n<li>首先判断语法树上的节点是否是赋值语句（Clang 中用 <code>BinaryOperator</code> 表征赋值语句）。如果是，进入第 2 步</li>\n<li>用 <code>BinaryOperator</code> 的 <code>getLHS()</code> 、<code>getRHS()</code> 函数分别获得左右的表达式</li>\n<li>如果左边表达式是 Objective-C 类的属性的话，获取该属性对应的类型 A。进入第 4 步</li>\n<li>如果右边表达式是 Objective-C 的函数调用，且被调用的函数是有我们上面所定义 <strong>attribute</strong>((objc_same_type)) 的话（可以通过 <code>ObjCMethodDecl</code> 的 <code>attrs()</code> 方法获得 Objective-C 函数的所有的 attribute），获取该函数的参数对应的类型 B</li>\n<li>对比 A 和 B 的类型是否一致，如果不一致，则弹出类型不一致的编译警告，并提出恰当的修改方法（如效果演示图所示）</li>\n</ol>\n<blockquote>\n<p>具体的实现代码和使用方法查看 Github：<a href=\"https://github.com/VernonVan/SameTypeClangPlugin\">https://github.com/VernonVan/SameTypeClangPlugin</a></p>\n</blockquote>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>最终花了不到 200 行代码就完成了这个小小的功能，但是却花了我将近一个月的业余时间，中间也做了很多无用功，在错误的道路上走了一段时间才发现自己做的完全是错的，幸好最后还是成功找到了正确的方法。不过，自己也收获了很多的技能点，比如说阅读源码的能力，得益于 LLVM 良好的代码设计和模块化，让我一个门外汉也能比较快速的从庞大的代码中找到自己想要的部分；比如说 CMake 构建工程的知识、C++ 语言以及查找阅读英文文档的能力。收获还是比较多的🍹🍹🍹</p>\n<p>接下来如果在 LLVM &amp;&amp; Clang 这一块有其他的所得的话，会再撰文分享~</p>\n"},{"title":"PPRoundedAvatar--高性能的异步裁剪圆角头像控件","date":"2017-04-01T10:09:16.000Z","_content":"\n## 起因\n\n最近的开发任务是进行性能优化，主要是提升列表（UITableView）的滚动流畅性。  \n\n在完成了提前算高、子视图层级优化几个优化步骤之后，滚动的流畅性已经有了明显的提升，平均的帧速率（fps）已经从优化之前49提高到了55。接下来通过 Instruments 的 Time Profile 工具分析，发现圆角头像的裁剪竟然占去了20%+的用户运行时间！图片的处理需要 GPU 和 CPU 的配合，本来就需要大量的处理时间，这本无可厚非。但是这么重的任务都派发到主线程肯定是会造成界面的卡顿的，而且圆角头像在项目中的使用星罗棋布，很多界面中都用到了这个控件，所以呢，对圆角头像的优化就很有必要了。  \n\n\n\n## 经过\n优化性能，无非是将主线程从繁重的任务中解放出来，将能在后台线程完成的任务都派发到后台线程中。这里选用 NSOperation 进行多线程处理，因为 CoreGraphics 都是线程安全的，于是把图片处理（裁圆角/加边框）的过程都在后台线程中执行好，再在主线程设置图片。接下来说一下核心的技术点：\n\n### 图片处理\n我将图片裁剪的过程封装并暴露了两个便利接口，默认的 - (nullable UIImage *)pp_imageByRoundCornerRadius: scaleSize: 会先将图片缩放到scaleSize的大小，再添加上圆角（注意默认的方法是没有边框的），另一个接口 - (nullable UIImage *)pp_imageByRoundCornerRadius: scaleSize: borderWidth: borderColor: 则可以在默认方法的基础上设置边框颜色和边框的宽度。这里没有新建一个专门的处理类，而是拓展了 UIImage 类，具体的头文件如下：\n```objective-c\n@interface UIImage (PPRoundedAvatar)\n/**\n 将图片进行圆角处理，默认无边框\n */\n- (nullable UIImage *)pp_imageByRoundCornerRadius:(CGFloat)radius\n                                        scaleSize:(CGSize)newSize;\n\n/**\n 将图片进行圆角处理，并加上边框\n */\n- (nullable UIImage *)pp_imageByRoundCornerRadius:(CGFloat)radius\n                                        scaleSize:(CGSize)newSize\n                                      borderWidth:(CGFloat)borderWidth\n                                      borderColor:(nullable UIColor *)borderColor;\n\n/**\n 图片加上圆形边框，图片必须得是正方形的，否则直接返回未加边框的原图片\n */\n- (nullable UIImage *)pp_imageByRoundBorderedColor:(nullable UIColor *)color\n                                       borderWidth:(CGFloat)width;\n\n@end\n```\n图片进行圆角裁剪和加上边框主要还是采用 CoreGraphics 和 UIBezierPath 的方法，这里按下不表。值得注意的是处理的顺序应该是**先缩放图片，再进行裁剪**，不然边框的宽度会因为缩放而改变。\n```objective-c\n// 图片圆角裁剪\n- (UIImage *)pp_imageByRoundCornerRadius:(CGFloat)radius\n                             borderWidth:(CGFloat)borderWidth\n                             borderColor:(UIColor *)borderColor\n{\n    UIImage *scaledImage = [self pp_imageScaledAspectToFillSize:newSize];  // 缩放图片\n    UIGraphicsBeginImageContextWithOptions(scaledImage.size, NO, 0);\n    CGContextRef context = UIGraphicsGetCurrentContext();\n    CGRect rect = CGRectMake(0, 0, scaledImage.size.width, scaledImage.size.height);\n    CGContextScaleCTM(context, 1, -1);\n    CGContextTranslateCTM(context, 0, -rect.size.height);\n    \n    CGFloat minSize = MIN(scaledImage.size.width, scaledImage.size.height);\n    if (borderWidth < minSize / 2) {\n        UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectInset(rect, borderWidth, borderWidth) byRoundingCorners:corners cornerRadii:CGSizeMake(radius, borderWidth)];\n        CGContextSaveGState(context);\n        [path addClip];\n        CGContextDrawImage(context, rect, scaledImage.CGImage);\n        CGContextRestoreGState(context);\n    }\n    \n    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();\n    image = [image pp_imageByRoundBorderedColor:borderColor borderWidth:borderWidth];   \t// 加上边框\n    UIGraphicsEndImageContext();\n    return image;\n}\n\n// 图片加边框\n- (UIImage *)pp_imageByRoundBorderedColor:(UIColor *)borderColor\n                              borderWidth:(CGFloat)borderWidth\n{\n    if (self.size.height != self.size.width) {\n        return self;\n    }\n    \n    if (!borderColor || borderWidth > self.size.width / 2 || borderWidth < 0) {\n        return self;\n    }\n    \n    UIGraphicsBeginImageContextWithOptions(self.size, NO, 0);\n    [self drawAtPoint:CGPointZero];\n    CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);\n    CGFloat strokeInset = borderWidth / 2;\n    CGRect strokeRect = CGRectInset(rect, strokeInset, strokeInset);\n    CGFloat radius = self.size.width / 2;\n    UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:strokeRect byRoundingCorners:UIRectCornerAllCorners cornerRadii:CGSizeMake(radius, borderWidth)];\n    path.lineWidth = borderWidth;\n    [borderColor setStroke];\n    [path stroke];\n    UIImage *result = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n    return result;\n}\n```\n\n### 圆角头像控件\n这里采用 NSOperation + NSOperationQueue 的方式进行多线程处理，在图片、边框等属性的 set 方法里调用 setNeedsLayout 方法刷新布局，同时设置 _isNeedTransform 标记位为 YES，表示需要刷新，可以提高性能。\n```objective-c\n- (void)setAvatarImage:(UIImage *)avatarImage\n{\n    if (_avatarImage != avatarImage) {\n        _avatarImage = avatarImage;\n        \n        _isNeedTransform = YES;      // 需要刷新的标识\n        [self setNeedsLayout];\n    }\n}\n\n- (void)setBorderHidden:(BOOL)borderHidden\n{\n    if (_borderHidden != borderHidden) {\n        _borderHidden = borderHidden;\n        \n        _isNeedTransform = YES;\t\t// 需要刷新的标识\n        [self setNeedsLayout];\n    }\n}\n\n+ (NSOperationQueue *)sharedTransformQueue\n{\n    static NSOperationQueue *transformQueue;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        transformQueue = [[NSOperationQueue alloc] init];\n        transformQueue.name = @\"io.github.vernonvan.PPRoundedAvatar.sharedOperationQueue\";\n        transformQueue.maxConcurrentOperationCount = 20;\n    });\n    return transformQueue;\n}\n\n- (void)layoutSubviews\n{\n    [super layoutSubviews];\n    \n    if (!self.avatarImage && !self.imageBackgroundColor) {\n        return;\n    }\n    \n    if (self.bounds.size.width <= 0 || self.bounds.size.height <= 0) {\n        return;\n    }\n\n    if (_isNeedTransform || !CGSizeEqualToSize(self.bounds.size, self.imageView.image.size)) {\n        [self transformImage];\n    }\n}\n\n- (void)transformImage\n{\n    UIImage *startImage = self.avatarImage;\n    \n    NSBlockOperation *transformOperation = [[NSBlockOperation alloc] init];\n    __weak NSBlockOperation *weakTransformOperation = transformOperation;\n    [transformOperation addExecutionBlock:^{\n        NSBlockOperation *strongTransformOperation = weakTransformOperation;\n        \n        if ([strongTransformOperation isCancelled]) {\n            return;\n        }\n        \n        UIImage *transformedImage = nil;\n        if (self.avatarImage) {\n            transformedImage = [self.avatarImage pp_imageByRoundCornerRadius:self.bounds.size.width scaleSize:self.bounds.size];\n        } else if (self.imageBackgroundColor) {\n            transformedImage = [UIImage pp_roundImageWithColor:self.imageBackgroundColor radius:self.bounds.size.width / 2];\n        }\n        \n        if (!self.borderHidden) {\n            transformedImage = [transformedImage pp_imageByRoundBorderedColor:self.borderColor borderWidth:self.borderWidth];\n        }\n        \n        dispatch_async(dispatch_get_main_queue(), ^{\n            if ([strongTransformOperation isCancelled]) {\n                return;\n            }\n            if (self.avatarImage == startImage) {  // 1\n                _isNeedTransform = NO;\n                [self setImage:transformedImage forState:UIControlStateNormal];\n            }\n        });\n    }];\n    \n    [[self.class sharedTransformQueue] addOperation:transformOperation];\n}\n```\n在上面有一个标注了1的注释点，这里的条件判断是为了避免多线程时序性的问题而加的。考虑这样的一种常见情况：圆角头像控件是表格上的单元格（cell）上的子视图，某个 cell 被滑到屏幕上，于是开始头像的裁剪（这里将这个头像称为旧头像），然后在这个裁剪尚未完成的时候，这个 cell 被滑出了屏幕，然后根据新的图片裁剪圆角（这个头像称为新头像），可能出现新头像裁剪早于旧头像完成的情况，就会导致控件先设置头像为新头像，然后被慢悠悠才完成裁剪的旧头像覆盖的问题。所以这里用这个条件避免这个问题。\n\n\n\n## 结果\n将上述的操作都封装隐藏好，现在的圆角头像控件 **PPRoundedAvatar** 的使用就很简单了，\n```objective-c\nPPRoundedAvatar *avatar = [[PPRoundedAvatar alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];\navatar.avatarImage = [UIImage imageNamed:@\"example.png\"];       // 头像图片\navatar.borderWidth = 1.0;                                       // 边框宽度\navatar.borderColor = UIColor.blackColor;                        // 边框颜色\navatar.borderHidden = NO;                                       // 显示边框\navatar.imageBackgroundColor = UIColor.grayColor;                // 背景颜色\n[self.view addSubview:avatar];\n```\n具体的代码已经丢到了 [github](https://github.com/VernonVan/PPRoundedAvatar) 上了，同时支持 Cocoapods 导入项目。\n有需要的可以 clone 进行使用，也欢迎 pull request 完善这个控件。\n\n\n\n## 插叙\n技术上的问题就说到了这里，可是做一个开源项目不仅在技术上需要反复斟酌，而且在 github 的展示、demo 的展示等地方都需要有界面的设计，可苦了我这直男审美....../(ㄒoㄒ)/~~\n这也导致了我家又吉君实在是看不下去了，终于勇敢地站了出来帮我把界面的设计给做好了，当中的你来我往又是另外的[故事](https://vernonvan.github.io/2017/04/01/ruanpapa%E5%92%8C%E5%8F%88%E5%90%89%E5%90%9B%E7%9A%84%E6%97%A5%E5%B8%B8%E4%B9%8B%E4%B8%80/)。真的是对我家又吉君感激涕零~~~\n呐，又吉君，你帮我画一辈子设计好不好吖，我带你去吃鸡锁骨、卷饼、酱香饼、枣糕还有烤冷面哦~哈哈哈哈啊哈哈哈","source":"_posts/PPRoundedAvatar-高性能的异步裁剪圆角头像控件.md","raw":"---\ntitle: PPRoundedAvatar--高性能的异步裁剪圆角头像控件\ndate: 2017-04-01 18:09:16\ntags:\n- iOS\n- Objective-C\ncategories:\n- ruanpapa--技术贴\n---\n\n## 起因\n\n最近的开发任务是进行性能优化，主要是提升列表（UITableView）的滚动流畅性。  \n\n在完成了提前算高、子视图层级优化几个优化步骤之后，滚动的流畅性已经有了明显的提升，平均的帧速率（fps）已经从优化之前49提高到了55。接下来通过 Instruments 的 Time Profile 工具分析，发现圆角头像的裁剪竟然占去了20%+的用户运行时间！图片的处理需要 GPU 和 CPU 的配合，本来就需要大量的处理时间，这本无可厚非。但是这么重的任务都派发到主线程肯定是会造成界面的卡顿的，而且圆角头像在项目中的使用星罗棋布，很多界面中都用到了这个控件，所以呢，对圆角头像的优化就很有必要了。  \n\n\n\n## 经过\n优化性能，无非是将主线程从繁重的任务中解放出来，将能在后台线程完成的任务都派发到后台线程中。这里选用 NSOperation 进行多线程处理，因为 CoreGraphics 都是线程安全的，于是把图片处理（裁圆角/加边框）的过程都在后台线程中执行好，再在主线程设置图片。接下来说一下核心的技术点：\n\n### 图片处理\n我将图片裁剪的过程封装并暴露了两个便利接口，默认的 - (nullable UIImage *)pp_imageByRoundCornerRadius: scaleSize: 会先将图片缩放到scaleSize的大小，再添加上圆角（注意默认的方法是没有边框的），另一个接口 - (nullable UIImage *)pp_imageByRoundCornerRadius: scaleSize: borderWidth: borderColor: 则可以在默认方法的基础上设置边框颜色和边框的宽度。这里没有新建一个专门的处理类，而是拓展了 UIImage 类，具体的头文件如下：\n```objective-c\n@interface UIImage (PPRoundedAvatar)\n/**\n 将图片进行圆角处理，默认无边框\n */\n- (nullable UIImage *)pp_imageByRoundCornerRadius:(CGFloat)radius\n                                        scaleSize:(CGSize)newSize;\n\n/**\n 将图片进行圆角处理，并加上边框\n */\n- (nullable UIImage *)pp_imageByRoundCornerRadius:(CGFloat)radius\n                                        scaleSize:(CGSize)newSize\n                                      borderWidth:(CGFloat)borderWidth\n                                      borderColor:(nullable UIColor *)borderColor;\n\n/**\n 图片加上圆形边框，图片必须得是正方形的，否则直接返回未加边框的原图片\n */\n- (nullable UIImage *)pp_imageByRoundBorderedColor:(nullable UIColor *)color\n                                       borderWidth:(CGFloat)width;\n\n@end\n```\n图片进行圆角裁剪和加上边框主要还是采用 CoreGraphics 和 UIBezierPath 的方法，这里按下不表。值得注意的是处理的顺序应该是**先缩放图片，再进行裁剪**，不然边框的宽度会因为缩放而改变。\n```objective-c\n// 图片圆角裁剪\n- (UIImage *)pp_imageByRoundCornerRadius:(CGFloat)radius\n                             borderWidth:(CGFloat)borderWidth\n                             borderColor:(UIColor *)borderColor\n{\n    UIImage *scaledImage = [self pp_imageScaledAspectToFillSize:newSize];  // 缩放图片\n    UIGraphicsBeginImageContextWithOptions(scaledImage.size, NO, 0);\n    CGContextRef context = UIGraphicsGetCurrentContext();\n    CGRect rect = CGRectMake(0, 0, scaledImage.size.width, scaledImage.size.height);\n    CGContextScaleCTM(context, 1, -1);\n    CGContextTranslateCTM(context, 0, -rect.size.height);\n    \n    CGFloat minSize = MIN(scaledImage.size.width, scaledImage.size.height);\n    if (borderWidth < minSize / 2) {\n        UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectInset(rect, borderWidth, borderWidth) byRoundingCorners:corners cornerRadii:CGSizeMake(radius, borderWidth)];\n        CGContextSaveGState(context);\n        [path addClip];\n        CGContextDrawImage(context, rect, scaledImage.CGImage);\n        CGContextRestoreGState(context);\n    }\n    \n    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();\n    image = [image pp_imageByRoundBorderedColor:borderColor borderWidth:borderWidth];   \t// 加上边框\n    UIGraphicsEndImageContext();\n    return image;\n}\n\n// 图片加边框\n- (UIImage *)pp_imageByRoundBorderedColor:(UIColor *)borderColor\n                              borderWidth:(CGFloat)borderWidth\n{\n    if (self.size.height != self.size.width) {\n        return self;\n    }\n    \n    if (!borderColor || borderWidth > self.size.width / 2 || borderWidth < 0) {\n        return self;\n    }\n    \n    UIGraphicsBeginImageContextWithOptions(self.size, NO, 0);\n    [self drawAtPoint:CGPointZero];\n    CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);\n    CGFloat strokeInset = borderWidth / 2;\n    CGRect strokeRect = CGRectInset(rect, strokeInset, strokeInset);\n    CGFloat radius = self.size.width / 2;\n    UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:strokeRect byRoundingCorners:UIRectCornerAllCorners cornerRadii:CGSizeMake(radius, borderWidth)];\n    path.lineWidth = borderWidth;\n    [borderColor setStroke];\n    [path stroke];\n    UIImage *result = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n    return result;\n}\n```\n\n### 圆角头像控件\n这里采用 NSOperation + NSOperationQueue 的方式进行多线程处理，在图片、边框等属性的 set 方法里调用 setNeedsLayout 方法刷新布局，同时设置 _isNeedTransform 标记位为 YES，表示需要刷新，可以提高性能。\n```objective-c\n- (void)setAvatarImage:(UIImage *)avatarImage\n{\n    if (_avatarImage != avatarImage) {\n        _avatarImage = avatarImage;\n        \n        _isNeedTransform = YES;      // 需要刷新的标识\n        [self setNeedsLayout];\n    }\n}\n\n- (void)setBorderHidden:(BOOL)borderHidden\n{\n    if (_borderHidden != borderHidden) {\n        _borderHidden = borderHidden;\n        \n        _isNeedTransform = YES;\t\t// 需要刷新的标识\n        [self setNeedsLayout];\n    }\n}\n\n+ (NSOperationQueue *)sharedTransformQueue\n{\n    static NSOperationQueue *transformQueue;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        transformQueue = [[NSOperationQueue alloc] init];\n        transformQueue.name = @\"io.github.vernonvan.PPRoundedAvatar.sharedOperationQueue\";\n        transformQueue.maxConcurrentOperationCount = 20;\n    });\n    return transformQueue;\n}\n\n- (void)layoutSubviews\n{\n    [super layoutSubviews];\n    \n    if (!self.avatarImage && !self.imageBackgroundColor) {\n        return;\n    }\n    \n    if (self.bounds.size.width <= 0 || self.bounds.size.height <= 0) {\n        return;\n    }\n\n    if (_isNeedTransform || !CGSizeEqualToSize(self.bounds.size, self.imageView.image.size)) {\n        [self transformImage];\n    }\n}\n\n- (void)transformImage\n{\n    UIImage *startImage = self.avatarImage;\n    \n    NSBlockOperation *transformOperation = [[NSBlockOperation alloc] init];\n    __weak NSBlockOperation *weakTransformOperation = transformOperation;\n    [transformOperation addExecutionBlock:^{\n        NSBlockOperation *strongTransformOperation = weakTransformOperation;\n        \n        if ([strongTransformOperation isCancelled]) {\n            return;\n        }\n        \n        UIImage *transformedImage = nil;\n        if (self.avatarImage) {\n            transformedImage = [self.avatarImage pp_imageByRoundCornerRadius:self.bounds.size.width scaleSize:self.bounds.size];\n        } else if (self.imageBackgroundColor) {\n            transformedImage = [UIImage pp_roundImageWithColor:self.imageBackgroundColor radius:self.bounds.size.width / 2];\n        }\n        \n        if (!self.borderHidden) {\n            transformedImage = [transformedImage pp_imageByRoundBorderedColor:self.borderColor borderWidth:self.borderWidth];\n        }\n        \n        dispatch_async(dispatch_get_main_queue(), ^{\n            if ([strongTransformOperation isCancelled]) {\n                return;\n            }\n            if (self.avatarImage == startImage) {  // 1\n                _isNeedTransform = NO;\n                [self setImage:transformedImage forState:UIControlStateNormal];\n            }\n        });\n    }];\n    \n    [[self.class sharedTransformQueue] addOperation:transformOperation];\n}\n```\n在上面有一个标注了1的注释点，这里的条件判断是为了避免多线程时序性的问题而加的。考虑这样的一种常见情况：圆角头像控件是表格上的单元格（cell）上的子视图，某个 cell 被滑到屏幕上，于是开始头像的裁剪（这里将这个头像称为旧头像），然后在这个裁剪尚未完成的时候，这个 cell 被滑出了屏幕，然后根据新的图片裁剪圆角（这个头像称为新头像），可能出现新头像裁剪早于旧头像完成的情况，就会导致控件先设置头像为新头像，然后被慢悠悠才完成裁剪的旧头像覆盖的问题。所以这里用这个条件避免这个问题。\n\n\n\n## 结果\n将上述的操作都封装隐藏好，现在的圆角头像控件 **PPRoundedAvatar** 的使用就很简单了，\n```objective-c\nPPRoundedAvatar *avatar = [[PPRoundedAvatar alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];\navatar.avatarImage = [UIImage imageNamed:@\"example.png\"];       // 头像图片\navatar.borderWidth = 1.0;                                       // 边框宽度\navatar.borderColor = UIColor.blackColor;                        // 边框颜色\navatar.borderHidden = NO;                                       // 显示边框\navatar.imageBackgroundColor = UIColor.grayColor;                // 背景颜色\n[self.view addSubview:avatar];\n```\n具体的代码已经丢到了 [github](https://github.com/VernonVan/PPRoundedAvatar) 上了，同时支持 Cocoapods 导入项目。\n有需要的可以 clone 进行使用，也欢迎 pull request 完善这个控件。\n\n\n\n## 插叙\n技术上的问题就说到了这里，可是做一个开源项目不仅在技术上需要反复斟酌，而且在 github 的展示、demo 的展示等地方都需要有界面的设计，可苦了我这直男审美....../(ㄒoㄒ)/~~\n这也导致了我家又吉君实在是看不下去了，终于勇敢地站了出来帮我把界面的设计给做好了，当中的你来我往又是另外的[故事](https://vernonvan.github.io/2017/04/01/ruanpapa%E5%92%8C%E5%8F%88%E5%90%89%E5%90%9B%E7%9A%84%E6%97%A5%E5%B8%B8%E4%B9%8B%E4%B8%80/)。真的是对我家又吉君感激涕零~~~\n呐，又吉君，你帮我画一辈子设计好不好吖，我带你去吃鸡锁骨、卷饼、酱香饼、枣糕还有烤冷面哦~哈哈哈哈啊哈哈哈","slug":"PPRoundedAvatar-高性能的异步裁剪圆角头像控件","published":1,"updated":"2017-04-05T11:21:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg4j8vyg000bvfwxmqdb7s2w","content":"<h2 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h2><p>最近的开发任务是进行性能优化，主要是提升列表（UITableView）的滚动流畅性。  </p>\n<p>在完成了提前算高、子视图层级优化几个优化步骤之后，滚动的流畅性已经有了明显的提升，平均的帧速率（fps）已经从优化之前49提高到了55。接下来通过 Instruments 的 Time Profile 工具分析，发现圆角头像的裁剪竟然占去了20%+的用户运行时间！图片的处理需要 GPU 和 CPU 的配合，本来就需要大量的处理时间，这本无可厚非。但是这么重的任务都派发到主线程肯定是会造成界面的卡顿的，而且圆角头像在项目中的使用星罗棋布，很多界面中都用到了这个控件，所以呢，对圆角头像的优化就很有必要了。  </p>\n<h2 id=\"经过\"><a href=\"#经过\" class=\"headerlink\" title=\"经过\"></a>经过</h2><p>优化性能，无非是将主线程从繁重的任务中解放出来，将能在后台线程完成的任务都派发到后台线程中。这里选用 NSOperation 进行多线程处理，因为 CoreGraphics 都是线程安全的，于是把图片处理（裁圆角/加边框）的过程都在后台线程中执行好，再在主线程设置图片。接下来说一下核心的技术点：</p>\n<h3 id=\"图片处理\"><a href=\"#图片处理\" class=\"headerlink\" title=\"图片处理\"></a>图片处理</h3><p>我将图片裁剪的过程封装并暴露了两个便利接口，默认的 - (nullable UIImage <em>)pp_imageByRoundCornerRadius: scaleSize: 会先将图片缩放到scaleSize的大小，再添加上圆角（注意默认的方法是没有边框的），另一个接口 - (nullable UIImage </em>)pp_imageByRoundCornerRadius: scaleSize: borderWidth: borderColor: 则可以在默认方法的基础上设置边框颜色和边框的宽度。这里没有新建一个专门的处理类，而是拓展了 UIImage 类，具体的头文件如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface UIImage (PPRoundedAvatar)</div><div class=\"line\">/**</div><div class=\"line\"> 将图片进行圆角处理，默认无边框</div><div class=\"line\"> */</div><div class=\"line\">- (nullable UIImage *)pp_imageByRoundCornerRadius:(CGFloat)radius</div><div class=\"line\">                                        scaleSize:(CGSize)newSize;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> 将图片进行圆角处理，并加上边框</div><div class=\"line\"> */</div><div class=\"line\">- (nullable UIImage *)pp_imageByRoundCornerRadius:(CGFloat)radius</div><div class=\"line\">                                        scaleSize:(CGSize)newSize</div><div class=\"line\">                                      borderWidth:(CGFloat)borderWidth</div><div class=\"line\">                                      borderColor:(nullable UIColor *)borderColor;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> 图片加上圆形边框，图片必须得是正方形的，否则直接返回未加边框的原图片</div><div class=\"line\"> */</div><div class=\"line\">- (nullable UIImage *)pp_imageByRoundBorderedColor:(nullable UIColor *)color</div><div class=\"line\">                                       borderWidth:(CGFloat)width;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>图片进行圆角裁剪和加上边框主要还是采用 CoreGraphics 和 UIBezierPath 的方法，这里按下不表。值得注意的是处理的顺序应该是<strong>先缩放图片，再进行裁剪</strong>，不然边框的宽度会因为缩放而改变。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 图片圆角裁剪</div><div class=\"line\">- (UIImage *)pp_imageByRoundCornerRadius:(CGFloat)radius</div><div class=\"line\">                             borderWidth:(CGFloat)borderWidth</div><div class=\"line\">                             borderColor:(UIColor *)borderColor</div><div class=\"line\">&#123;</div><div class=\"line\">    UIImage *scaledImage = [self pp_imageScaledAspectToFillSize:newSize];  // 缩放图片</div><div class=\"line\">    UIGraphicsBeginImageContextWithOptions(scaledImage.size, NO, 0);</div><div class=\"line\">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class=\"line\">    CGRect rect = CGRectMake(0, 0, scaledImage.size.width, scaledImage.size.height);</div><div class=\"line\">    CGContextScaleCTM(context, 1, -1);</div><div class=\"line\">    CGContextTranslateCTM(context, 0, -rect.size.height);</div><div class=\"line\">    </div><div class=\"line\">    CGFloat minSize = MIN(scaledImage.size.width, scaledImage.size.height);</div><div class=\"line\">    if (borderWidth &lt; minSize / 2) &#123;</div><div class=\"line\">        UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectInset(rect, borderWidth, borderWidth) byRoundingCorners:corners cornerRadii:CGSizeMake(radius, borderWidth)];</div><div class=\"line\">        CGContextSaveGState(context);</div><div class=\"line\">        [path addClip];</div><div class=\"line\">        CGContextDrawImage(context, rect, scaledImage.CGImage);</div><div class=\"line\">        CGContextRestoreGState(context);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</div><div class=\"line\">    image = [image pp_imageByRoundBorderedColor:borderColor borderWidth:borderWidth];   \t// 加上边框</div><div class=\"line\">    UIGraphicsEndImageContext();</div><div class=\"line\">    return image;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 图片加边框</div><div class=\"line\">- (UIImage *)pp_imageByRoundBorderedColor:(UIColor *)borderColor</div><div class=\"line\">                              borderWidth:(CGFloat)borderWidth</div><div class=\"line\">&#123;</div><div class=\"line\">    if (self.size.height != self.size.width) &#123;</div><div class=\"line\">        return self;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    if (!borderColor || borderWidth &gt; self.size.width / 2 || borderWidth &lt; 0) &#123;</div><div class=\"line\">        return self;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    UIGraphicsBeginImageContextWithOptions(self.size, NO, 0);</div><div class=\"line\">    [self drawAtPoint:CGPointZero];</div><div class=\"line\">    CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);</div><div class=\"line\">    CGFloat strokeInset = borderWidth / 2;</div><div class=\"line\">    CGRect strokeRect = CGRectInset(rect, strokeInset, strokeInset);</div><div class=\"line\">    CGFloat radius = self.size.width / 2;</div><div class=\"line\">    UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:strokeRect byRoundingCorners:UIRectCornerAllCorners cornerRadii:CGSizeMake(radius, borderWidth)];</div><div class=\"line\">    path.lineWidth = borderWidth;</div><div class=\"line\">    [borderColor setStroke];</div><div class=\"line\">    [path stroke];</div><div class=\"line\">    UIImage *result = UIGraphicsGetImageFromCurrentImageContext();</div><div class=\"line\">    UIGraphicsEndImageContext();</div><div class=\"line\">    return result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"圆角头像控件\"><a href=\"#圆角头像控件\" class=\"headerlink\" title=\"圆角头像控件\"></a>圆角头像控件</h3><p>这里采用 NSOperation + NSOperationQueue 的方式进行多线程处理，在图片、边框等属性的 set 方法里调用 setNeedsLayout 方法刷新布局，同时设置 _isNeedTransform 标记位为 YES，表示需要刷新，可以提高性能。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)setAvatarImage:(UIImage *)avatarImage</div><div class=\"line\">&#123;</div><div class=\"line\">    if (_avatarImage != avatarImage) &#123;</div><div class=\"line\">        _avatarImage = avatarImage;</div><div class=\"line\">        </div><div class=\"line\">        _isNeedTransform = YES;      // 需要刷新的标识</div><div class=\"line\">        [self setNeedsLayout];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)setBorderHidden:(BOOL)borderHidden</div><div class=\"line\">&#123;</div><div class=\"line\">    if (_borderHidden != borderHidden) &#123;</div><div class=\"line\">        _borderHidden = borderHidden;</div><div class=\"line\">        </div><div class=\"line\">        _isNeedTransform = YES;\t\t// 需要刷新的标识</div><div class=\"line\">        [self setNeedsLayout];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+ (NSOperationQueue *)sharedTransformQueue</div><div class=\"line\">&#123;</div><div class=\"line\">    static NSOperationQueue *transformQueue;</div><div class=\"line\">    static dispatch_once_t onceToken;</div><div class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">        transformQueue = [[NSOperationQueue alloc] init];</div><div class=\"line\">        transformQueue.name = @&quot;io.github.vernonvan.PPRoundedAvatar.sharedOperationQueue&quot;;</div><div class=\"line\">        transformQueue.maxConcurrentOperationCount = 20;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    return transformQueue;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)layoutSubviews</div><div class=\"line\">&#123;</div><div class=\"line\">    [super layoutSubviews];</div><div class=\"line\">    </div><div class=\"line\">    if (!self.avatarImage &amp;&amp; !self.imageBackgroundColor) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    if (self.bounds.size.width &lt;= 0 || self.bounds.size.height &lt;= 0) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (_isNeedTransform || !CGSizeEqualToSize(self.bounds.size, self.imageView.image.size)) &#123;</div><div class=\"line\">        [self transformImage];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)transformImage</div><div class=\"line\">&#123;</div><div class=\"line\">    UIImage *startImage = self.avatarImage;</div><div class=\"line\">    </div><div class=\"line\">    NSBlockOperation *transformOperation = [[NSBlockOperation alloc] init];</div><div class=\"line\">    __weak NSBlockOperation *weakTransformOperation = transformOperation;</div><div class=\"line\">    [transformOperation addExecutionBlock:^&#123;</div><div class=\"line\">        NSBlockOperation *strongTransformOperation = weakTransformOperation;</div><div class=\"line\">        </div><div class=\"line\">        if ([strongTransformOperation isCancelled]) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        UIImage *transformedImage = nil;</div><div class=\"line\">        if (self.avatarImage) &#123;</div><div class=\"line\">            transformedImage = [self.avatarImage pp_imageByRoundCornerRadius:self.bounds.size.width scaleSize:self.bounds.size];</div><div class=\"line\">        &#125; else if (self.imageBackgroundColor) &#123;</div><div class=\"line\">            transformedImage = [UIImage pp_roundImageWithColor:self.imageBackgroundColor radius:self.bounds.size.width / 2];</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        if (!self.borderHidden) &#123;</div><div class=\"line\">            transformedImage = [transformedImage pp_imageByRoundBorderedColor:self.borderColor borderWidth:self.borderWidth];</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">            if ([strongTransformOperation isCancelled]) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (self.avatarImage == startImage) &#123;  // 1</div><div class=\"line\">                _isNeedTransform = NO;</div><div class=\"line\">                [self setImage:transformedImage forState:UIControlStateNormal];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    </div><div class=\"line\">    [[self.class sharedTransformQueue] addOperation:transformOperation];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在上面有一个标注了1的注释点，这里的条件判断是为了避免多线程时序性的问题而加的。考虑这样的一种常见情况：圆角头像控件是表格上的单元格（cell）上的子视图，某个 cell 被滑到屏幕上，于是开始头像的裁剪（这里将这个头像称为旧头像），然后在这个裁剪尚未完成的时候，这个 cell 被滑出了屏幕，然后根据新的图片裁剪圆角（这个头像称为新头像），可能出现新头像裁剪早于旧头像完成的情况，就会导致控件先设置头像为新头像，然后被慢悠悠才完成裁剪的旧头像覆盖的问题。所以这里用这个条件避免这个问题。</p>\n<h2 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h2><p>将上述的操作都封装隐藏好，现在的圆角头像控件 <strong>PPRoundedAvatar</strong> 的使用就很简单了，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">PPRoundedAvatar *avatar = [[PPRoundedAvatar alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];</div><div class=\"line\">avatar.avatarImage = [UIImage imageNamed:@&quot;example.png&quot;];       // 头像图片</div><div class=\"line\">avatar.borderWidth = 1.0;                                       // 边框宽度</div><div class=\"line\">avatar.borderColor = UIColor.blackColor;                        // 边框颜色</div><div class=\"line\">avatar.borderHidden = NO;                                       // 显示边框</div><div class=\"line\">avatar.imageBackgroundColor = UIColor.grayColor;                // 背景颜色</div><div class=\"line\">[self.view addSubview:avatar];</div></pre></td></tr></table></figure></p>\n<p>具体的代码已经丢到了 <a href=\"https://github.com/VernonVan/PPRoundedAvatar\" target=\"_blank\" rel=\"external\">github</a> 上了，同时支持 Cocoapods 导入项目。<br>有需要的可以 clone 进行使用，也欢迎 pull request 完善这个控件。</p>\n<h2 id=\"插叙\"><a href=\"#插叙\" class=\"headerlink\" title=\"插叙\"></a>插叙</h2><p>技术上的问题就说到了这里，可是做一个开源项目不仅在技术上需要反复斟酌，而且在 github 的展示、demo 的展示等地方都需要有界面的设计，可苦了我这直男审美……/(ㄒoㄒ)/~~<br>这也导致了我家又吉君实在是看不下去了，终于勇敢地站了出来帮我把界面的设计给做好了，当中的你来我往又是另外的<a href=\"https://vernonvan.github.io/2017/04/01/ruanpapa%E5%92%8C%E5%8F%88%E5%90%89%E5%90%9B%E7%9A%84%E6%97%A5%E5%B8%B8%E4%B9%8B%E4%B8%80/\" target=\"_blank\" rel=\"external\">故事</a>。真的是对我家又吉君感激涕零~~~<br>呐，又吉君，你帮我画一辈子设计好不好吖，我带你去吃鸡锁骨、卷饼、酱香饼、枣糕还有烤冷面哦~哈哈哈哈啊哈哈哈</p>\n","excerpt":"","more":"<h2 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h2><p>最近的开发任务是进行性能优化，主要是提升列表（UITableView）的滚动流畅性。  </p>\n<p>在完成了提前算高、子视图层级优化几个优化步骤之后，滚动的流畅性已经有了明显的提升，平均的帧速率（fps）已经从优化之前49提高到了55。接下来通过 Instruments 的 Time Profile 工具分析，发现圆角头像的裁剪竟然占去了20%+的用户运行时间！图片的处理需要 GPU 和 CPU 的配合，本来就需要大量的处理时间，这本无可厚非。但是这么重的任务都派发到主线程肯定是会造成界面的卡顿的，而且圆角头像在项目中的使用星罗棋布，很多界面中都用到了这个控件，所以呢，对圆角头像的优化就很有必要了。  </p>\n<h2 id=\"经过\"><a href=\"#经过\" class=\"headerlink\" title=\"经过\"></a>经过</h2><p>优化性能，无非是将主线程从繁重的任务中解放出来，将能在后台线程完成的任务都派发到后台线程中。这里选用 NSOperation 进行多线程处理，因为 CoreGraphics 都是线程安全的，于是把图片处理（裁圆角/加边框）的过程都在后台线程中执行好，再在主线程设置图片。接下来说一下核心的技术点：</p>\n<h3 id=\"图片处理\"><a href=\"#图片处理\" class=\"headerlink\" title=\"图片处理\"></a>图片处理</h3><p>我将图片裁剪的过程封装并暴露了两个便利接口，默认的 - (nullable UIImage <em>)pp_imageByRoundCornerRadius: scaleSize: 会先将图片缩放到scaleSize的大小，再添加上圆角（注意默认的方法是没有边框的），另一个接口 - (nullable UIImage </em>)pp_imageByRoundCornerRadius: scaleSize: borderWidth: borderColor: 则可以在默认方法的基础上设置边框颜色和边框的宽度。这里没有新建一个专门的处理类，而是拓展了 UIImage 类，具体的头文件如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface UIImage (PPRoundedAvatar)</div><div class=\"line\">/**</div><div class=\"line\"> 将图片进行圆角处理，默认无边框</div><div class=\"line\"> */</div><div class=\"line\">- (nullable UIImage *)pp_imageByRoundCornerRadius:(CGFloat)radius</div><div class=\"line\">                                        scaleSize:(CGSize)newSize;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> 将图片进行圆角处理，并加上边框</div><div class=\"line\"> */</div><div class=\"line\">- (nullable UIImage *)pp_imageByRoundCornerRadius:(CGFloat)radius</div><div class=\"line\">                                        scaleSize:(CGSize)newSize</div><div class=\"line\">                                      borderWidth:(CGFloat)borderWidth</div><div class=\"line\">                                      borderColor:(nullable UIColor *)borderColor;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> 图片加上圆形边框，图片必须得是正方形的，否则直接返回未加边框的原图片</div><div class=\"line\"> */</div><div class=\"line\">- (nullable UIImage *)pp_imageByRoundBorderedColor:(nullable UIColor *)color</div><div class=\"line\">                                       borderWidth:(CGFloat)width;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>图片进行圆角裁剪和加上边框主要还是采用 CoreGraphics 和 UIBezierPath 的方法，这里按下不表。值得注意的是处理的顺序应该是<strong>先缩放图片，再进行裁剪</strong>，不然边框的宽度会因为缩放而改变。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 图片圆角裁剪</div><div class=\"line\">- (UIImage *)pp_imageByRoundCornerRadius:(CGFloat)radius</div><div class=\"line\">                             borderWidth:(CGFloat)borderWidth</div><div class=\"line\">                             borderColor:(UIColor *)borderColor</div><div class=\"line\">&#123;</div><div class=\"line\">    UIImage *scaledImage = [self pp_imageScaledAspectToFillSize:newSize];  // 缩放图片</div><div class=\"line\">    UIGraphicsBeginImageContextWithOptions(scaledImage.size, NO, 0);</div><div class=\"line\">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class=\"line\">    CGRect rect = CGRectMake(0, 0, scaledImage.size.width, scaledImage.size.height);</div><div class=\"line\">    CGContextScaleCTM(context, 1, -1);</div><div class=\"line\">    CGContextTranslateCTM(context, 0, -rect.size.height);</div><div class=\"line\">    </div><div class=\"line\">    CGFloat minSize = MIN(scaledImage.size.width, scaledImage.size.height);</div><div class=\"line\">    if (borderWidth &lt; minSize / 2) &#123;</div><div class=\"line\">        UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectInset(rect, borderWidth, borderWidth) byRoundingCorners:corners cornerRadii:CGSizeMake(radius, borderWidth)];</div><div class=\"line\">        CGContextSaveGState(context);</div><div class=\"line\">        [path addClip];</div><div class=\"line\">        CGContextDrawImage(context, rect, scaledImage.CGImage);</div><div class=\"line\">        CGContextRestoreGState(context);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</div><div class=\"line\">    image = [image pp_imageByRoundBorderedColor:borderColor borderWidth:borderWidth];   \t// 加上边框</div><div class=\"line\">    UIGraphicsEndImageContext();</div><div class=\"line\">    return image;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 图片加边框</div><div class=\"line\">- (UIImage *)pp_imageByRoundBorderedColor:(UIColor *)borderColor</div><div class=\"line\">                              borderWidth:(CGFloat)borderWidth</div><div class=\"line\">&#123;</div><div class=\"line\">    if (self.size.height != self.size.width) &#123;</div><div class=\"line\">        return self;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    if (!borderColor || borderWidth &gt; self.size.width / 2 || borderWidth &lt; 0) &#123;</div><div class=\"line\">        return self;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    UIGraphicsBeginImageContextWithOptions(self.size, NO, 0);</div><div class=\"line\">    [self drawAtPoint:CGPointZero];</div><div class=\"line\">    CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);</div><div class=\"line\">    CGFloat strokeInset = borderWidth / 2;</div><div class=\"line\">    CGRect strokeRect = CGRectInset(rect, strokeInset, strokeInset);</div><div class=\"line\">    CGFloat radius = self.size.width / 2;</div><div class=\"line\">    UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:strokeRect byRoundingCorners:UIRectCornerAllCorners cornerRadii:CGSizeMake(radius, borderWidth)];</div><div class=\"line\">    path.lineWidth = borderWidth;</div><div class=\"line\">    [borderColor setStroke];</div><div class=\"line\">    [path stroke];</div><div class=\"line\">    UIImage *result = UIGraphicsGetImageFromCurrentImageContext();</div><div class=\"line\">    UIGraphicsEndImageContext();</div><div class=\"line\">    return result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"圆角头像控件\"><a href=\"#圆角头像控件\" class=\"headerlink\" title=\"圆角头像控件\"></a>圆角头像控件</h3><p>这里采用 NSOperation + NSOperationQueue 的方式进行多线程处理，在图片、边框等属性的 set 方法里调用 setNeedsLayout 方法刷新布局，同时设置 _isNeedTransform 标记位为 YES，表示需要刷新，可以提高性能。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)setAvatarImage:(UIImage *)avatarImage</div><div class=\"line\">&#123;</div><div class=\"line\">    if (_avatarImage != avatarImage) &#123;</div><div class=\"line\">        _avatarImage = avatarImage;</div><div class=\"line\">        </div><div class=\"line\">        _isNeedTransform = YES;      // 需要刷新的标识</div><div class=\"line\">        [self setNeedsLayout];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)setBorderHidden:(BOOL)borderHidden</div><div class=\"line\">&#123;</div><div class=\"line\">    if (_borderHidden != borderHidden) &#123;</div><div class=\"line\">        _borderHidden = borderHidden;</div><div class=\"line\">        </div><div class=\"line\">        _isNeedTransform = YES;\t\t// 需要刷新的标识</div><div class=\"line\">        [self setNeedsLayout];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+ (NSOperationQueue *)sharedTransformQueue</div><div class=\"line\">&#123;</div><div class=\"line\">    static NSOperationQueue *transformQueue;</div><div class=\"line\">    static dispatch_once_t onceToken;</div><div class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">        transformQueue = [[NSOperationQueue alloc] init];</div><div class=\"line\">        transformQueue.name = @&quot;io.github.vernonvan.PPRoundedAvatar.sharedOperationQueue&quot;;</div><div class=\"line\">        transformQueue.maxConcurrentOperationCount = 20;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    return transformQueue;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)layoutSubviews</div><div class=\"line\">&#123;</div><div class=\"line\">    [super layoutSubviews];</div><div class=\"line\">    </div><div class=\"line\">    if (!self.avatarImage &amp;&amp; !self.imageBackgroundColor) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    if (self.bounds.size.width &lt;= 0 || self.bounds.size.height &lt;= 0) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (_isNeedTransform || !CGSizeEqualToSize(self.bounds.size, self.imageView.image.size)) &#123;</div><div class=\"line\">        [self transformImage];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)transformImage</div><div class=\"line\">&#123;</div><div class=\"line\">    UIImage *startImage = self.avatarImage;</div><div class=\"line\">    </div><div class=\"line\">    NSBlockOperation *transformOperation = [[NSBlockOperation alloc] init];</div><div class=\"line\">    __weak NSBlockOperation *weakTransformOperation = transformOperation;</div><div class=\"line\">    [transformOperation addExecutionBlock:^&#123;</div><div class=\"line\">        NSBlockOperation *strongTransformOperation = weakTransformOperation;</div><div class=\"line\">        </div><div class=\"line\">        if ([strongTransformOperation isCancelled]) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        UIImage *transformedImage = nil;</div><div class=\"line\">        if (self.avatarImage) &#123;</div><div class=\"line\">            transformedImage = [self.avatarImage pp_imageByRoundCornerRadius:self.bounds.size.width scaleSize:self.bounds.size];</div><div class=\"line\">        &#125; else if (self.imageBackgroundColor) &#123;</div><div class=\"line\">            transformedImage = [UIImage pp_roundImageWithColor:self.imageBackgroundColor radius:self.bounds.size.width / 2];</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        if (!self.borderHidden) &#123;</div><div class=\"line\">            transformedImage = [transformedImage pp_imageByRoundBorderedColor:self.borderColor borderWidth:self.borderWidth];</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">            if ([strongTransformOperation isCancelled]) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (self.avatarImage == startImage) &#123;  // 1</div><div class=\"line\">                _isNeedTransform = NO;</div><div class=\"line\">                [self setImage:transformedImage forState:UIControlStateNormal];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    </div><div class=\"line\">    [[self.class sharedTransformQueue] addOperation:transformOperation];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在上面有一个标注了1的注释点，这里的条件判断是为了避免多线程时序性的问题而加的。考虑这样的一种常见情况：圆角头像控件是表格上的单元格（cell）上的子视图，某个 cell 被滑到屏幕上，于是开始头像的裁剪（这里将这个头像称为旧头像），然后在这个裁剪尚未完成的时候，这个 cell 被滑出了屏幕，然后根据新的图片裁剪圆角（这个头像称为新头像），可能出现新头像裁剪早于旧头像完成的情况，就会导致控件先设置头像为新头像，然后被慢悠悠才完成裁剪的旧头像覆盖的问题。所以这里用这个条件避免这个问题。</p>\n<h2 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h2><p>将上述的操作都封装隐藏好，现在的圆角头像控件 <strong>PPRoundedAvatar</strong> 的使用就很简单了，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">PPRoundedAvatar *avatar = [[PPRoundedAvatar alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];</div><div class=\"line\">avatar.avatarImage = [UIImage imageNamed:@&quot;example.png&quot;];       // 头像图片</div><div class=\"line\">avatar.borderWidth = 1.0;                                       // 边框宽度</div><div class=\"line\">avatar.borderColor = UIColor.blackColor;                        // 边框颜色</div><div class=\"line\">avatar.borderHidden = NO;                                       // 显示边框</div><div class=\"line\">avatar.imageBackgroundColor = UIColor.grayColor;                // 背景颜色</div><div class=\"line\">[self.view addSubview:avatar];</div></pre></td></tr></table></figure></p>\n<p>具体的代码已经丢到了 <a href=\"https://github.com/VernonVan/PPRoundedAvatar\">github</a> 上了，同时支持 Cocoapods 导入项目。<br>有需要的可以 clone 进行使用，也欢迎 pull request 完善这个控件。</p>\n<h2 id=\"插叙\"><a href=\"#插叙\" class=\"headerlink\" title=\"插叙\"></a>插叙</h2><p>技术上的问题就说到了这里，可是做一个开源项目不仅在技术上需要反复斟酌，而且在 github 的展示、demo 的展示等地方都需要有界面的设计，可苦了我这直男审美……/(ㄒoㄒ)/~~<br>这也导致了我家又吉君实在是看不下去了，终于勇敢地站了出来帮我把界面的设计给做好了，当中的你来我往又是另外的<a href=\"https://vernonvan.github.io/2017/04/01/ruanpapa%E5%92%8C%E5%8F%88%E5%90%89%E5%90%9B%E7%9A%84%E6%97%A5%E5%B8%B8%E4%B9%8B%E4%B8%80/\">故事</a>。真的是对我家又吉君感激涕零~~~<br>呐，又吉君，你帮我画一辈子设计好不好吖，我带你去吃鸡锁骨、卷饼、酱香饼、枣糕还有烤冷面哦~哈哈哈哈啊哈哈哈</p>\n"},{"title":"Swift的lazy关键字–延迟加载","date":"2016-12-28T08:29:02.000Z","_content":"### 定义\nlazy属性就是初始值直到第一次使用的时候才执行计算的属性，这对小内存的手机所产生的性能上的优化是相当可观的。\n**注意：lazy属性必须是变量（var修饰符），因为常量属性（let修饰符）必须在初始化之前就有值，所以常量属性不能定义为lazy。**\n\n### Objective-C中的延迟加载\nObjective-C并没有在语法上支持延迟加载，通常是由程序员自己手动实现的。\n示例如下：\n``` swift\n@property (nonatomic, strong) NSArray *names;\n\n- (NSArray *)names {\n    if (!_names) {\n        _names = [[NSArray alloc] init];\n        NSLog(@\"只在首次访问输出\");\n    }\n    return _names;\n}\n```\n说明：在初始化对象后，_names 是 nil。只有当首次访问 names 属性时 getter 方法会被调用，并检查如果还没有初始化的话，就进行赋值。可以想见，控制台打印的“只在首次访问输出”的确只会输出一次。我们之后再多次访问这个属性的话，因为 _names已经有值，因此将直接返回。\n分析：getter方法和下划线语法对初学者并不是那么的友好，同时属性以及对应的getter方法空间上隔得比较远，代码逻辑不直观。\n\n### Swift的延迟加载\nSwift中则可以通过**lazy**关键字简单地实现相同功能，比如上述示例代码在Swift中实现的话：\n``` swift\nlazy var names: NSArray = {\n\tlet names = NSArray()\n\tprint(\"只在首次访问输出\")\n\treturn names\n}()\n```\n分析：相比起Objective-C中的实现，现在的lazy是在是简单的多了，而且更加的直观。除了上述直接在属性后面定义闭包调用的方法以外，还可以使用实例方法（func）和类方法（class func）来为lazy属性初始化添加必要的逻辑。\n\n### 使用场景\n延迟加载主要有以下两个使用的场景：\n1. 属性的初始值依赖于其他的属性值，只有其他的属性值有值之后才能得出该属性的值。\n2. 属性的初始值需要大量的计算。\n\n### 高级用法\n在Swift标准库中还有一组lazy方法，可以配合map、filter这类接受闭包并进行运行的方法一起，让整个行为变成延时进行的。以下是map函数的用法（示例取自喵神的[Swifter](http://swifter.tips/lazy/)）:\n``` Swift\nlet data = 1...3\nlet result = data.lazy.map {\n    (i: Int) -> Int in\n    print(\"正在处理 \\(i)\")\n    return i * 2\n}\n\nprint(\"准备访问结果\")\nfor i in result {\n    print(\"操作后结果为 \\(i)\")\n}\n\nprint(\"操作完毕\")\n```\n``` swift\n// 准备访问结果\n// 正在处理 1\n// 操作后结果为 2\n// 正在处理 2\n// 操作后结果为 4\n// 正在处理 3\n// 操作后结果为 6\n// 操作完毕\n```\n\n> 对于那些不需要完全运行，可能提前退出的情况，使用 lazy 来进行性能优化效果会非常有效。\n\n参考链接：\n1. 喵神：[LAZY 修饰符和 LAZY 方法](http://swifter.tips/lazy/)\n2. Swiftist：[Swift中的延迟加载](http://swiftist.org/topics/129)\n3. [Apple developer](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html)\n","source":"_posts/Swift的lazy关键字–延迟加载.md","raw":"---\ntitle: Swift的lazy关键字–延迟加载\ndate: 2016-12-28 16:29:02\ntags:\n- iOS\n- Swift\ncategories:\n- ruanpapa--技术贴\n---\n### 定义\nlazy属性就是初始值直到第一次使用的时候才执行计算的属性，这对小内存的手机所产生的性能上的优化是相当可观的。\n**注意：lazy属性必须是变量（var修饰符），因为常量属性（let修饰符）必须在初始化之前就有值，所以常量属性不能定义为lazy。**\n\n### Objective-C中的延迟加载\nObjective-C并没有在语法上支持延迟加载，通常是由程序员自己手动实现的。\n示例如下：\n``` swift\n@property (nonatomic, strong) NSArray *names;\n\n- (NSArray *)names {\n    if (!_names) {\n        _names = [[NSArray alloc] init];\n        NSLog(@\"只在首次访问输出\");\n    }\n    return _names;\n}\n```\n说明：在初始化对象后，_names 是 nil。只有当首次访问 names 属性时 getter 方法会被调用，并检查如果还没有初始化的话，就进行赋值。可以想见，控制台打印的“只在首次访问输出”的确只会输出一次。我们之后再多次访问这个属性的话，因为 _names已经有值，因此将直接返回。\n分析：getter方法和下划线语法对初学者并不是那么的友好，同时属性以及对应的getter方法空间上隔得比较远，代码逻辑不直观。\n\n### Swift的延迟加载\nSwift中则可以通过**lazy**关键字简单地实现相同功能，比如上述示例代码在Swift中实现的话：\n``` swift\nlazy var names: NSArray = {\n\tlet names = NSArray()\n\tprint(\"只在首次访问输出\")\n\treturn names\n}()\n```\n分析：相比起Objective-C中的实现，现在的lazy是在是简单的多了，而且更加的直观。除了上述直接在属性后面定义闭包调用的方法以外，还可以使用实例方法（func）和类方法（class func）来为lazy属性初始化添加必要的逻辑。\n\n### 使用场景\n延迟加载主要有以下两个使用的场景：\n1. 属性的初始值依赖于其他的属性值，只有其他的属性值有值之后才能得出该属性的值。\n2. 属性的初始值需要大量的计算。\n\n### 高级用法\n在Swift标准库中还有一组lazy方法，可以配合map、filter这类接受闭包并进行运行的方法一起，让整个行为变成延时进行的。以下是map函数的用法（示例取自喵神的[Swifter](http://swifter.tips/lazy/)）:\n``` Swift\nlet data = 1...3\nlet result = data.lazy.map {\n    (i: Int) -> Int in\n    print(\"正在处理 \\(i)\")\n    return i * 2\n}\n\nprint(\"准备访问结果\")\nfor i in result {\n    print(\"操作后结果为 \\(i)\")\n}\n\nprint(\"操作完毕\")\n```\n``` swift\n// 准备访问结果\n// 正在处理 1\n// 操作后结果为 2\n// 正在处理 2\n// 操作后结果为 4\n// 正在处理 3\n// 操作后结果为 6\n// 操作完毕\n```\n\n> 对于那些不需要完全运行，可能提前退出的情况，使用 lazy 来进行性能优化效果会非常有效。\n\n参考链接：\n1. 喵神：[LAZY 修饰符和 LAZY 方法](http://swifter.tips/lazy/)\n2. Swiftist：[Swift中的延迟加载](http://swiftist.org/topics/129)\n3. [Apple developer](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html)\n","slug":"Swift的lazy关键字–延迟加载","published":1,"updated":"2017-03-30T05:42:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg4j8vyh000dvfwxs9t8xstm","content":"<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>lazy属性就是初始值直到第一次使用的时候才执行计算的属性，这对小内存的手机所产生的性能上的优化是相当可观的。<br><strong>注意：lazy属性必须是变量（var修饰符），因为常量属性（let修饰符）必须在初始化之前就有值，所以常量属性不能定义为lazy。</strong></p>\n<h3 id=\"Objective-C中的延迟加载\"><a href=\"#Objective-C中的延迟加载\" class=\"headerlink\" title=\"Objective-C中的延迟加载\"></a>Objective-C中的延迟加载</h3><p>Objective-C并没有在语法上支持延迟加载，通常是由程序员自己手动实现的。<br>示例如下：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property (nonatomic, strong) <span class=\"type\">NSArray</span> *names;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"type\">NSArray</span> *)names &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!_names) &#123;</div><div class=\"line\">        _names = [[<span class=\"type\">NSArray</span> alloc] <span class=\"keyword\">init</span>];</div><div class=\"line\">        <span class=\"type\">NSLog</span>(@<span class=\"string\">\"只在首次访问输出\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> _names;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>说明：在初始化对象后，_names 是 nil。只有当首次访问 names 属性时 getter 方法会被调用，并检查如果还没有初始化的话，就进行赋值。可以想见，控制台打印的“只在首次访问输出”的确只会输出一次。我们之后再多次访问这个属性的话，因为 _names已经有值，因此将直接返回。<br>分析：getter方法和下划线语法对初学者并不是那么的友好，同时属性以及对应的getter方法空间上隔得比较远，代码逻辑不直观。</p>\n<h3 id=\"Swift的延迟加载\"><a href=\"#Swift的延迟加载\" class=\"headerlink\" title=\"Swift的延迟加载\"></a>Swift的延迟加载</h3><p>Swift中则可以通过<strong>lazy</strong>关键字简单地实现相同功能，比如上述示例代码在Swift中实现的话：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">lazy</span> <span class=\"keyword\">var</span> names: <span class=\"type\">NSArray</span> = &#123;</div><div class=\"line\">\t<span class=\"keyword\">let</span> names = <span class=\"type\">NSArray</span>()</div><div class=\"line\">\t<span class=\"built_in\">print</span>(<span class=\"string\">\"只在首次访问输出\"</span>)</div><div class=\"line\">\t<span class=\"keyword\">return</span> names</div><div class=\"line\">&#125;()</div></pre></td></tr></table></figure></p>\n<p>分析：相比起Objective-C中的实现，现在的lazy是在是简单的多了，而且更加的直观。除了上述直接在属性后面定义闭包调用的方法以外，还可以使用实例方法（func）和类方法（class func）来为lazy属性初始化添加必要的逻辑。</p>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>延迟加载主要有以下两个使用的场景：</p>\n<ol>\n<li>属性的初始值依赖于其他的属性值，只有其他的属性值有值之后才能得出该属性的值。</li>\n<li>属性的初始值需要大量的计算。</li>\n</ol>\n<h3 id=\"高级用法\"><a href=\"#高级用法\" class=\"headerlink\" title=\"高级用法\"></a>高级用法</h3><p>在Swift标准库中还有一组lazy方法，可以配合map、filter这类接受闭包并进行运行的方法一起，让整个行为变成延时进行的。以下是map函数的用法（示例取自喵神的<a href=\"http://swifter.tips/lazy/\" target=\"_blank\" rel=\"external\">Swifter</a>）:<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> data = <span class=\"number\">1</span>...<span class=\"number\">3</span></div><div class=\"line\"><span class=\"keyword\">let</span> result = data.<span class=\"built_in\">lazy</span>.<span class=\"built_in\">map</span> &#123;</div><div class=\"line\">    (i: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"正在处理 \\(i)\"</span>)</div><div class=\"line\">    <span class=\"keyword\">return</span> i * <span class=\"number\">2</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"准备访问结果\"</span>)</div><div class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> result &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"操作后结果为 \\(i)\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"操作完毕\"</span>)</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 准备访问结果</span></div><div class=\"line\"><span class=\"comment\">// 正在处理 1</span></div><div class=\"line\"><span class=\"comment\">// 操作后结果为 2</span></div><div class=\"line\"><span class=\"comment\">// 正在处理 2</span></div><div class=\"line\"><span class=\"comment\">// 操作后结果为 4</span></div><div class=\"line\"><span class=\"comment\">// 正在处理 3</span></div><div class=\"line\"><span class=\"comment\">// 操作后结果为 6</span></div><div class=\"line\"><span class=\"comment\">// 操作完毕</span></div></pre></td></tr></table></figure>\n<blockquote>\n<p>对于那些不需要完全运行，可能提前退出的情况，使用 lazy 来进行性能优化效果会非常有效。</p>\n</blockquote>\n<p>参考链接：</p>\n<ol>\n<li>喵神：<a href=\"http://swifter.tips/lazy/\" target=\"_blank\" rel=\"external\">LAZY 修饰符和 LAZY 方法</a></li>\n<li>Swiftist：<a href=\"http://swiftist.org/topics/129\" target=\"_blank\" rel=\"external\">Swift中的延迟加载</a></li>\n<li><a href=\"https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html\" target=\"_blank\" rel=\"external\">Apple developer</a></li>\n</ol>\n","excerpt":"","more":"<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>lazy属性就是初始值直到第一次使用的时候才执行计算的属性，这对小内存的手机所产生的性能上的优化是相当可观的。<br><strong>注意：lazy属性必须是变量（var修饰符），因为常量属性（let修饰符）必须在初始化之前就有值，所以常量属性不能定义为lazy。</strong></p>\n<h3 id=\"Objective-C中的延迟加载\"><a href=\"#Objective-C中的延迟加载\" class=\"headerlink\" title=\"Objective-C中的延迟加载\"></a>Objective-C中的延迟加载</h3><p>Objective-C并没有在语法上支持延迟加载，通常是由程序员自己手动实现的。<br>示例如下：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property (nonatomic, strong) <span class=\"type\">NSArray</span> *names;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"type\">NSArray</span> *)names &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!_names) &#123;</div><div class=\"line\">        _names = [[<span class=\"type\">NSArray</span> alloc] <span class=\"keyword\">init</span>];</div><div class=\"line\">        <span class=\"type\">NSLog</span>(@<span class=\"string\">\"只在首次访问输出\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> _names;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>说明：在初始化对象后，_names 是 nil。只有当首次访问 names 属性时 getter 方法会被调用，并检查如果还没有初始化的话，就进行赋值。可以想见，控制台打印的“只在首次访问输出”的确只会输出一次。我们之后再多次访问这个属性的话，因为 _names已经有值，因此将直接返回。<br>分析：getter方法和下划线语法对初学者并不是那么的友好，同时属性以及对应的getter方法空间上隔得比较远，代码逻辑不直观。</p>\n<h3 id=\"Swift的延迟加载\"><a href=\"#Swift的延迟加载\" class=\"headerlink\" title=\"Swift的延迟加载\"></a>Swift的延迟加载</h3><p>Swift中则可以通过<strong>lazy</strong>关键字简单地实现相同功能，比如上述示例代码在Swift中实现的话：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">lazy</span> <span class=\"keyword\">var</span> names: <span class=\"type\">NSArray</span> = &#123;</div><div class=\"line\">\t<span class=\"keyword\">let</span> names = <span class=\"type\">NSArray</span>()</div><div class=\"line\">\t<span class=\"built_in\">print</span>(<span class=\"string\">\"只在首次访问输出\"</span>)</div><div class=\"line\">\t<span class=\"keyword\">return</span> names</div><div class=\"line\">&#125;()</div></pre></td></tr></table></figure></p>\n<p>分析：相比起Objective-C中的实现，现在的lazy是在是简单的多了，而且更加的直观。除了上述直接在属性后面定义闭包调用的方法以外，还可以使用实例方法（func）和类方法（class func）来为lazy属性初始化添加必要的逻辑。</p>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>延迟加载主要有以下两个使用的场景：</p>\n<ol>\n<li>属性的初始值依赖于其他的属性值，只有其他的属性值有值之后才能得出该属性的值。</li>\n<li>属性的初始值需要大量的计算。</li>\n</ol>\n<h3 id=\"高级用法\"><a href=\"#高级用法\" class=\"headerlink\" title=\"高级用法\"></a>高级用法</h3><p>在Swift标准库中还有一组lazy方法，可以配合map、filter这类接受闭包并进行运行的方法一起，让整个行为变成延时进行的。以下是map函数的用法（示例取自喵神的<a href=\"http://swifter.tips/lazy/\">Swifter</a>）:<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> data = <span class=\"number\">1</span>...<span class=\"number\">3</span></div><div class=\"line\"><span class=\"keyword\">let</span> result = data.<span class=\"built_in\">lazy</span>.<span class=\"built_in\">map</span> &#123;</div><div class=\"line\">    (i: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"正在处理 \\(i)\"</span>)</div><div class=\"line\">    <span class=\"keyword\">return</span> i * <span class=\"number\">2</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"准备访问结果\"</span>)</div><div class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> result &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"操作后结果为 \\(i)\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"操作完毕\"</span>)</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 准备访问结果</span></div><div class=\"line\"><span class=\"comment\">// 正在处理 1</span></div><div class=\"line\"><span class=\"comment\">// 操作后结果为 2</span></div><div class=\"line\"><span class=\"comment\">// 正在处理 2</span></div><div class=\"line\"><span class=\"comment\">// 操作后结果为 4</span></div><div class=\"line\"><span class=\"comment\">// 正在处理 3</span></div><div class=\"line\"><span class=\"comment\">// 操作后结果为 6</span></div><div class=\"line\"><span class=\"comment\">// 操作完毕</span></div></pre></td></tr></table></figure>\n<blockquote>\n<p>对于那些不需要完全运行，可能提前退出的情况，使用 lazy 来进行性能优化效果会非常有效。</p>\n</blockquote>\n<p>参考链接：</p>\n<ol>\n<li>喵神：<a href=\"http://swifter.tips/lazy/\">LAZY 修饰符和 LAZY 方法</a></li>\n<li>Swiftist：<a href=\"http://swiftist.org/topics/129\">Swift中的延迟加载</a></li>\n<li><a href=\"https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html\">Apple developer</a></li>\n</ol>\n"},{"title":"iOS性能优化探讨","date":"2017-09-20T03:11:06.000Z","_content":"\n\n\n*最近在公司内部做了一个分享会，探讨了iOS性能优化的话题，现在将重点的内容整理好发出来，各位大牛斧正。*\n\n\n\n本文将从原理出发，解释卡顿发生的原理，然后会讲解项目中行之有效的几个优化点，最后会展望一下接下来将要尝试的方向。下面进入正题。\n\n\n\n### 屏幕显示的原理\n\n\n\n#### 基本原理\n\n![屏幕显示](http://upload-images.jianshu.io/upload_images/698554-f81809fe17a003e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们知道，远古时代的CRT显示器的显示原理是用电子枪扫描荧光屏来发光。如上图所示，电子枪按照从左到右，从上到下的顺序扫描。当电子枪换到新的一行准备进行扫描时，也就是上图A4、B4、C4、D4的位置，显示器会发出一个水平同步信号；而当一帧画面绘制完成后，电子枪回复到原位准备画下一帧前，也就是上图D4的位置，显示器会发出一个垂直同步信号。垂直同步信号的作用一方面是通知显示器回到A1位置，另外一方面，也通知显卡，准备输出下一帧画面。现在已经是液晶显示器的时代了，不再使用电子枪扫描了，但是原理还是类似的，水平同步信号和垂直同步信号还是一样被使用的。\n\n\n\n![计算机工作原理](http://upload-images.jianshu.io/upload_images/698554-10c8e7e137166beb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n计算机系统的工作原理如上图所示：首先是CPU的工作，包括创建视图分配内存、计算布局、图片解码以及文本绘制等；接下来轮到GPU工作了，GPU负责视图变换、合成和渲染等；GPU渲染完提交到帧缓冲区中，等收到垂直同步信号后将帧缓冲区的内容显示到屏幕上。\n\n\n\n#### 屏幕撕裂(Screen tearing)\n\n上述的简单的屏幕显示原理其实会产生这样一个问题：假设我们的显卡速度很快，每秒生产的帧数肯定要超过显示器刷新率。那么在实际数据处理过程中，缓冲区的数据，在被输出之前，就被显卡不断的刷新重写。但是缓冲区并不是“先清空再写入数据”，这太没有效率，而是采用“新数据覆盖老数据”的方式。\n\n假设这样一种情况，缓冲区已经有一副完整的帧画面（A帧），然后显卡生成了下一帧画面（B帧），新一帧的数据开始写入缓冲区，写到一半的时候，垂直同步信号来了，于是缓冲区的数据被输出到显示器。但问题是，这时缓冲区的数据，是由一半A帧和一半B帧数据合成的。因此最终显示器上显示出来的画面就不是一副完整的画面，这就是“画面撕裂”现象出现的原因，如下图。\n\n![屏幕撕裂](http://upload-images.jianshu.io/upload_images/698554-66bc0d60d4a305c8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n那怎样才能解决画面撕裂的问题呢？简单来说只要让帧缓冲区里的数据始终保持一副完整的画面就可以了。从技术角度出发，其实就是利用刚刚提到的垂直同步信号。\n\n具体说起来就是，当显卡生成了一副完整画面并写入了帧缓冲区之后，暂停！然后开始等待垂直同步信号，当得到垂直同步信号后，再继续渲染下一帧写入缓冲区。这样就可以保证在缓冲区的数据始终是一副完整的画面，不会出现前后帧混合的问题。\n\n\n\n#### 卡顿产生原因\n\n但是呢，垂直同步机制带来了一个新的问题 —— 掉帧。所谓的掉帧，跟垂直同步有一定关系，因为垂直同步机制决定了如果在一个时钟周期内CPU或者GPU没有完成各自的任务的话，就会将帧缓冲区里的内容直接丢弃！掉帧并不能完全怪罪于垂直同步机制，更重要的原因是我们作为开发者没有进行足够的优化，将过重的任务派发到了CPU或者GPU上，下图(from：[iOS 保持界面流畅的技巧](https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/))是掉帧的图示，表明CPU或者GPU任意一个没能在时钟周期内完成自己的任务的话都会导致卡顿掉帧。\n\n![卡顿](http://upload-images.jianshu.io/upload_images/698554-75e20f80bb5101f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n### 行之有效的优化点\n\n1. #### 提前布局\n\n   提前布局可以说是最重要的优化点了。其实在从服务端拿到 JSON 数据的时候，关于视图的布局就已经确定了，包括每个控件的frame、cell的高度以及文本排版结果等等，在这个时候完全可以在后台线程计算并封装为对应的布局对象XXXTableViewCellLayout，每个cellLayout的内存占用并不是很多，所以直接全部缓存到内存中。当列表滚动到某个cell的时候，直接拿到对应的cellLayout配置这个cell的对应属性即可。当然，该有的计算是免不了的，只是提前算好并缓存，免去了在滚动的时候计算和重复的计算。通过这一个优化，将本来的fps50的列表优化到了55、56左右，可以说从肉眼上已经看不出有卡顿掉帧了。\n\n   ​\n\n   ![cellLayout示例图](http://upload-images.jianshu.io/upload_images/698554-6b21937ce6754567.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n   上图是项目中某个cellLayout的部分代码，可以看到里面存的就是所有控件的frame和文本的排版结果而已，里面没有任何的黑科技，只是将本来在滚动中才做的事情提前了而已。\n\n   ​\n\n2. #### 按页加载缓存\n\n   - 现状分析：90%的APP有tableview，90%的tableview里有上拉刷新和下拉加载。以我司的项目**ZAKER**中的热点新闻界面为例，简单流程大概是这样的：①应用启动的时候会将磁盘中所有的新闻一次性读取出来显示到屏幕上； ②在每次下拉刷新和上拉加载的时候会将内存中所有新闻缓存到磁盘中，也即全量读写。这意味着大部分的新闻数据会反复写入到磁盘中，这样的写入是冗余的，因为前面的这些新闻数据并没有发生改变。\n\n     ​\n\n   - 改进方案：所以优化的方法就是将这些列表数组进行分割，分割成一页一页，每次写入的数据量很小，而且避免了冗余写入的问题。现在的流程变为：①启动时只读取第一批新闻显示在屏幕中；②下拉刷新和上拉加载的时候只把当前服务器返回的一批新闻写入缓存中；③在上拉加载的时候会先查看磁盘中是否有未读的缓存，若有则读取缓存，否则才从服务器下载一批新的文章。\n\n     ​\n\n   - 直观图示：\n\n     ![按页缓存](http://upload-images.jianshu.io/upload_images/698554-ba7a27262a9e0931.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n     可以看到，优化之前整个新闻列表以及其他配置都在一个文件里，刷新10几次之后文件大小达到2MB，并且随着不断刷新而越来越大；优化之后，其他的配置还是在刚刚的文件中，但是不断增长的新闻数组被分割成一页一页的文件，每一页里面有10多条的新闻数据，同时有一个configure文件保存这些页的信息以及页的顺序。根据测试人员的反馈，进行按页加载缓存优化能减少5%~8%的CPU占用，使用的内存也有一定的下降。还是有很明显的优化效果的。\n\n     ​\n\n3. #### 后台线程处理图片\n\n   圆形头像、图片裁圆角等处理可以说是非常常见的需求了，包括从iOS11的系统各处都能看到，整体的页面控件都变得更加圆润了。但是，对图片处理必然是消耗资源的，实现过图片圆角效果的应该都知道，最简单的就是 layer.cornerRadius+layer.masksToBounds 的方式，但是这种做法在tableview中往往会是滚动变得卡顿，因为这种实现方式会触发离屏渲染，屏幕外缓冲区跟当前屏幕缓冲区上下文切换是很耗性能的，所以离屏渲染往往会造成卡顿(参考：[iOS 离屏渲染的研究](http://www.jianshu.com/p/6d24a4c29e18))。\n\n   那要怎么处理图片呢？可以使用Core Graphics，CoreGraphic通常是线程安全的，所以可以进行异步绘制，显示的时候再放回主线程。我们在项目中实现了一个后台处理图片的框架，核心代码如下：\n\n   ```objective-c\n   NSBlockOperation *transformOperation = [[NSBlockOperation alloc] init];\n       [transformOperation addExecutionBlock:^{        \n           // 此处处理图片\n         \t...\n           dispatch_async(dispatch_get_main_queue(), ^{\n             \t    // 主线程设置图片\n                   [self setImage:transformedImage forState:UIControlStateNormal];\n               }\n           });\n       }];\n   ```\n\n   ​\n\n   ​\n\n4. #### 更加高效的控件\n\n   还可以直接从开源库中选用更加高效的控件替换项目中性能没那么好的控件。项目中将之前的TTTAttributedLabel、M80AttributedLabel全部替换为YYLabel，开启YYLabel的displaysAsynchronously、ignoreCommonProperties属性可以异步绘制文本以及忽略不需要的属性。更加追求性能的话，可以结合第1点的提前布局机制，在提前布局的阶段生成好YYLabel渲染时用到的textLayout，显示的时候直接赋值textLayout就可以了。\n\n   ​\n\n5. #### 其他\n\n   还有一些比较微小的优化，对性能可以说没有多大的影响，但是可以在开发阶段稍加留意，养成良好的习惯。\n\n   - 尽量减少视图层级，合并多余的视图。同样以 **ZAKER** 为例，用户显示时的蓝V标签、达人标签以及楼主图片等几个视图，之前是用不同的view来展示的，优化过程将这几个view合并为一个view，一个view管理这些相似的事物，也可以减少某些相同逻辑的代码。\n   - 减少频繁的addSubview、removeSubview，remove之后视图的实例对象会被释放，再add的时候会再次调用初始化函数。可以用hidden属性隐藏不显示的视图。\n\n\n\n### 接下来的方向\n\n1. #### 异步绘制\n\n   从开始接触我们就一直在被告知，UIKit的东西是绝对不能在后台线程调用的，一定得在主线程调用，所以主线程也被叫做UI线程。在后台线程调用UIKit的东西有一定几率导致崩溃，或者出现视图不显示、显示错乱等等问题。但是呢，根据刚刚所说的，Core Graphics的那一套东西是线程安全的，所以可以通过Core Graphics在后台将视图渲染到一张图片上，显示的时候在主线程将这张图片设置到相应位置上。Facebook著名的AsyncDisplayKit的核心实现应该也是基于这个原理，接下来的优化可以尝试这个方案。\n\n   ​\n\n2. #### Metal\n\n   根据Apple官方说法，Metal框架被设计用来实现两个目标: 3D 图形渲染和并行计算。这两者有很多共同点。它们都在数量庞大的数据上并行运行特殊的代码，并可以在GPU上执行。目前正在研究学习阶段，看项目中是否能利用Metal进行一定的优化。\n\n   ​\n\n3. #### APM??\n\n   Application Performance Management(APM)：应用程序性能管理， 通过对应用的可靠性、稳定性等方面的监控，进而达到可以快速修复问题、提高用户体验的目的。目前比较有代表性的 APM 产品有：听云、阿里百川、腾讯bugly等，现在也在考虑自己研发一套APM系统，先从比较简单的指标入手，先对卡顿和崩溃这两个指标着手，做的顺利的话再逐步扩展别的指标的检测管理。\n\n\n\n以上。\n\n","source":"_posts/iOS性能优化探讨.md","raw":"---\ntitle: iOS性能优化探讨\ndate: 2017-09-20 11:11:06\ntags: \n- iOS\n- 性能优化\ncategories:\n- ruanpapa--技术贴\n---\n\n\n\n*最近在公司内部做了一个分享会，探讨了iOS性能优化的话题，现在将重点的内容整理好发出来，各位大牛斧正。*\n\n\n\n本文将从原理出发，解释卡顿发生的原理，然后会讲解项目中行之有效的几个优化点，最后会展望一下接下来将要尝试的方向。下面进入正题。\n\n\n\n### 屏幕显示的原理\n\n\n\n#### 基本原理\n\n![屏幕显示](http://upload-images.jianshu.io/upload_images/698554-f81809fe17a003e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们知道，远古时代的CRT显示器的显示原理是用电子枪扫描荧光屏来发光。如上图所示，电子枪按照从左到右，从上到下的顺序扫描。当电子枪换到新的一行准备进行扫描时，也就是上图A4、B4、C4、D4的位置，显示器会发出一个水平同步信号；而当一帧画面绘制完成后，电子枪回复到原位准备画下一帧前，也就是上图D4的位置，显示器会发出一个垂直同步信号。垂直同步信号的作用一方面是通知显示器回到A1位置，另外一方面，也通知显卡，准备输出下一帧画面。现在已经是液晶显示器的时代了，不再使用电子枪扫描了，但是原理还是类似的，水平同步信号和垂直同步信号还是一样被使用的。\n\n\n\n![计算机工作原理](http://upload-images.jianshu.io/upload_images/698554-10c8e7e137166beb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n计算机系统的工作原理如上图所示：首先是CPU的工作，包括创建视图分配内存、计算布局、图片解码以及文本绘制等；接下来轮到GPU工作了，GPU负责视图变换、合成和渲染等；GPU渲染完提交到帧缓冲区中，等收到垂直同步信号后将帧缓冲区的内容显示到屏幕上。\n\n\n\n#### 屏幕撕裂(Screen tearing)\n\n上述的简单的屏幕显示原理其实会产生这样一个问题：假设我们的显卡速度很快，每秒生产的帧数肯定要超过显示器刷新率。那么在实际数据处理过程中，缓冲区的数据，在被输出之前，就被显卡不断的刷新重写。但是缓冲区并不是“先清空再写入数据”，这太没有效率，而是采用“新数据覆盖老数据”的方式。\n\n假设这样一种情况，缓冲区已经有一副完整的帧画面（A帧），然后显卡生成了下一帧画面（B帧），新一帧的数据开始写入缓冲区，写到一半的时候，垂直同步信号来了，于是缓冲区的数据被输出到显示器。但问题是，这时缓冲区的数据，是由一半A帧和一半B帧数据合成的。因此最终显示器上显示出来的画面就不是一副完整的画面，这就是“画面撕裂”现象出现的原因，如下图。\n\n![屏幕撕裂](http://upload-images.jianshu.io/upload_images/698554-66bc0d60d4a305c8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n那怎样才能解决画面撕裂的问题呢？简单来说只要让帧缓冲区里的数据始终保持一副完整的画面就可以了。从技术角度出发，其实就是利用刚刚提到的垂直同步信号。\n\n具体说起来就是，当显卡生成了一副完整画面并写入了帧缓冲区之后，暂停！然后开始等待垂直同步信号，当得到垂直同步信号后，再继续渲染下一帧写入缓冲区。这样就可以保证在缓冲区的数据始终是一副完整的画面，不会出现前后帧混合的问题。\n\n\n\n#### 卡顿产生原因\n\n但是呢，垂直同步机制带来了一个新的问题 —— 掉帧。所谓的掉帧，跟垂直同步有一定关系，因为垂直同步机制决定了如果在一个时钟周期内CPU或者GPU没有完成各自的任务的话，就会将帧缓冲区里的内容直接丢弃！掉帧并不能完全怪罪于垂直同步机制，更重要的原因是我们作为开发者没有进行足够的优化，将过重的任务派发到了CPU或者GPU上，下图(from：[iOS 保持界面流畅的技巧](https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/))是掉帧的图示，表明CPU或者GPU任意一个没能在时钟周期内完成自己的任务的话都会导致卡顿掉帧。\n\n![卡顿](http://upload-images.jianshu.io/upload_images/698554-75e20f80bb5101f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n### 行之有效的优化点\n\n1. #### 提前布局\n\n   提前布局可以说是最重要的优化点了。其实在从服务端拿到 JSON 数据的时候，关于视图的布局就已经确定了，包括每个控件的frame、cell的高度以及文本排版结果等等，在这个时候完全可以在后台线程计算并封装为对应的布局对象XXXTableViewCellLayout，每个cellLayout的内存占用并不是很多，所以直接全部缓存到内存中。当列表滚动到某个cell的时候，直接拿到对应的cellLayout配置这个cell的对应属性即可。当然，该有的计算是免不了的，只是提前算好并缓存，免去了在滚动的时候计算和重复的计算。通过这一个优化，将本来的fps50的列表优化到了55、56左右，可以说从肉眼上已经看不出有卡顿掉帧了。\n\n   ​\n\n   ![cellLayout示例图](http://upload-images.jianshu.io/upload_images/698554-6b21937ce6754567.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n   上图是项目中某个cellLayout的部分代码，可以看到里面存的就是所有控件的frame和文本的排版结果而已，里面没有任何的黑科技，只是将本来在滚动中才做的事情提前了而已。\n\n   ​\n\n2. #### 按页加载缓存\n\n   - 现状分析：90%的APP有tableview，90%的tableview里有上拉刷新和下拉加载。以我司的项目**ZAKER**中的热点新闻界面为例，简单流程大概是这样的：①应用启动的时候会将磁盘中所有的新闻一次性读取出来显示到屏幕上； ②在每次下拉刷新和上拉加载的时候会将内存中所有新闻缓存到磁盘中，也即全量读写。这意味着大部分的新闻数据会反复写入到磁盘中，这样的写入是冗余的，因为前面的这些新闻数据并没有发生改变。\n\n     ​\n\n   - 改进方案：所以优化的方法就是将这些列表数组进行分割，分割成一页一页，每次写入的数据量很小，而且避免了冗余写入的问题。现在的流程变为：①启动时只读取第一批新闻显示在屏幕中；②下拉刷新和上拉加载的时候只把当前服务器返回的一批新闻写入缓存中；③在上拉加载的时候会先查看磁盘中是否有未读的缓存，若有则读取缓存，否则才从服务器下载一批新的文章。\n\n     ​\n\n   - 直观图示：\n\n     ![按页缓存](http://upload-images.jianshu.io/upload_images/698554-ba7a27262a9e0931.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n     可以看到，优化之前整个新闻列表以及其他配置都在一个文件里，刷新10几次之后文件大小达到2MB，并且随着不断刷新而越来越大；优化之后，其他的配置还是在刚刚的文件中，但是不断增长的新闻数组被分割成一页一页的文件，每一页里面有10多条的新闻数据，同时有一个configure文件保存这些页的信息以及页的顺序。根据测试人员的反馈，进行按页加载缓存优化能减少5%~8%的CPU占用，使用的内存也有一定的下降。还是有很明显的优化效果的。\n\n     ​\n\n3. #### 后台线程处理图片\n\n   圆形头像、图片裁圆角等处理可以说是非常常见的需求了，包括从iOS11的系统各处都能看到，整体的页面控件都变得更加圆润了。但是，对图片处理必然是消耗资源的，实现过图片圆角效果的应该都知道，最简单的就是 layer.cornerRadius+layer.masksToBounds 的方式，但是这种做法在tableview中往往会是滚动变得卡顿，因为这种实现方式会触发离屏渲染，屏幕外缓冲区跟当前屏幕缓冲区上下文切换是很耗性能的，所以离屏渲染往往会造成卡顿(参考：[iOS 离屏渲染的研究](http://www.jianshu.com/p/6d24a4c29e18))。\n\n   那要怎么处理图片呢？可以使用Core Graphics，CoreGraphic通常是线程安全的，所以可以进行异步绘制，显示的时候再放回主线程。我们在项目中实现了一个后台处理图片的框架，核心代码如下：\n\n   ```objective-c\n   NSBlockOperation *transformOperation = [[NSBlockOperation alloc] init];\n       [transformOperation addExecutionBlock:^{        \n           // 此处处理图片\n         \t...\n           dispatch_async(dispatch_get_main_queue(), ^{\n             \t    // 主线程设置图片\n                   [self setImage:transformedImage forState:UIControlStateNormal];\n               }\n           });\n       }];\n   ```\n\n   ​\n\n   ​\n\n4. #### 更加高效的控件\n\n   还可以直接从开源库中选用更加高效的控件替换项目中性能没那么好的控件。项目中将之前的TTTAttributedLabel、M80AttributedLabel全部替换为YYLabel，开启YYLabel的displaysAsynchronously、ignoreCommonProperties属性可以异步绘制文本以及忽略不需要的属性。更加追求性能的话，可以结合第1点的提前布局机制，在提前布局的阶段生成好YYLabel渲染时用到的textLayout，显示的时候直接赋值textLayout就可以了。\n\n   ​\n\n5. #### 其他\n\n   还有一些比较微小的优化，对性能可以说没有多大的影响，但是可以在开发阶段稍加留意，养成良好的习惯。\n\n   - 尽量减少视图层级，合并多余的视图。同样以 **ZAKER** 为例，用户显示时的蓝V标签、达人标签以及楼主图片等几个视图，之前是用不同的view来展示的，优化过程将这几个view合并为一个view，一个view管理这些相似的事物，也可以减少某些相同逻辑的代码。\n   - 减少频繁的addSubview、removeSubview，remove之后视图的实例对象会被释放，再add的时候会再次调用初始化函数。可以用hidden属性隐藏不显示的视图。\n\n\n\n### 接下来的方向\n\n1. #### 异步绘制\n\n   从开始接触我们就一直在被告知，UIKit的东西是绝对不能在后台线程调用的，一定得在主线程调用，所以主线程也被叫做UI线程。在后台线程调用UIKit的东西有一定几率导致崩溃，或者出现视图不显示、显示错乱等等问题。但是呢，根据刚刚所说的，Core Graphics的那一套东西是线程安全的，所以可以通过Core Graphics在后台将视图渲染到一张图片上，显示的时候在主线程将这张图片设置到相应位置上。Facebook著名的AsyncDisplayKit的核心实现应该也是基于这个原理，接下来的优化可以尝试这个方案。\n\n   ​\n\n2. #### Metal\n\n   根据Apple官方说法，Metal框架被设计用来实现两个目标: 3D 图形渲染和并行计算。这两者有很多共同点。它们都在数量庞大的数据上并行运行特殊的代码，并可以在GPU上执行。目前正在研究学习阶段，看项目中是否能利用Metal进行一定的优化。\n\n   ​\n\n3. #### APM??\n\n   Application Performance Management(APM)：应用程序性能管理， 通过对应用的可靠性、稳定性等方面的监控，进而达到可以快速修复问题、提高用户体验的目的。目前比较有代表性的 APM 产品有：听云、阿里百川、腾讯bugly等，现在也在考虑自己研发一套APM系统，先从比较简单的指标入手，先对卡顿和崩溃这两个指标着手，做的顺利的话再逐步扩展别的指标的检测管理。\n\n\n\n以上。\n\n","slug":"iOS性能优化探讨","published":1,"updated":"2017-10-14T09:07:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg4j8vyj000hvfwxd05rjys3","content":"<p><em>最近在公司内部做了一个分享会，探讨了iOS性能优化的话题，现在将重点的内容整理好发出来，各位大牛斧正。</em></p>\n<p>本文将从原理出发，解释卡顿发生的原理，然后会讲解项目中行之有效的几个优化点，最后会展望一下接下来将要尝试的方向。下面进入正题。</p>\n<h3 id=\"屏幕显示的原理\"><a href=\"#屏幕显示的原理\" class=\"headerlink\" title=\"屏幕显示的原理\"></a>屏幕显示的原理</h3><h4 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/698554-f81809fe17a003e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕显示\"></p>\n<p>我们知道，远古时代的CRT显示器的显示原理是用电子枪扫描荧光屏来发光。如上图所示，电子枪按照从左到右，从上到下的顺序扫描。当电子枪换到新的一行准备进行扫描时，也就是上图A4、B4、C4、D4的位置，显示器会发出一个水平同步信号；而当一帧画面绘制完成后，电子枪回复到原位准备画下一帧前，也就是上图D4的位置，显示器会发出一个垂直同步信号。垂直同步信号的作用一方面是通知显示器回到A1位置，另外一方面，也通知显卡，准备输出下一帧画面。现在已经是液晶显示器的时代了，不再使用电子枪扫描了，但是原理还是类似的，水平同步信号和垂直同步信号还是一样被使用的。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-10c8e7e137166beb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"计算机工作原理\"></p>\n<p>计算机系统的工作原理如上图所示：首先是CPU的工作，包括创建视图分配内存、计算布局、图片解码以及文本绘制等；接下来轮到GPU工作了，GPU负责视图变换、合成和渲染等；GPU渲染完提交到帧缓冲区中，等收到垂直同步信号后将帧缓冲区的内容显示到屏幕上。</p>\n<h4 id=\"屏幕撕裂-Screen-tearing\"><a href=\"#屏幕撕裂-Screen-tearing\" class=\"headerlink\" title=\"屏幕撕裂(Screen tearing)\"></a>屏幕撕裂(Screen tearing)</h4><p>上述的简单的屏幕显示原理其实会产生这样一个问题：假设我们的显卡速度很快，每秒生产的帧数肯定要超过显示器刷新率。那么在实际数据处理过程中，缓冲区的数据，在被输出之前，就被显卡不断的刷新重写。但是缓冲区并不是“先清空再写入数据”，这太没有效率，而是采用“新数据覆盖老数据”的方式。</p>\n<p>假设这样一种情况，缓冲区已经有一副完整的帧画面（A帧），然后显卡生成了下一帧画面（B帧），新一帧的数据开始写入缓冲区，写到一半的时候，垂直同步信号来了，于是缓冲区的数据被输出到显示器。但问题是，这时缓冲区的数据，是由一半A帧和一半B帧数据合成的。因此最终显示器上显示出来的画面就不是一副完整的画面，这就是“画面撕裂”现象出现的原因，如下图。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-66bc0d60d4a305c8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕撕裂\"></p>\n<p>那怎样才能解决画面撕裂的问题呢？简单来说只要让帧缓冲区里的数据始终保持一副完整的画面就可以了。从技术角度出发，其实就是利用刚刚提到的垂直同步信号。</p>\n<p>具体说起来就是，当显卡生成了一副完整画面并写入了帧缓冲区之后，暂停！然后开始等待垂直同步信号，当得到垂直同步信号后，再继续渲染下一帧写入缓冲区。这样就可以保证在缓冲区的数据始终是一副完整的画面，不会出现前后帧混合的问题。</p>\n<h4 id=\"卡顿产生原因\"><a href=\"#卡顿产生原因\" class=\"headerlink\" title=\"卡顿产生原因\"></a>卡顿产生原因</h4><p>但是呢，垂直同步机制带来了一个新的问题 —— 掉帧。所谓的掉帧，跟垂直同步有一定关系，因为垂直同步机制决定了如果在一个时钟周期内CPU或者GPU没有完成各自的任务的话，就会将帧缓冲区里的内容直接丢弃！掉帧并不能完全怪罪于垂直同步机制，更重要的原因是我们作为开发者没有进行足够的优化，将过重的任务派发到了CPU或者GPU上，下图(from：<a href=\"https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/\" target=\"_blank\" rel=\"external\">iOS 保持界面流畅的技巧</a>)是掉帧的图示，表明CPU或者GPU任意一个没能在时钟周期内完成自己的任务的话都会导致卡顿掉帧。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-75e20f80bb5101f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"卡顿\"></p>\n<h3 id=\"行之有效的优化点\"><a href=\"#行之有效的优化点\" class=\"headerlink\" title=\"行之有效的优化点\"></a>行之有效的优化点</h3><ol>\n<li><h4 id=\"提前布局\"><a href=\"#提前布局\" class=\"headerlink\" title=\"提前布局\"></a>提前布局</h4><p>提前布局可以说是最重要的优化点了。其实在从服务端拿到 JSON 数据的时候，关于视图的布局就已经确定了，包括每个控件的frame、cell的高度以及文本排版结果等等，在这个时候完全可以在后台线程计算并封装为对应的布局对象XXXTableViewCellLayout，每个cellLayout的内存占用并不是很多，所以直接全部缓存到内存中。当列表滚动到某个cell的时候，直接拿到对应的cellLayout配置这个cell的对应属性即可。当然，该有的计算是免不了的，只是提前算好并缓存，免去了在滚动的时候计算和重复的计算。通过这一个优化，将本来的fps50的列表优化到了55、56左右，可以说从肉眼上已经看不出有卡顿掉帧了。</p>\n<p>​</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-6b21937ce6754567.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"cellLayout示例图\"></p>\n<p>上图是项目中某个cellLayout的部分代码，可以看到里面存的就是所有控件的frame和文本的排版结果而已，里面没有任何的黑科技，只是将本来在滚动中才做的事情提前了而已。</p>\n<p>​</p>\n</li>\n<li><h4 id=\"按页加载缓存\"><a href=\"#按页加载缓存\" class=\"headerlink\" title=\"按页加载缓存\"></a>按页加载缓存</h4><ul>\n<li><p>现状分析：90%的APP有tableview，90%的tableview里有上拉刷新和下拉加载。以我司的项目<strong>ZAKER</strong>中的热点新闻界面为例，简单流程大概是这样的：①应用启动的时候会将磁盘中所有的新闻一次性读取出来显示到屏幕上； ②在每次下拉刷新和上拉加载的时候会将内存中所有新闻缓存到磁盘中，也即全量读写。这意味着大部分的新闻数据会反复写入到磁盘中，这样的写入是冗余的，因为前面的这些新闻数据并没有发生改变。</p>\n<p>​</p>\n</li>\n<li><p>改进方案：所以优化的方法就是将这些列表数组进行分割，分割成一页一页，每次写入的数据量很小，而且避免了冗余写入的问题。现在的流程变为：①启动时只读取第一批新闻显示在屏幕中；②下拉刷新和上拉加载的时候只把当前服务器返回的一批新闻写入缓存中；③在上拉加载的时候会先查看磁盘中是否有未读的缓存，若有则读取缓存，否则才从服务器下载一批新的文章。</p>\n<p>​</p>\n</li>\n<li><p>直观图示：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-ba7a27262a9e0931.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"按页缓存\"></p>\n<p>可以看到，优化之前整个新闻列表以及其他配置都在一个文件里，刷新10几次之后文件大小达到2MB，并且随着不断刷新而越来越大；优化之后，其他的配置还是在刚刚的文件中，但是不断增长的新闻数组被分割成一页一页的文件，每一页里面有10多条的新闻数据，同时有一个configure文件保存这些页的信息以及页的顺序。根据测试人员的反馈，进行按页加载缓存优化能减少5%~8%的CPU占用，使用的内存也有一定的下降。还是有很明显的优化效果的。</p>\n<p>​</p>\n</li>\n</ul>\n</li>\n<li><h4 id=\"后台线程处理图片\"><a href=\"#后台线程处理图片\" class=\"headerlink\" title=\"后台线程处理图片\"></a>后台线程处理图片</h4><p>圆形头像、图片裁圆角等处理可以说是非常常见的需求了，包括从iOS11的系统各处都能看到，整体的页面控件都变得更加圆润了。但是，对图片处理必然是消耗资源的，实现过图片圆角效果的应该都知道，最简单的就是 layer.cornerRadius+layer.masksToBounds 的方式，但是这种做法在tableview中往往会是滚动变得卡顿，因为这种实现方式会触发离屏渲染，屏幕外缓冲区跟当前屏幕缓冲区上下文切换是很耗性能的，所以离屏渲染往往会造成卡顿(参考：<a href=\"http://www.jianshu.com/p/6d24a4c29e18\" target=\"_blank\" rel=\"external\">iOS 离屏渲染的研究</a>)。</p>\n<p>那要怎么处理图片呢？可以使用Core Graphics，CoreGraphic通常是线程安全的，所以可以进行异步绘制，显示的时候再放回主线程。我们在项目中实现了一个后台处理图片的框架，核心代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSBlockOperation *transformOperation = [[NSBlockOperation alloc] init];</div><div class=\"line\">    [transformOperation addExecutionBlock:^&#123;        </div><div class=\"line\">        // 此处处理图片</div><div class=\"line\">      \t...</div><div class=\"line\">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">          \t    // 主线程设置图片</div><div class=\"line\">                [self setImage:transformedImage forState:UIControlStateNormal];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;];</div></pre></td></tr></table></figure>\n<p>​</p>\n<p>​</p>\n</li>\n<li><h4 id=\"更加高效的控件\"><a href=\"#更加高效的控件\" class=\"headerlink\" title=\"更加高效的控件\"></a>更加高效的控件</h4><p>还可以直接从开源库中选用更加高效的控件替换项目中性能没那么好的控件。项目中将之前的TTTAttributedLabel、M80AttributedLabel全部替换为YYLabel，开启YYLabel的displaysAsynchronously、ignoreCommonProperties属性可以异步绘制文本以及忽略不需要的属性。更加追求性能的话，可以结合第1点的提前布局机制，在提前布局的阶段生成好YYLabel渲染时用到的textLayout，显示的时候直接赋值textLayout就可以了。</p>\n<p>​</p>\n</li>\n<li><h4 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h4><p>还有一些比较微小的优化，对性能可以说没有多大的影响，但是可以在开发阶段稍加留意，养成良好的习惯。</p>\n<ul>\n<li>尽量减少视图层级，合并多余的视图。同样以 <strong>ZAKER</strong> 为例，用户显示时的蓝V标签、达人标签以及楼主图片等几个视图，之前是用不同的view来展示的，优化过程将这几个view合并为一个view，一个view管理这些相似的事物，也可以减少某些相同逻辑的代码。</li>\n<li>减少频繁的addSubview、removeSubview，remove之后视图的实例对象会被释放，再add的时候会再次调用初始化函数。可以用hidden属性隐藏不显示的视图。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"接下来的方向\"><a href=\"#接下来的方向\" class=\"headerlink\" title=\"接下来的方向\"></a>接下来的方向</h3><ol>\n<li><h4 id=\"异步绘制\"><a href=\"#异步绘制\" class=\"headerlink\" title=\"异步绘制\"></a>异步绘制</h4><p>从开始接触我们就一直在被告知，UIKit的东西是绝对不能在后台线程调用的，一定得在主线程调用，所以主线程也被叫做UI线程。在后台线程调用UIKit的东西有一定几率导致崩溃，或者出现视图不显示、显示错乱等等问题。但是呢，根据刚刚所说的，Core Graphics的那一套东西是线程安全的，所以可以通过Core Graphics在后台将视图渲染到一张图片上，显示的时候在主线程将这张图片设置到相应位置上。Facebook著名的AsyncDisplayKit的核心实现应该也是基于这个原理，接下来的优化可以尝试这个方案。</p>\n<p>​</p>\n</li>\n<li><h4 id=\"Metal\"><a href=\"#Metal\" class=\"headerlink\" title=\"Metal\"></a>Metal</h4><p>根据Apple官方说法，Metal框架被设计用来实现两个目标: 3D 图形渲染和并行计算。这两者有很多共同点。它们都在数量庞大的数据上并行运行特殊的代码，并可以在GPU上执行。目前正在研究学习阶段，看项目中是否能利用Metal进行一定的优化。</p>\n<p>​</p>\n</li>\n<li><h4 id=\"APM\"><a href=\"#APM\" class=\"headerlink\" title=\"APM??\"></a>APM??</h4><p>Application Performance Management(APM)：应用程序性能管理， 通过对应用的可靠性、稳定性等方面的监控，进而达到可以快速修复问题、提高用户体验的目的。目前比较有代表性的 APM 产品有：听云、阿里百川、腾讯bugly等，现在也在考虑自己研发一套APM系统，先从比较简单的指标入手，先对卡顿和崩溃这两个指标着手，做的顺利的话再逐步扩展别的指标的检测管理。</p>\n</li>\n</ol>\n<p>以上。</p>\n","excerpt":"","more":"<p><em>最近在公司内部做了一个分享会，探讨了iOS性能优化的话题，现在将重点的内容整理好发出来，各位大牛斧正。</em></p>\n<p>本文将从原理出发，解释卡顿发生的原理，然后会讲解项目中行之有效的几个优化点，最后会展望一下接下来将要尝试的方向。下面进入正题。</p>\n<h3 id=\"屏幕显示的原理\"><a href=\"#屏幕显示的原理\" class=\"headerlink\" title=\"屏幕显示的原理\"></a>屏幕显示的原理</h3><h4 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/698554-f81809fe17a003e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕显示\"></p>\n<p>我们知道，远古时代的CRT显示器的显示原理是用电子枪扫描荧光屏来发光。如上图所示，电子枪按照从左到右，从上到下的顺序扫描。当电子枪换到新的一行准备进行扫描时，也就是上图A4、B4、C4、D4的位置，显示器会发出一个水平同步信号；而当一帧画面绘制完成后，电子枪回复到原位准备画下一帧前，也就是上图D4的位置，显示器会发出一个垂直同步信号。垂直同步信号的作用一方面是通知显示器回到A1位置，另外一方面，也通知显卡，准备输出下一帧画面。现在已经是液晶显示器的时代了，不再使用电子枪扫描了，但是原理还是类似的，水平同步信号和垂直同步信号还是一样被使用的。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-10c8e7e137166beb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"计算机工作原理\"></p>\n<p>计算机系统的工作原理如上图所示：首先是CPU的工作，包括创建视图分配内存、计算布局、图片解码以及文本绘制等；接下来轮到GPU工作了，GPU负责视图变换、合成和渲染等；GPU渲染完提交到帧缓冲区中，等收到垂直同步信号后将帧缓冲区的内容显示到屏幕上。</p>\n<h4 id=\"屏幕撕裂-Screen-tearing\"><a href=\"#屏幕撕裂-Screen-tearing\" class=\"headerlink\" title=\"屏幕撕裂(Screen tearing)\"></a>屏幕撕裂(Screen tearing)</h4><p>上述的简单的屏幕显示原理其实会产生这样一个问题：假设我们的显卡速度很快，每秒生产的帧数肯定要超过显示器刷新率。那么在实际数据处理过程中，缓冲区的数据，在被输出之前，就被显卡不断的刷新重写。但是缓冲区并不是“先清空再写入数据”，这太没有效率，而是采用“新数据覆盖老数据”的方式。</p>\n<p>假设这样一种情况，缓冲区已经有一副完整的帧画面（A帧），然后显卡生成了下一帧画面（B帧），新一帧的数据开始写入缓冲区，写到一半的时候，垂直同步信号来了，于是缓冲区的数据被输出到显示器。但问题是，这时缓冲区的数据，是由一半A帧和一半B帧数据合成的。因此最终显示器上显示出来的画面就不是一副完整的画面，这就是“画面撕裂”现象出现的原因，如下图。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-66bc0d60d4a305c8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕撕裂\"></p>\n<p>那怎样才能解决画面撕裂的问题呢？简单来说只要让帧缓冲区里的数据始终保持一副完整的画面就可以了。从技术角度出发，其实就是利用刚刚提到的垂直同步信号。</p>\n<p>具体说起来就是，当显卡生成了一副完整画面并写入了帧缓冲区之后，暂停！然后开始等待垂直同步信号，当得到垂直同步信号后，再继续渲染下一帧写入缓冲区。这样就可以保证在缓冲区的数据始终是一副完整的画面，不会出现前后帧混合的问题。</p>\n<h4 id=\"卡顿产生原因\"><a href=\"#卡顿产生原因\" class=\"headerlink\" title=\"卡顿产生原因\"></a>卡顿产生原因</h4><p>但是呢，垂直同步机制带来了一个新的问题 —— 掉帧。所谓的掉帧，跟垂直同步有一定关系，因为垂直同步机制决定了如果在一个时钟周期内CPU或者GPU没有完成各自的任务的话，就会将帧缓冲区里的内容直接丢弃！掉帧并不能完全怪罪于垂直同步机制，更重要的原因是我们作为开发者没有进行足够的优化，将过重的任务派发到了CPU或者GPU上，下图(from：<a href=\"https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/\">iOS 保持界面流畅的技巧</a>)是掉帧的图示，表明CPU或者GPU任意一个没能在时钟周期内完成自己的任务的话都会导致卡顿掉帧。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-75e20f80bb5101f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"卡顿\"></p>\n<h3 id=\"行之有效的优化点\"><a href=\"#行之有效的优化点\" class=\"headerlink\" title=\"行之有效的优化点\"></a>行之有效的优化点</h3><ol>\n<li><h4 id=\"提前布局\"><a href=\"#提前布局\" class=\"headerlink\" title=\"提前布局\"></a>提前布局</h4><p>提前布局可以说是最重要的优化点了。其实在从服务端拿到 JSON 数据的时候，关于视图的布局就已经确定了，包括每个控件的frame、cell的高度以及文本排版结果等等，在这个时候完全可以在后台线程计算并封装为对应的布局对象XXXTableViewCellLayout，每个cellLayout的内存占用并不是很多，所以直接全部缓存到内存中。当列表滚动到某个cell的时候，直接拿到对应的cellLayout配置这个cell的对应属性即可。当然，该有的计算是免不了的，只是提前算好并缓存，免去了在滚动的时候计算和重复的计算。通过这一个优化，将本来的fps50的列表优化到了55、56左右，可以说从肉眼上已经看不出有卡顿掉帧了。</p>\n<p>​</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-6b21937ce6754567.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"cellLayout示例图\"></p>\n<p>上图是项目中某个cellLayout的部分代码，可以看到里面存的就是所有控件的frame和文本的排版结果而已，里面没有任何的黑科技，只是将本来在滚动中才做的事情提前了而已。</p>\n<p>​</p>\n</li>\n<li><h4 id=\"按页加载缓存\"><a href=\"#按页加载缓存\" class=\"headerlink\" title=\"按页加载缓存\"></a>按页加载缓存</h4><ul>\n<li><p>现状分析：90%的APP有tableview，90%的tableview里有上拉刷新和下拉加载。以我司的项目<strong>ZAKER</strong>中的热点新闻界面为例，简单流程大概是这样的：①应用启动的时候会将磁盘中所有的新闻一次性读取出来显示到屏幕上； ②在每次下拉刷新和上拉加载的时候会将内存中所有新闻缓存到磁盘中，也即全量读写。这意味着大部分的新闻数据会反复写入到磁盘中，这样的写入是冗余的，因为前面的这些新闻数据并没有发生改变。</p>\n<p>​</p>\n</li>\n<li><p>改进方案：所以优化的方法就是将这些列表数组进行分割，分割成一页一页，每次写入的数据量很小，而且避免了冗余写入的问题。现在的流程变为：①启动时只读取第一批新闻显示在屏幕中；②下拉刷新和上拉加载的时候只把当前服务器返回的一批新闻写入缓存中；③在上拉加载的时候会先查看磁盘中是否有未读的缓存，若有则读取缓存，否则才从服务器下载一批新的文章。</p>\n<p>​</p>\n</li>\n<li><p>直观图示：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-ba7a27262a9e0931.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"按页缓存\"></p>\n<p>可以看到，优化之前整个新闻列表以及其他配置都在一个文件里，刷新10几次之后文件大小达到2MB，并且随着不断刷新而越来越大；优化之后，其他的配置还是在刚刚的文件中，但是不断增长的新闻数组被分割成一页一页的文件，每一页里面有10多条的新闻数据，同时有一个configure文件保存这些页的信息以及页的顺序。根据测试人员的反馈，进行按页加载缓存优化能减少5%~8%的CPU占用，使用的内存也有一定的下降。还是有很明显的优化效果的。</p>\n<p>​</p>\n</li>\n</ul>\n</li>\n<li><h4 id=\"后台线程处理图片\"><a href=\"#后台线程处理图片\" class=\"headerlink\" title=\"后台线程处理图片\"></a>后台线程处理图片</h4><p>圆形头像、图片裁圆角等处理可以说是非常常见的需求了，包括从iOS11的系统各处都能看到，整体的页面控件都变得更加圆润了。但是，对图片处理必然是消耗资源的，实现过图片圆角效果的应该都知道，最简单的就是 layer.cornerRadius+layer.masksToBounds 的方式，但是这种做法在tableview中往往会是滚动变得卡顿，因为这种实现方式会触发离屏渲染，屏幕外缓冲区跟当前屏幕缓冲区上下文切换是很耗性能的，所以离屏渲染往往会造成卡顿(参考：<a href=\"http://www.jianshu.com/p/6d24a4c29e18\">iOS 离屏渲染的研究</a>)。</p>\n<p>那要怎么处理图片呢？可以使用Core Graphics，CoreGraphic通常是线程安全的，所以可以进行异步绘制，显示的时候再放回主线程。我们在项目中实现了一个后台处理图片的框架，核心代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSBlockOperation *transformOperation = [[NSBlockOperation alloc] init];</div><div class=\"line\">    [transformOperation addExecutionBlock:^&#123;        </div><div class=\"line\">        // 此处处理图片</div><div class=\"line\">      \t...</div><div class=\"line\">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">          \t    // 主线程设置图片</div><div class=\"line\">                [self setImage:transformedImage forState:UIControlStateNormal];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;];</div></pre></td></tr></table></figure>\n<p>​</p>\n<p>​</p>\n</li>\n<li><h4 id=\"更加高效的控件\"><a href=\"#更加高效的控件\" class=\"headerlink\" title=\"更加高效的控件\"></a>更加高效的控件</h4><p>还可以直接从开源库中选用更加高效的控件替换项目中性能没那么好的控件。项目中将之前的TTTAttributedLabel、M80AttributedLabel全部替换为YYLabel，开启YYLabel的displaysAsynchronously、ignoreCommonProperties属性可以异步绘制文本以及忽略不需要的属性。更加追求性能的话，可以结合第1点的提前布局机制，在提前布局的阶段生成好YYLabel渲染时用到的textLayout，显示的时候直接赋值textLayout就可以了。</p>\n<p>​</p>\n</li>\n<li><h4 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h4><p>还有一些比较微小的优化，对性能可以说没有多大的影响，但是可以在开发阶段稍加留意，养成良好的习惯。</p>\n<ul>\n<li>尽量减少视图层级，合并多余的视图。同样以 <strong>ZAKER</strong> 为例，用户显示时的蓝V标签、达人标签以及楼主图片等几个视图，之前是用不同的view来展示的，优化过程将这几个view合并为一个view，一个view管理这些相似的事物，也可以减少某些相同逻辑的代码。</li>\n<li>减少频繁的addSubview、removeSubview，remove之后视图的实例对象会被释放，再add的时候会再次调用初始化函数。可以用hidden属性隐藏不显示的视图。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"接下来的方向\"><a href=\"#接下来的方向\" class=\"headerlink\" title=\"接下来的方向\"></a>接下来的方向</h3><ol>\n<li><h4 id=\"异步绘制\"><a href=\"#异步绘制\" class=\"headerlink\" title=\"异步绘制\"></a>异步绘制</h4><p>从开始接触我们就一直在被告知，UIKit的东西是绝对不能在后台线程调用的，一定得在主线程调用，所以主线程也被叫做UI线程。在后台线程调用UIKit的东西有一定几率导致崩溃，或者出现视图不显示、显示错乱等等问题。但是呢，根据刚刚所说的，Core Graphics的那一套东西是线程安全的，所以可以通过Core Graphics在后台将视图渲染到一张图片上，显示的时候在主线程将这张图片设置到相应位置上。Facebook著名的AsyncDisplayKit的核心实现应该也是基于这个原理，接下来的优化可以尝试这个方案。</p>\n<p>​</p>\n</li>\n<li><h4 id=\"Metal\"><a href=\"#Metal\" class=\"headerlink\" title=\"Metal\"></a>Metal</h4><p>根据Apple官方说法，Metal框架被设计用来实现两个目标: 3D 图形渲染和并行计算。这两者有很多共同点。它们都在数量庞大的数据上并行运行特殊的代码，并可以在GPU上执行。目前正在研究学习阶段，看项目中是否能利用Metal进行一定的优化。</p>\n<p>​</p>\n</li>\n<li><h4 id=\"APM\"><a href=\"#APM\" class=\"headerlink\" title=\"APM??\"></a>APM??</h4><p>Application Performance Management(APM)：应用程序性能管理， 通过对应用的可靠性、稳定性等方面的监控，进而达到可以快速修复问题、提高用户体验的目的。目前比较有代表性的 APM 产品有：听云、阿里百川、腾讯bugly等，现在也在考虑自己研发一套APM系统，先从比较简单的指标入手，先对卡顿和崩溃这两个指标着手，做的顺利的话再逐步扩展别的指标的检测管理。</p>\n</li>\n</ol>\n<p>以上。</p>\n"},{"title":"ruanpapa和又吉君的日常之一","date":"2017-04-01T01:39:53.000Z","_content":"\n## ruanpapa和又吉君的日常\n> ruanpapa最近做了个开源的圆角裁剪工具，期间那是被我各种嫌弃啊！代码放一边不说，反正是开源的，大家拿去用用看就行。\n### 但是！！！里面的各种展示图片简直！\n### 丑！！很丑！！没有更丑！！\n> 于是.....\n\n* “ruanpapa！！！！啊啊啊啊！你看看你这个线怎么像猪八戒的耙子！！”\n* “你不能把这个弄成圆角么！！”\n* “啊！！！你这个选图不行啊！头像图片选的颜色太杂了！”\n* “你这边框，这么细，加了和没加有什么区别！”\n* ........  \n  ![能怎么办](http://upload-images.jianshu.io/upload_images/5431890-59a692e2f42c5d25.jpg)\n  <p align=\"center\"><font color=\"9E9E9E\"><u>能怎么办</u></font></p>\n  <br>\n\n> #### 万般无奈之下，又吉君开始了“设计之旅”\n> 于是.....  \n> 这张充满了直男癌风格的展示图就可爱了！\n>\n> ![喏，展示图](http://upload-images.jianshu.io/upload_images/5431890-ebd81b62a0a5ce02.jpg)\n> <p align=\"center\"><font color=\"9E9E9E\"><u>喏，展示图</u></font></p>\n> <br>\n> **还有经过多次失败弄出来的图标...**\n>\n> ![么么扎٩(๑❛ᴗ❛๑)۶](http://upload-images.jianshu.io/upload_images/5431890-26b53c04af1d3859.jpg)\n> <p align=\"center\"><font color=\"9E9E9E\"><u>么么扎٩(๑❛ᴗ❛๑)۶</u></font></p>\n> <br>\n\n\n\n\n- 啊哈哈哈哈哈哈哈哈哈！！！实际上我ruanpapa设计的也挺好看的！但是我就是喜欢我弄的！！！！\n- 我是又吉君，一个集ruanpapa和智慧于一身的大可爱！\n- 嚯嚯嚯嚯嚯嚯嚯！！\n  <br>\n  <br>\n  <p align=\"right\">by：又吉君</p>\n","source":"_posts/ruanpapa和又吉君的日常之一.md","raw":"---\ntitle: ruanpapa和又吉君的日常之一\ndate: 2017-04-01 09:39:53\ntags:\ncategories:\n- ruanpapa&又吉君的日常\n---\n\n## ruanpapa和又吉君的日常\n> ruanpapa最近做了个开源的圆角裁剪工具，期间那是被我各种嫌弃啊！代码放一边不说，反正是开源的，大家拿去用用看就行。\n### 但是！！！里面的各种展示图片简直！\n### 丑！！很丑！！没有更丑！！\n> 于是.....\n\n* “ruanpapa！！！！啊啊啊啊！你看看你这个线怎么像猪八戒的耙子！！”\n* “你不能把这个弄成圆角么！！”\n* “啊！！！你这个选图不行啊！头像图片选的颜色太杂了！”\n* “你这边框，这么细，加了和没加有什么区别！”\n* ........  \n  ![能怎么办](http://upload-images.jianshu.io/upload_images/5431890-59a692e2f42c5d25.jpg)\n  <p align=\"center\"><font color=\"9E9E9E\"><u>能怎么办</u></font></p>\n  <br>\n\n> #### 万般无奈之下，又吉君开始了“设计之旅”\n> 于是.....  \n> 这张充满了直男癌风格的展示图就可爱了！\n>\n> ![喏，展示图](http://upload-images.jianshu.io/upload_images/5431890-ebd81b62a0a5ce02.jpg)\n> <p align=\"center\"><font color=\"9E9E9E\"><u>喏，展示图</u></font></p>\n> <br>\n> **还有经过多次失败弄出来的图标...**\n>\n> ![么么扎٩(๑❛ᴗ❛๑)۶](http://upload-images.jianshu.io/upload_images/5431890-26b53c04af1d3859.jpg)\n> <p align=\"center\"><font color=\"9E9E9E\"><u>么么扎٩(๑❛ᴗ❛๑)۶</u></font></p>\n> <br>\n\n\n\n\n- 啊哈哈哈哈哈哈哈哈哈！！！实际上我ruanpapa设计的也挺好看的！但是我就是喜欢我弄的！！！！\n- 我是又吉君，一个集ruanpapa和智慧于一身的大可爱！\n- 嚯嚯嚯嚯嚯嚯嚯！！\n  <br>\n  <br>\n  <p align=\"right\">by：又吉君</p>\n","slug":"ruanpapa和又吉君的日常之一","published":1,"updated":"2017-04-10T00:52:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg4j8vyk000kvfwxk9xp1jyi","content":"<h2 id=\"ruanpapa和又吉君的日常\"><a href=\"#ruanpapa和又吉君的日常\" class=\"headerlink\" title=\"ruanpapa和又吉君的日常\"></a>ruanpapa和又吉君的日常</h2><blockquote>\n<p>ruanpapa最近做了个开源的圆角裁剪工具，期间那是被我各种嫌弃啊！代码放一边不说，反正是开源的，大家拿去用用看就行。</p>\n<h3 id=\"但是！！！里面的各种展示图片简直！\"><a href=\"#但是！！！里面的各种展示图片简直！\" class=\"headerlink\" title=\"但是！！！里面的各种展示图片简直！\"></a>但是！！！里面的各种展示图片简直！</h3><h3 id=\"丑！！很丑！！没有更丑！！\"><a href=\"#丑！！很丑！！没有更丑！！\" class=\"headerlink\" title=\"丑！！很丑！！没有更丑！！\"></a>丑！！很丑！！没有更丑！！</h3><p>于是…..</p>\n</blockquote>\n<ul>\n<li>“ruanpapa！！！！啊啊啊啊！你看看你这个线怎么像猪八戒的耙子！！”</li>\n<li>“你不能把这个弄成圆角么！！”</li>\n<li>“啊！！！你这个选图不行啊！头像图片选的颜色太杂了！”</li>\n<li>“你这边框，这么细，加了和没加有什么区别！”</li>\n<li>……..<br><img src=\"http://upload-images.jianshu.io/upload_images/5431890-59a692e2f42c5d25.jpg\" alt=\"能怎么办\"><br><p align=\"center\"><font color=\"9E9E9E\"><u>能怎么办</u></font></p><br><br></li>\n</ul>\n<blockquote>\n<h4 id=\"万般无奈之下，又吉君开始了“设计之旅”\"><a href=\"#万般无奈之下，又吉君开始了“设计之旅”\" class=\"headerlink\" title=\"万般无奈之下，又吉君开始了“设计之旅”\"></a>万般无奈之下，又吉君开始了“设计之旅”</h4><p>于是…..<br>这张充满了直男癌风格的展示图就可爱了！</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-ebd81b62a0a5ce02.jpg\" alt=\"喏，展示图\"></p>\n<p></p><p align=\"center\"><font color=\"9E9E9E\"><u>喏，展示图</u></font></p><br><br><br><strong>还有经过多次失败弄出来的图标…</strong><p></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-26b53c04af1d3859.jpg\" alt=\"么么扎٩(๑❛ᴗ❛๑)۶\"></p>\n<p></p><p align=\"center\"><font color=\"9E9E9E\"><u>么么扎٩(๑❛ᴗ❛๑)۶</u></font></p><br><br><p></p>\n</blockquote>\n<ul>\n<li>啊哈哈哈哈哈哈哈哈哈！！！实际上我ruanpapa设计的也挺好看的！但是我就是喜欢我弄的！！！！</li>\n<li>我是又吉君，一个集ruanpapa和智慧于一身的大可爱！</li>\n<li>嚯嚯嚯嚯嚯嚯嚯！！<br><br><br><br><p align=\"right\">by：又吉君</p>\n</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"ruanpapa和又吉君的日常\"><a href=\"#ruanpapa和又吉君的日常\" class=\"headerlink\" title=\"ruanpapa和又吉君的日常\"></a>ruanpapa和又吉君的日常</h2><blockquote>\n<p>ruanpapa最近做了个开源的圆角裁剪工具，期间那是被我各种嫌弃啊！代码放一边不说，反正是开源的，大家拿去用用看就行。</p>\n<h3 id=\"但是！！！里面的各种展示图片简直！\"><a href=\"#但是！！！里面的各种展示图片简直！\" class=\"headerlink\" title=\"但是！！！里面的各种展示图片简直！\"></a>但是！！！里面的各种展示图片简直！</h3><h3 id=\"丑！！很丑！！没有更丑！！\"><a href=\"#丑！！很丑！！没有更丑！！\" class=\"headerlink\" title=\"丑！！很丑！！没有更丑！！\"></a>丑！！很丑！！没有更丑！！</h3><p>于是…..</p>\n</blockquote>\n<ul>\n<li>“ruanpapa！！！！啊啊啊啊！你看看你这个线怎么像猪八戒的耙子！！”</li>\n<li>“你不能把这个弄成圆角么！！”</li>\n<li>“啊！！！你这个选图不行啊！头像图片选的颜色太杂了！”</li>\n<li>“你这边框，这么细，加了和没加有什么区别！”</li>\n<li>……..<br><img src=\"http://upload-images.jianshu.io/upload_images/5431890-59a692e2f42c5d25.jpg\" alt=\"能怎么办\"><br><p align=\"center\"><font color=\"9E9E9E\"><u>能怎么办</u></font></p><br><br></li>\n</ul>\n<blockquote>\n<h4 id=\"万般无奈之下，又吉君开始了“设计之旅”\"><a href=\"#万般无奈之下，又吉君开始了“设计之旅”\" class=\"headerlink\" title=\"万般无奈之下，又吉君开始了“设计之旅”\"></a>万般无奈之下，又吉君开始了“设计之旅”</h4><p>于是…..<br>这张充满了直男癌风格的展示图就可爱了！</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-ebd81b62a0a5ce02.jpg\" alt=\"喏，展示图\"></p>\n<p><p align=\"center\"><font color=\"9E9E9E\"><u>喏，展示图</u></font></p><br><br><br><strong>还有经过多次失败弄出来的图标…</strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-26b53c04af1d3859.jpg\" alt=\"么么扎٩(๑❛ᴗ❛๑)۶\"></p>\n<p><p align=\"center\"><font color=\"9E9E9E\"><u>么么扎٩(๑❛ᴗ❛๑)۶</u></font></p><br><br></p>\n</blockquote>\n<ul>\n<li>啊哈哈哈哈哈哈哈哈哈！！！实际上我ruanpapa设计的也挺好看的！但是我就是喜欢我弄的！！！！</li>\n<li>我是又吉君，一个集ruanpapa和智慧于一身的大可爱！</li>\n<li>嚯嚯嚯嚯嚯嚯嚯！！<br><br><br><br><p align=\"right\">by：又吉君</p>\n</li>\n</ul>\n"},{"title":"iOS表情键盘的完整实现","date":"2018-01-19T15:55:51.000Z","_content":"\n\n\n最近在公司做了个表情键盘的需求，这个需求的技术难度不会很大，比较偏向业务。但是要把用户体验做的好也是不容易的，其中有几个点需要特别注意。话不多说，下面开始正文(注：本文对应的Demo放在Github上：[https://github.com/VernonVan/PPStickerKeyboard](https://github.com/VernonVan/PPStickerKeyboard))。\n\n## 市面上的表情键盘的分析\n\n首先来看一下市面上主要的几个APP上的表情键盘，平时使用的时候不会去关注细节，这次特意去使用了表情键盘，发现各个APP的体验还是有优有劣的。\n\n首先是QQ和微信，这两者差不多，切换到表情键盘的时候都是没有光标的，这样的用户体验是非常不好的，没有办法在输入表情的时候框选区域，也不能拖动光标进行特定位置的复制黏贴删除等操作，微信甚至在输入框里显示的都不是点击的表情图片，而是文字描述。\n\n![微信QQ表情键盘.JPG](http://upload-images.jianshu.io/upload_images/698554-2c59f42aa0dd0dd1.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n接下来看一下微博国际版，国际版调起表情键盘时是有光标的，是一个\"真正的\"键盘，但是想要拖拽光标的时候，很大概率上会触发到保存图片的行为（如下图所示），导致根本没办法拖动光标。\n![微博国际版误触.JPG](http://upload-images.jianshu.io/upload_images/698554-5f667795a7778a6e.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n同时微博国际版输入框表情黏贴后的光标定位是错误的，如下图，开始时光标是在第4个表情后面，然后复制狗头+害羞两个表情黏贴到光标后，光标还是在第4个表情后，同时黏贴的表情前后都莫名多了空格。\n![微博国际版黏贴.JPG](http://upload-images.jianshu.io/upload_images/698554-d4cddecefc22cfc9.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n最后是微博，微博客户端的表情键盘的体验是非常好的，上面说到的问题都不存在，而且表情键盘的删除按钮还能长按删除输入框的内容。\n![微博表情键盘.jpg](http://upload-images.jianshu.io/upload_images/698554-63023d1dfcce132b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 表情键盘的实现\n\n#### 实现效果\n\n主要实现了以下几个功能\n\n- 能输入表情，有光标，支持复制黏贴删除表情等\n- 长按预览表情\n- 删除表情、长按连续删除表情\n- 适配 iPhone X\n  ![演示.GIF](http://upload-images.jianshu.io/upload_images/698554-9d1661ee627dc3ca.GIF?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 基本思路\n\n首先，表情包的图片是用bundle的形式组织的，用`PPSticker`类表征一套表情包，用`PPEmoji`类表征某一个表情，用一个plist作为配置文件，存储表情包的信息。\n![表情的组织.jpg](http://upload-images.jianshu.io/upload_images/698554-10847f03391e9560.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n`PPStickerDataManager`类主要负责数据部分，用单例的形式，这样可以在初始化的时候只会读取一次plist文件中的所有表情信息；同时我们把输入框内容发到服务端以及从服务端请求到的都是纯文本的，比如会把 \"笑死了🤣\" 转成 \"笑死了[笑哭]\" 这样的纯文本，而不是直接把表情图片直接发到服务端，也就是说项目中有大量的地方会有把文本->表情的操作，所以`PPStickerDataManager`类也提供匹配某段纯文本中的表情，并把文本替换为图片的功能，`PPStickerDataManager`类的头文件如下：\n\n```objective-c\n@interface PPStickerDataManager : NSObject\n\n+ (instancetype)sharedInstance;\n\n/// 所有的表情包\n@property (nonatomic, strong, readonly) NSArray<PPSticker *> *allStickers;\n\n/* 匹配给定attributedString中的所有emoji，如果匹配到的emoji有本地图片的话会直接换成本地的图片\n *\n * @param attributedString 可能包含表情包的attributedString\n * @param font 表情图片的对齐字体大小\n */\n- (void)replaceEmojiForAttributedString:(NSMutableAttributedString *)attributedString font:(UIFont *)font;\n\n@end\n```\n\n#### \"真正的\"键盘\n\n真正的键盘也就是说调起表情键盘时输入框是有光标的，能进行拖拽光标、选中区域等的操作，这样的体验才是与系统键盘一致的。其实系统已经提供好了接口给我们直接使用，`UITextView`和`UITextField`都有的`inputView`和`inputAccessoryView`就是用来实现自定义键盘的，这两个属性的定义如下：\n\n```objective-c\n// Presented when object becomes first responder.  If set to nil, reverts to following responder chain.  If\n// set while first responder, will not take effect until reloadInputViews is called.\n@property (nullable, readwrite, strong) UIView *inputView;             \n@property (nullable, readwrite, strong) UIView *inputAccessoryView;\n```\n\n同时系统键盘在 设置->声音->按键音 选项打开且手机非静音状态下输入是有按键的声音的，这个按键音也是可以支持的，只要自定义键盘类遵循`UIInputViewAudioFeedback`协议，同时实现 `enableInputClicksWhenVisible`方法并返回YES，这样就可以在点击表情的时候调用`[[UIDevice currentDevice] playInputClick]`方法发出按键音了，详情请查看[苹果的官方文档](https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/InputViews/InputViews.html)。\n\n下面是Demo中键盘切换方法的实现：\n\n```objective-c\n- (void)changeKeyboardTo:(PPKeyboardType)toType\n{\n    switch (toType) {\n        case PPKeyboardTypeSystem:\n            self.textView.inputView = nil;    // 切换到系统键盘\n            [self.textView reloadInputViews]; // 调用reloadInputViews方法会立刻进行键盘的切换\n            break;\n        case PPKeyboardTypeSticker:            \n            self.textView.inputView = self.stickerKeyboard; // 切换到自定义的表情键盘\n            [self.textView reloadInputViews];\n            break;\n        default:\n            break;\n    }\n}\n```\n\n#### 去除表情的拖拽交互\n\n在iOS11上，`UITextView`上的`NSTextAttachment`（表情）默认可以进行拖拽交互，但是却导致拖动光标时很容易触发这个交互（图示可以查看上面说到的微博国际版中的误触）。一番查找之后才找到一个比较隐蔽的属性：`textDragInteraction`，直接设置为`NO`就能禁止掉`NSTextAttachment`的拖拽交互。\n\n```objective-c\nif (@available(iOS 11.0, *)) {\t// 只在iOS11及以上才有这个属性\n     _textView.textDragInteraction.enabled = NO;\n}\n```\n\n#### 与服务端的交互\n\n我们在输入框中输入的内容与服务端进行交互的时候都是用纯文本的，比如会把 \"笑死了🤣\" 转成 \"笑死了[笑哭]\" 这样的纯文本发到服务端，而不是直接发表情图片，向服务端请求内容的时候也是传回 \"笑死了[笑哭]\"，然后客户端再根据正则匹配找出表情替换成对应的表情图片，然后显示到页面上。具体过程可以看下图：\n![与服务端的交互.png](http://upload-images.jianshu.io/upload_images/698554-00199a31ec46945d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n也就是说，我们设置到输入框的`NSAttributedString`中的每一个`NSTextAttachment`都有一个\"隐藏的\"属性—表情的文本描述，这里对`NSAttributedString`进行拓展就能实现。`pp_setTextBackedString`可以对`NSAttributedString`的指定`range`设置一个`PPTextBackedString`类型的属性，而`pp_plainTextForRange`能拿到`NSAttributedString`指定`range`的纯文本。具体实现如下：\n\n```objective-c\n@implementation NSAttributedString (PPAddition)\n\n- (NSString *)pp_plainTextForRange:(NSRange)range\n{\n    if (range.location == NSNotFound || range.length == NSNotFound) {\n        return nil;\n    }\n\n    NSMutableString *result = [[NSMutableString alloc] init];\n    if (range.length == 0) {\n        return result;\n    }\n\n    NSString *string = self.string;\n    [self enumerateAttribute:PPTextBackedStringAttributeName inRange:range options:kNilOptions usingBlock:^(id value, NSRange range, BOOL *stop) {\n        PPTextBackedString *backed = value;\n        if (backed && backed.string) {\n            [result appendString:backed.string];\n        } else {\n            [result appendString:[string substringWithRange:range]];\n        }\n    }];\n    return result;\n}\n\n@end\n\n@implementation NSMutableAttributedString (PPAddition)\n\n- (void)pp_setTextBackedString:(PPTextBackedString *)textBackedString range:(NSRange)range\n{\n    if (textBackedString && ![NSNull isEqual:textBackedString]) {\n        [self addAttribute:PPTextBackedStringAttributeName value:textBackedString range:range];\n    } else {\n        [self removeAttribute:PPTextBackedStringAttributeName range:range];\n    }\n}\n\n@end\n```\n\n#### 灵活的光标\n\n表情功能，`UITextView`都是用`NSAttributedString`进行赋值的，并且我们底层其实还是用上面说到的纯文本进行实现的，那么把 [笑死] 转成 🤣 就会从4个字符变成1个字符，这里是有差值的，如果不处理的话就会出现上面提到的微博国际版中复制黏贴输入框的表情会导致光标位置不对，甚至莫名其妙多出前后空格的问题。为了精准的定位光标，我们需要自行处理好这些问题。\n\n这里自己继承并实现了`UITextView`的子类`PPStickerTextView`，在这个类中重载复制、黏贴、剪切等操作，分别对应的方法如下：\n\n```objective-c\n- (void)cut:(id)sender;\t\t// 剪切\n\n- (void)copy:(id)sender;\t// 复制\n\n- (void)paste:(id)sender;\t// 黏贴\n```\n\n下面以剪切方法举例，看看怎么处理光标的问题，需要注意的地方请看对应的注释：\n\n```objective-c\n- (void)cut:(id)sender\n{\n    // 1.从textView中拿到对应的纯文本，比如：笑死了[笑死]\n    NSString *string = [self.attributedText pp_plainTextForRange:self.selectedRange];\n    if (string.length) {\n      \t// 2. 将纯文本写入到剪贴板中\n        [UIPasteboard generalPasteboard].string = string;\n\n      \t// 3. 记住当前的光标位置\n        NSRange selectedRange = self.selectedRange;\n        NSMutableAttributedString *attributeContent = [[NSMutableAttributedString alloc] initWithAttributedString:self.attributedText];\n      \t// 4. 将检测到是表情的文本替换成对应的图片\n        [attributeContent replaceCharactersInRange:self.selectedRange withString:@\"\"];\n        self.attributedText = attributeContent;\n      \n      \t// 5. 重新设置光标\n        self.selectedRange = NSMakeRange(selectedRange.location, 0);\n    }\n}\n```\n\n技术点的分析就是以上这些，详细的代码可以clone代码查看：https://github.com/VernonVan/PPStickerKeyboard","source":"_posts/iOS表情键盘的完整实现.md","raw":"---\ntitle: iOS表情键盘的完整实现\ndate: 2018-01-19 23:55:51\ntags: \n- iOS\ncategories:\n- ruanpapa--技术贴\n---\n\n\n\n最近在公司做了个表情键盘的需求，这个需求的技术难度不会很大，比较偏向业务。但是要把用户体验做的好也是不容易的，其中有几个点需要特别注意。话不多说，下面开始正文(注：本文对应的Demo放在Github上：[https://github.com/VernonVan/PPStickerKeyboard](https://github.com/VernonVan/PPStickerKeyboard))。\n\n## 市面上的表情键盘的分析\n\n首先来看一下市面上主要的几个APP上的表情键盘，平时使用的时候不会去关注细节，这次特意去使用了表情键盘，发现各个APP的体验还是有优有劣的。\n\n首先是QQ和微信，这两者差不多，切换到表情键盘的时候都是没有光标的，这样的用户体验是非常不好的，没有办法在输入表情的时候框选区域，也不能拖动光标进行特定位置的复制黏贴删除等操作，微信甚至在输入框里显示的都不是点击的表情图片，而是文字描述。\n\n![微信QQ表情键盘.JPG](http://upload-images.jianshu.io/upload_images/698554-2c59f42aa0dd0dd1.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n接下来看一下微博国际版，国际版调起表情键盘时是有光标的，是一个\"真正的\"键盘，但是想要拖拽光标的时候，很大概率上会触发到保存图片的行为（如下图所示），导致根本没办法拖动光标。\n![微博国际版误触.JPG](http://upload-images.jianshu.io/upload_images/698554-5f667795a7778a6e.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n同时微博国际版输入框表情黏贴后的光标定位是错误的，如下图，开始时光标是在第4个表情后面，然后复制狗头+害羞两个表情黏贴到光标后，光标还是在第4个表情后，同时黏贴的表情前后都莫名多了空格。\n![微博国际版黏贴.JPG](http://upload-images.jianshu.io/upload_images/698554-d4cddecefc22cfc9.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n最后是微博，微博客户端的表情键盘的体验是非常好的，上面说到的问题都不存在，而且表情键盘的删除按钮还能长按删除输入框的内容。\n![微博表情键盘.jpg](http://upload-images.jianshu.io/upload_images/698554-63023d1dfcce132b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 表情键盘的实现\n\n#### 实现效果\n\n主要实现了以下几个功能\n\n- 能输入表情，有光标，支持复制黏贴删除表情等\n- 长按预览表情\n- 删除表情、长按连续删除表情\n- 适配 iPhone X\n  ![演示.GIF](http://upload-images.jianshu.io/upload_images/698554-9d1661ee627dc3ca.GIF?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 基本思路\n\n首先，表情包的图片是用bundle的形式组织的，用`PPSticker`类表征一套表情包，用`PPEmoji`类表征某一个表情，用一个plist作为配置文件，存储表情包的信息。\n![表情的组织.jpg](http://upload-images.jianshu.io/upload_images/698554-10847f03391e9560.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n`PPStickerDataManager`类主要负责数据部分，用单例的形式，这样可以在初始化的时候只会读取一次plist文件中的所有表情信息；同时我们把输入框内容发到服务端以及从服务端请求到的都是纯文本的，比如会把 \"笑死了🤣\" 转成 \"笑死了[笑哭]\" 这样的纯文本，而不是直接把表情图片直接发到服务端，也就是说项目中有大量的地方会有把文本->表情的操作，所以`PPStickerDataManager`类也提供匹配某段纯文本中的表情，并把文本替换为图片的功能，`PPStickerDataManager`类的头文件如下：\n\n```objective-c\n@interface PPStickerDataManager : NSObject\n\n+ (instancetype)sharedInstance;\n\n/// 所有的表情包\n@property (nonatomic, strong, readonly) NSArray<PPSticker *> *allStickers;\n\n/* 匹配给定attributedString中的所有emoji，如果匹配到的emoji有本地图片的话会直接换成本地的图片\n *\n * @param attributedString 可能包含表情包的attributedString\n * @param font 表情图片的对齐字体大小\n */\n- (void)replaceEmojiForAttributedString:(NSMutableAttributedString *)attributedString font:(UIFont *)font;\n\n@end\n```\n\n#### \"真正的\"键盘\n\n真正的键盘也就是说调起表情键盘时输入框是有光标的，能进行拖拽光标、选中区域等的操作，这样的体验才是与系统键盘一致的。其实系统已经提供好了接口给我们直接使用，`UITextView`和`UITextField`都有的`inputView`和`inputAccessoryView`就是用来实现自定义键盘的，这两个属性的定义如下：\n\n```objective-c\n// Presented when object becomes first responder.  If set to nil, reverts to following responder chain.  If\n// set while first responder, will not take effect until reloadInputViews is called.\n@property (nullable, readwrite, strong) UIView *inputView;             \n@property (nullable, readwrite, strong) UIView *inputAccessoryView;\n```\n\n同时系统键盘在 设置->声音->按键音 选项打开且手机非静音状态下输入是有按键的声音的，这个按键音也是可以支持的，只要自定义键盘类遵循`UIInputViewAudioFeedback`协议，同时实现 `enableInputClicksWhenVisible`方法并返回YES，这样就可以在点击表情的时候调用`[[UIDevice currentDevice] playInputClick]`方法发出按键音了，详情请查看[苹果的官方文档](https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/InputViews/InputViews.html)。\n\n下面是Demo中键盘切换方法的实现：\n\n```objective-c\n- (void)changeKeyboardTo:(PPKeyboardType)toType\n{\n    switch (toType) {\n        case PPKeyboardTypeSystem:\n            self.textView.inputView = nil;    // 切换到系统键盘\n            [self.textView reloadInputViews]; // 调用reloadInputViews方法会立刻进行键盘的切换\n            break;\n        case PPKeyboardTypeSticker:            \n            self.textView.inputView = self.stickerKeyboard; // 切换到自定义的表情键盘\n            [self.textView reloadInputViews];\n            break;\n        default:\n            break;\n    }\n}\n```\n\n#### 去除表情的拖拽交互\n\n在iOS11上，`UITextView`上的`NSTextAttachment`（表情）默认可以进行拖拽交互，但是却导致拖动光标时很容易触发这个交互（图示可以查看上面说到的微博国际版中的误触）。一番查找之后才找到一个比较隐蔽的属性：`textDragInteraction`，直接设置为`NO`就能禁止掉`NSTextAttachment`的拖拽交互。\n\n```objective-c\nif (@available(iOS 11.0, *)) {\t// 只在iOS11及以上才有这个属性\n     _textView.textDragInteraction.enabled = NO;\n}\n```\n\n#### 与服务端的交互\n\n我们在输入框中输入的内容与服务端进行交互的时候都是用纯文本的，比如会把 \"笑死了🤣\" 转成 \"笑死了[笑哭]\" 这样的纯文本发到服务端，而不是直接发表情图片，向服务端请求内容的时候也是传回 \"笑死了[笑哭]\"，然后客户端再根据正则匹配找出表情替换成对应的表情图片，然后显示到页面上。具体过程可以看下图：\n![与服务端的交互.png](http://upload-images.jianshu.io/upload_images/698554-00199a31ec46945d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n也就是说，我们设置到输入框的`NSAttributedString`中的每一个`NSTextAttachment`都有一个\"隐藏的\"属性—表情的文本描述，这里对`NSAttributedString`进行拓展就能实现。`pp_setTextBackedString`可以对`NSAttributedString`的指定`range`设置一个`PPTextBackedString`类型的属性，而`pp_plainTextForRange`能拿到`NSAttributedString`指定`range`的纯文本。具体实现如下：\n\n```objective-c\n@implementation NSAttributedString (PPAddition)\n\n- (NSString *)pp_plainTextForRange:(NSRange)range\n{\n    if (range.location == NSNotFound || range.length == NSNotFound) {\n        return nil;\n    }\n\n    NSMutableString *result = [[NSMutableString alloc] init];\n    if (range.length == 0) {\n        return result;\n    }\n\n    NSString *string = self.string;\n    [self enumerateAttribute:PPTextBackedStringAttributeName inRange:range options:kNilOptions usingBlock:^(id value, NSRange range, BOOL *stop) {\n        PPTextBackedString *backed = value;\n        if (backed && backed.string) {\n            [result appendString:backed.string];\n        } else {\n            [result appendString:[string substringWithRange:range]];\n        }\n    }];\n    return result;\n}\n\n@end\n\n@implementation NSMutableAttributedString (PPAddition)\n\n- (void)pp_setTextBackedString:(PPTextBackedString *)textBackedString range:(NSRange)range\n{\n    if (textBackedString && ![NSNull isEqual:textBackedString]) {\n        [self addAttribute:PPTextBackedStringAttributeName value:textBackedString range:range];\n    } else {\n        [self removeAttribute:PPTextBackedStringAttributeName range:range];\n    }\n}\n\n@end\n```\n\n#### 灵活的光标\n\n表情功能，`UITextView`都是用`NSAttributedString`进行赋值的，并且我们底层其实还是用上面说到的纯文本进行实现的，那么把 [笑死] 转成 🤣 就会从4个字符变成1个字符，这里是有差值的，如果不处理的话就会出现上面提到的微博国际版中复制黏贴输入框的表情会导致光标位置不对，甚至莫名其妙多出前后空格的问题。为了精准的定位光标，我们需要自行处理好这些问题。\n\n这里自己继承并实现了`UITextView`的子类`PPStickerTextView`，在这个类中重载复制、黏贴、剪切等操作，分别对应的方法如下：\n\n```objective-c\n- (void)cut:(id)sender;\t\t// 剪切\n\n- (void)copy:(id)sender;\t// 复制\n\n- (void)paste:(id)sender;\t// 黏贴\n```\n\n下面以剪切方法举例，看看怎么处理光标的问题，需要注意的地方请看对应的注释：\n\n```objective-c\n- (void)cut:(id)sender\n{\n    // 1.从textView中拿到对应的纯文本，比如：笑死了[笑死]\n    NSString *string = [self.attributedText pp_plainTextForRange:self.selectedRange];\n    if (string.length) {\n      \t// 2. 将纯文本写入到剪贴板中\n        [UIPasteboard generalPasteboard].string = string;\n\n      \t// 3. 记住当前的光标位置\n        NSRange selectedRange = self.selectedRange;\n        NSMutableAttributedString *attributeContent = [[NSMutableAttributedString alloc] initWithAttributedString:self.attributedText];\n      \t// 4. 将检测到是表情的文本替换成对应的图片\n        [attributeContent replaceCharactersInRange:self.selectedRange withString:@\"\"];\n        self.attributedText = attributeContent;\n      \n      \t// 5. 重新设置光标\n        self.selectedRange = NSMakeRange(selectedRange.location, 0);\n    }\n}\n```\n\n技术点的分析就是以上这些，详细的代码可以clone代码查看：https://github.com/VernonVan/PPStickerKeyboard","slug":"iOS表情键盘的完整实现","published":1,"updated":"2018-02-06T06:42:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg4j8vym000pvfwxc04mjsd5","content":"<p>最近在公司做了个表情键盘的需求，这个需求的技术难度不会很大，比较偏向业务。但是要把用户体验做的好也是不容易的，其中有几个点需要特别注意。话不多说，下面开始正文(注：本文对应的Demo放在Github上：<a href=\"https://github.com/VernonVan/PPStickerKeyboard\" target=\"_blank\" rel=\"external\">https://github.com/VernonVan/PPStickerKeyboard</a>)。</p>\n<h2 id=\"市面上的表情键盘的分析\"><a href=\"#市面上的表情键盘的分析\" class=\"headerlink\" title=\"市面上的表情键盘的分析\"></a>市面上的表情键盘的分析</h2><p>首先来看一下市面上主要的几个APP上的表情键盘，平时使用的时候不会去关注细节，这次特意去使用了表情键盘，发现各个APP的体验还是有优有劣的。</p>\n<p>首先是QQ和微信，这两者差不多，切换到表情键盘的时候都是没有光标的，这样的用户体验是非常不好的，没有办法在输入表情的时候框选区域，也不能拖动光标进行特定位置的复制黏贴删除等操作，微信甚至在输入框里显示的都不是点击的表情图片，而是文字描述。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-2c59f42aa0dd0dd1.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"微信QQ表情键盘.JPG\"></p>\n<p>接下来看一下微博国际版，国际版调起表情键盘时是有光标的，是一个”真正的”键盘，但是想要拖拽光标的时候，很大概率上会触发到保存图片的行为（如下图所示），导致根本没办法拖动光标。<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-5f667795a7778a6e.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"微博国际版误触.JPG\"></p>\n<p>同时微博国际版输入框表情黏贴后的光标定位是错误的，如下图，开始时光标是在第4个表情后面，然后复制狗头+害羞两个表情黏贴到光标后，光标还是在第4个表情后，同时黏贴的表情前后都莫名多了空格。<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-d4cddecefc22cfc9.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"微博国际版黏贴.JPG\"></p>\n<p>最后是微博，微博客户端的表情键盘的体验是非常好的，上面说到的问题都不存在，而且表情键盘的删除按钮还能长按删除输入框的内容。<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-63023d1dfcce132b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"微博表情键盘.jpg\"></p>\n<h2 id=\"表情键盘的实现\"><a href=\"#表情键盘的实现\" class=\"headerlink\" title=\"表情键盘的实现\"></a>表情键盘的实现</h2><h4 id=\"实现效果\"><a href=\"#实现效果\" class=\"headerlink\" title=\"实现效果\"></a>实现效果</h4><p>主要实现了以下几个功能</p>\n<ul>\n<li>能输入表情，有光标，支持复制黏贴删除表情等</li>\n<li>长按预览表情</li>\n<li>删除表情、长按连续删除表情</li>\n<li>适配 iPhone X<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-9d1661ee627dc3ca.GIF?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"演示.GIF\"></li>\n</ul>\n<h4 id=\"基本思路\"><a href=\"#基本思路\" class=\"headerlink\" title=\"基本思路\"></a>基本思路</h4><p>首先，表情包的图片是用bundle的形式组织的，用<code>PPSticker</code>类表征一套表情包，用<code>PPEmoji</code>类表征某一个表情，用一个plist作为配置文件，存储表情包的信息。<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-10847f03391e9560.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"表情的组织.jpg\"></p>\n<p><code>PPStickerDataManager</code>类主要负责数据部分，用单例的形式，这样可以在初始化的时候只会读取一次plist文件中的所有表情信息；同时我们把输入框内容发到服务端以及从服务端请求到的都是纯文本的，比如会把 “笑死了🤣” 转成 “笑死了[笑哭]” 这样的纯文本，而不是直接把表情图片直接发到服务端，也就是说项目中有大量的地方会有把文本-&gt;表情的操作，所以<code>PPStickerDataManager</code>类也提供匹配某段纯文本中的表情，并把文本替换为图片的功能，<code>PPStickerDataManager</code>类的头文件如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface PPStickerDataManager : NSObject</div><div class=\"line\"></div><div class=\"line\">+ (instancetype)sharedInstance;</div><div class=\"line\"></div><div class=\"line\">/// 所有的表情包</div><div class=\"line\">@property (nonatomic, strong, readonly) NSArray&lt;PPSticker *&gt; *allStickers;</div><div class=\"line\"></div><div class=\"line\">/* 匹配给定attributedString中的所有emoji，如果匹配到的emoji有本地图片的话会直接换成本地的图片</div><div class=\"line\"> *</div><div class=\"line\"> * @param attributedString 可能包含表情包的attributedString</div><div class=\"line\"> * @param font 表情图片的对齐字体大小</div><div class=\"line\"> */</div><div class=\"line\">- (void)replaceEmojiForAttributedString:(NSMutableAttributedString *)attributedString font:(UIFont *)font;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<h4 id=\"“真正的”键盘\"><a href=\"#“真正的”键盘\" class=\"headerlink\" title=\"“真正的”键盘\"></a>“真正的”键盘</h4><p>真正的键盘也就是说调起表情键盘时输入框是有光标的，能进行拖拽光标、选中区域等的操作，这样的体验才是与系统键盘一致的。其实系统已经提供好了接口给我们直接使用，<code>UITextView</code>和<code>UITextField</code>都有的<code>inputView</code>和<code>inputAccessoryView</code>就是用来实现自定义键盘的，这两个属性的定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Presented when object becomes first responder.  If set to nil, reverts to following responder chain.  If</div><div class=\"line\">// set while first responder, will not take effect until reloadInputViews is called.</div><div class=\"line\">@property (nullable, readwrite, strong) UIView *inputView;             </div><div class=\"line\">@property (nullable, readwrite, strong) UIView *inputAccessoryView;</div></pre></td></tr></table></figure>\n<p>同时系统键盘在 设置-&gt;声音-&gt;按键音 选项打开且手机非静音状态下输入是有按键的声音的，这个按键音也是可以支持的，只要自定义键盘类遵循<code>UIInputViewAudioFeedback</code>协议，同时实现 <code>enableInputClicksWhenVisible</code>方法并返回YES，这样就可以在点击表情的时候调用<code>[[UIDevice currentDevice] playInputClick]</code>方法发出按键音了，详情请查看<a href=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/InputViews/InputViews.html\" target=\"_blank\" rel=\"external\">苹果的官方文档</a>。</p>\n<p>下面是Demo中键盘切换方法的实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)changeKeyboardTo:(PPKeyboardType)toType</div><div class=\"line\">&#123;</div><div class=\"line\">    switch (toType) &#123;</div><div class=\"line\">        case PPKeyboardTypeSystem:</div><div class=\"line\">            self.textView.inputView = nil;    // 切换到系统键盘</div><div class=\"line\">            [self.textView reloadInputViews]; // 调用reloadInputViews方法会立刻进行键盘的切换</div><div class=\"line\">            break;</div><div class=\"line\">        case PPKeyboardTypeSticker:            </div><div class=\"line\">            self.textView.inputView = self.stickerKeyboard; // 切换到自定义的表情键盘</div><div class=\"line\">            [self.textView reloadInputViews];</div><div class=\"line\">            break;</div><div class=\"line\">        default:</div><div class=\"line\">            break;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"去除表情的拖拽交互\"><a href=\"#去除表情的拖拽交互\" class=\"headerlink\" title=\"去除表情的拖拽交互\"></a>去除表情的拖拽交互</h4><p>在iOS11上，<code>UITextView</code>上的<code>NSTextAttachment</code>（表情）默认可以进行拖拽交互，但是却导致拖动光标时很容易触发这个交互（图示可以查看上面说到的微博国际版中的误触）。一番查找之后才找到一个比较隐蔽的属性：<code>textDragInteraction</code>，直接设置为<code>NO</code>就能禁止掉<code>NSTextAttachment</code>的拖拽交互。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (@available(iOS 11.0, *)) &#123;\t// 只在iOS11及以上才有这个属性</div><div class=\"line\">     _textView.textDragInteraction.enabled = NO;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"与服务端的交互\"><a href=\"#与服务端的交互\" class=\"headerlink\" title=\"与服务端的交互\"></a>与服务端的交互</h4><p>我们在输入框中输入的内容与服务端进行交互的时候都是用纯文本的，比如会把 “笑死了🤣” 转成 “笑死了[笑哭]” 这样的纯文本发到服务端，而不是直接发表情图片，向服务端请求内容的时候也是传回 “笑死了[笑哭]”，然后客户端再根据正则匹配找出表情替换成对应的表情图片，然后显示到页面上。具体过程可以看下图：<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-00199a31ec46945d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"与服务端的交互.png\"></p>\n<p>也就是说，我们设置到输入框的<code>NSAttributedString</code>中的每一个<code>NSTextAttachment</code>都有一个”隐藏的”属性—表情的文本描述，这里对<code>NSAttributedString</code>进行拓展就能实现。<code>pp_setTextBackedString</code>可以对<code>NSAttributedString</code>的指定<code>range</code>设置一个<code>PPTextBackedString</code>类型的属性，而<code>pp_plainTextForRange</code>能拿到<code>NSAttributedString</code>指定<code>range</code>的纯文本。具体实现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">@implementation NSAttributedString (PPAddition)</div><div class=\"line\"></div><div class=\"line\">- (NSString *)pp_plainTextForRange:(NSRange)range</div><div class=\"line\">&#123;</div><div class=\"line\">    if (range.location == NSNotFound || range.length == NSNotFound) &#123;</div><div class=\"line\">        return nil;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    NSMutableString *result = [[NSMutableString alloc] init];</div><div class=\"line\">    if (range.length == 0) &#123;</div><div class=\"line\">        return result;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    NSString *string = self.string;</div><div class=\"line\">    [self enumerateAttribute:PPTextBackedStringAttributeName inRange:range options:kNilOptions usingBlock:^(id value, NSRange range, BOOL *stop) &#123;</div><div class=\"line\">        PPTextBackedString *backed = value;</div><div class=\"line\">        if (backed &amp;&amp; backed.string) &#123;</div><div class=\"line\">            [result appendString:backed.string];</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            [result appendString:[string substringWithRange:range]];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;];</div><div class=\"line\">    return result;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation NSMutableAttributedString (PPAddition)</div><div class=\"line\"></div><div class=\"line\">- (void)pp_setTextBackedString:(PPTextBackedString *)textBackedString range:(NSRange)range</div><div class=\"line\">&#123;</div><div class=\"line\">    if (textBackedString &amp;&amp; ![NSNull isEqual:textBackedString]) &#123;</div><div class=\"line\">        [self addAttribute:PPTextBackedStringAttributeName value:textBackedString range:range];</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        [self removeAttribute:PPTextBackedStringAttributeName range:range];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<h4 id=\"灵活的光标\"><a href=\"#灵活的光标\" class=\"headerlink\" title=\"灵活的光标\"></a>灵活的光标</h4><p>表情功能，<code>UITextView</code>都是用<code>NSAttributedString</code>进行赋值的，并且我们底层其实还是用上面说到的纯文本进行实现的，那么把 [笑死] 转成 🤣 就会从4个字符变成1个字符，这里是有差值的，如果不处理的话就会出现上面提到的微博国际版中复制黏贴输入框的表情会导致光标位置不对，甚至莫名其妙多出前后空格的问题。为了精准的定位光标，我们需要自行处理好这些问题。</p>\n<p>这里自己继承并实现了<code>UITextView</code>的子类<code>PPStickerTextView</code>，在这个类中重载复制、黏贴、剪切等操作，分别对应的方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)cut:(id)sender;\t\t// 剪切</div><div class=\"line\"></div><div class=\"line\">- (void)copy:(id)sender;\t// 复制</div><div class=\"line\"></div><div class=\"line\">- (void)paste:(id)sender;\t// 黏贴</div></pre></td></tr></table></figure>\n<p>下面以剪切方法举例，看看怎么处理光标的问题，需要注意的地方请看对应的注释：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)cut:(id)sender</div><div class=\"line\">&#123;</div><div class=\"line\">    // 1.从textView中拿到对应的纯文本，比如：笑死了[笑死]</div><div class=\"line\">    NSString *string = [self.attributedText pp_plainTextForRange:self.selectedRange];</div><div class=\"line\">    if (string.length) &#123;</div><div class=\"line\">      \t// 2. 将纯文本写入到剪贴板中</div><div class=\"line\">        [UIPasteboard generalPasteboard].string = string;</div><div class=\"line\"></div><div class=\"line\">      \t// 3. 记住当前的光标位置</div><div class=\"line\">        NSRange selectedRange = self.selectedRange;</div><div class=\"line\">        NSMutableAttributedString *attributeContent = [[NSMutableAttributedString alloc] initWithAttributedString:self.attributedText];</div><div class=\"line\">      \t// 4. 将检测到是表情的文本替换成对应的图片</div><div class=\"line\">        [attributeContent replaceCharactersInRange:self.selectedRange withString:@&quot;&quot;];</div><div class=\"line\">        self.attributedText = attributeContent;</div><div class=\"line\">      </div><div class=\"line\">      \t// 5. 重新设置光标</div><div class=\"line\">        self.selectedRange = NSMakeRange(selectedRange.location, 0);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>技术点的分析就是以上这些，详细的代码可以clone代码查看：<a href=\"https://github.com/VernonVan/PPStickerKeyboard\" target=\"_blank\" rel=\"external\">https://github.com/VernonVan/PPStickerKeyboard</a></p>\n","excerpt":"","more":"<p>最近在公司做了个表情键盘的需求，这个需求的技术难度不会很大，比较偏向业务。但是要把用户体验做的好也是不容易的，其中有几个点需要特别注意。话不多说，下面开始正文(注：本文对应的Demo放在Github上：<a href=\"https://github.com/VernonVan/PPStickerKeyboard\">https://github.com/VernonVan/PPStickerKeyboard</a>)。</p>\n<h2 id=\"市面上的表情键盘的分析\"><a href=\"#市面上的表情键盘的分析\" class=\"headerlink\" title=\"市面上的表情键盘的分析\"></a>市面上的表情键盘的分析</h2><p>首先来看一下市面上主要的几个APP上的表情键盘，平时使用的时候不会去关注细节，这次特意去使用了表情键盘，发现各个APP的体验还是有优有劣的。</p>\n<p>首先是QQ和微信，这两者差不多，切换到表情键盘的时候都是没有光标的，这样的用户体验是非常不好的，没有办法在输入表情的时候框选区域，也不能拖动光标进行特定位置的复制黏贴删除等操作，微信甚至在输入框里显示的都不是点击的表情图片，而是文字描述。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-2c59f42aa0dd0dd1.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"微信QQ表情键盘.JPG\"></p>\n<p>接下来看一下微博国际版，国际版调起表情键盘时是有光标的，是一个”真正的”键盘，但是想要拖拽光标的时候，很大概率上会触发到保存图片的行为（如下图所示），导致根本没办法拖动光标。<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-5f667795a7778a6e.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"微博国际版误触.JPG\"></p>\n<p>同时微博国际版输入框表情黏贴后的光标定位是错误的，如下图，开始时光标是在第4个表情后面，然后复制狗头+害羞两个表情黏贴到光标后，光标还是在第4个表情后，同时黏贴的表情前后都莫名多了空格。<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-d4cddecefc22cfc9.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"微博国际版黏贴.JPG\"></p>\n<p>最后是微博，微博客户端的表情键盘的体验是非常好的，上面说到的问题都不存在，而且表情键盘的删除按钮还能长按删除输入框的内容。<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-63023d1dfcce132b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"微博表情键盘.jpg\"></p>\n<h2 id=\"表情键盘的实现\"><a href=\"#表情键盘的实现\" class=\"headerlink\" title=\"表情键盘的实现\"></a>表情键盘的实现</h2><h4 id=\"实现效果\"><a href=\"#实现效果\" class=\"headerlink\" title=\"实现效果\"></a>实现效果</h4><p>主要实现了以下几个功能</p>\n<ul>\n<li>能输入表情，有光标，支持复制黏贴删除表情等</li>\n<li>长按预览表情</li>\n<li>删除表情、长按连续删除表情</li>\n<li>适配 iPhone X<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-9d1661ee627dc3ca.GIF?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"演示.GIF\"></li>\n</ul>\n<h4 id=\"基本思路\"><a href=\"#基本思路\" class=\"headerlink\" title=\"基本思路\"></a>基本思路</h4><p>首先，表情包的图片是用bundle的形式组织的，用<code>PPSticker</code>类表征一套表情包，用<code>PPEmoji</code>类表征某一个表情，用一个plist作为配置文件，存储表情包的信息。<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-10847f03391e9560.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"表情的组织.jpg\"></p>\n<p><code>PPStickerDataManager</code>类主要负责数据部分，用单例的形式，这样可以在初始化的时候只会读取一次plist文件中的所有表情信息；同时我们把输入框内容发到服务端以及从服务端请求到的都是纯文本的，比如会把 “笑死了🤣” 转成 “笑死了[笑哭]” 这样的纯文本，而不是直接把表情图片直接发到服务端，也就是说项目中有大量的地方会有把文本-&gt;表情的操作，所以<code>PPStickerDataManager</code>类也提供匹配某段纯文本中的表情，并把文本替换为图片的功能，<code>PPStickerDataManager</code>类的头文件如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface PPStickerDataManager : NSObject</div><div class=\"line\"></div><div class=\"line\">+ (instancetype)sharedInstance;</div><div class=\"line\"></div><div class=\"line\">/// 所有的表情包</div><div class=\"line\">@property (nonatomic, strong, readonly) NSArray&lt;PPSticker *&gt; *allStickers;</div><div class=\"line\"></div><div class=\"line\">/* 匹配给定attributedString中的所有emoji，如果匹配到的emoji有本地图片的话会直接换成本地的图片</div><div class=\"line\"> *</div><div class=\"line\"> * @param attributedString 可能包含表情包的attributedString</div><div class=\"line\"> * @param font 表情图片的对齐字体大小</div><div class=\"line\"> */</div><div class=\"line\">- (void)replaceEmojiForAttributedString:(NSMutableAttributedString *)attributedString font:(UIFont *)font;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<h4 id=\"“真正的”键盘\"><a href=\"#“真正的”键盘\" class=\"headerlink\" title=\"“真正的”键盘\"></a>“真正的”键盘</h4><p>真正的键盘也就是说调起表情键盘时输入框是有光标的，能进行拖拽光标、选中区域等的操作，这样的体验才是与系统键盘一致的。其实系统已经提供好了接口给我们直接使用，<code>UITextView</code>和<code>UITextField</code>都有的<code>inputView</code>和<code>inputAccessoryView</code>就是用来实现自定义键盘的，这两个属性的定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Presented when object becomes first responder.  If set to nil, reverts to following responder chain.  If</div><div class=\"line\">// set while first responder, will not take effect until reloadInputViews is called.</div><div class=\"line\">@property (nullable, readwrite, strong) UIView *inputView;             </div><div class=\"line\">@property (nullable, readwrite, strong) UIView *inputAccessoryView;</div></pre></td></tr></table></figure>\n<p>同时系统键盘在 设置-&gt;声音-&gt;按键音 选项打开且手机非静音状态下输入是有按键的声音的，这个按键音也是可以支持的，只要自定义键盘类遵循<code>UIInputViewAudioFeedback</code>协议，同时实现 <code>enableInputClicksWhenVisible</code>方法并返回YES，这样就可以在点击表情的时候调用<code>[[UIDevice currentDevice] playInputClick]</code>方法发出按键音了，详情请查看<a href=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/InputViews/InputViews.html\">苹果的官方文档</a>。</p>\n<p>下面是Demo中键盘切换方法的实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)changeKeyboardTo:(PPKeyboardType)toType</div><div class=\"line\">&#123;</div><div class=\"line\">    switch (toType) &#123;</div><div class=\"line\">        case PPKeyboardTypeSystem:</div><div class=\"line\">            self.textView.inputView = nil;    // 切换到系统键盘</div><div class=\"line\">            [self.textView reloadInputViews]; // 调用reloadInputViews方法会立刻进行键盘的切换</div><div class=\"line\">            break;</div><div class=\"line\">        case PPKeyboardTypeSticker:            </div><div class=\"line\">            self.textView.inputView = self.stickerKeyboard; // 切换到自定义的表情键盘</div><div class=\"line\">            [self.textView reloadInputViews];</div><div class=\"line\">            break;</div><div class=\"line\">        default:</div><div class=\"line\">            break;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"去除表情的拖拽交互\"><a href=\"#去除表情的拖拽交互\" class=\"headerlink\" title=\"去除表情的拖拽交互\"></a>去除表情的拖拽交互</h4><p>在iOS11上，<code>UITextView</code>上的<code>NSTextAttachment</code>（表情）默认可以进行拖拽交互，但是却导致拖动光标时很容易触发这个交互（图示可以查看上面说到的微博国际版中的误触）。一番查找之后才找到一个比较隐蔽的属性：<code>textDragInteraction</code>，直接设置为<code>NO</code>就能禁止掉<code>NSTextAttachment</code>的拖拽交互。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (@available(iOS 11.0, *)) &#123;\t// 只在iOS11及以上才有这个属性</div><div class=\"line\">     _textView.textDragInteraction.enabled = NO;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"与服务端的交互\"><a href=\"#与服务端的交互\" class=\"headerlink\" title=\"与服务端的交互\"></a>与服务端的交互</h4><p>我们在输入框中输入的内容与服务端进行交互的时候都是用纯文本的，比如会把 “笑死了🤣” 转成 “笑死了[笑哭]” 这样的纯文本发到服务端，而不是直接发表情图片，向服务端请求内容的时候也是传回 “笑死了[笑哭]”，然后客户端再根据正则匹配找出表情替换成对应的表情图片，然后显示到页面上。具体过程可以看下图：<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-00199a31ec46945d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"与服务端的交互.png\"></p>\n<p>也就是说，我们设置到输入框的<code>NSAttributedString</code>中的每一个<code>NSTextAttachment</code>都有一个”隐藏的”属性—表情的文本描述，这里对<code>NSAttributedString</code>进行拓展就能实现。<code>pp_setTextBackedString</code>可以对<code>NSAttributedString</code>的指定<code>range</code>设置一个<code>PPTextBackedString</code>类型的属性，而<code>pp_plainTextForRange</code>能拿到<code>NSAttributedString</code>指定<code>range</code>的纯文本。具体实现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">@implementation NSAttributedString (PPAddition)</div><div class=\"line\"></div><div class=\"line\">- (NSString *)pp_plainTextForRange:(NSRange)range</div><div class=\"line\">&#123;</div><div class=\"line\">    if (range.location == NSNotFound || range.length == NSNotFound) &#123;</div><div class=\"line\">        return nil;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    NSMutableString *result = [[NSMutableString alloc] init];</div><div class=\"line\">    if (range.length == 0) &#123;</div><div class=\"line\">        return result;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    NSString *string = self.string;</div><div class=\"line\">    [self enumerateAttribute:PPTextBackedStringAttributeName inRange:range options:kNilOptions usingBlock:^(id value, NSRange range, BOOL *stop) &#123;</div><div class=\"line\">        PPTextBackedString *backed = value;</div><div class=\"line\">        if (backed &amp;&amp; backed.string) &#123;</div><div class=\"line\">            [result appendString:backed.string];</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            [result appendString:[string substringWithRange:range]];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;];</div><div class=\"line\">    return result;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation NSMutableAttributedString (PPAddition)</div><div class=\"line\"></div><div class=\"line\">- (void)pp_setTextBackedString:(PPTextBackedString *)textBackedString range:(NSRange)range</div><div class=\"line\">&#123;</div><div class=\"line\">    if (textBackedString &amp;&amp; ![NSNull isEqual:textBackedString]) &#123;</div><div class=\"line\">        [self addAttribute:PPTextBackedStringAttributeName value:textBackedString range:range];</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        [self removeAttribute:PPTextBackedStringAttributeName range:range];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<h4 id=\"灵活的光标\"><a href=\"#灵活的光标\" class=\"headerlink\" title=\"灵活的光标\"></a>灵活的光标</h4><p>表情功能，<code>UITextView</code>都是用<code>NSAttributedString</code>进行赋值的，并且我们底层其实还是用上面说到的纯文本进行实现的，那么把 [笑死] 转成 🤣 就会从4个字符变成1个字符，这里是有差值的，如果不处理的话就会出现上面提到的微博国际版中复制黏贴输入框的表情会导致光标位置不对，甚至莫名其妙多出前后空格的问题。为了精准的定位光标，我们需要自行处理好这些问题。</p>\n<p>这里自己继承并实现了<code>UITextView</code>的子类<code>PPStickerTextView</code>，在这个类中重载复制、黏贴、剪切等操作，分别对应的方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)cut:(id)sender;\t\t// 剪切</div><div class=\"line\"></div><div class=\"line\">- (void)copy:(id)sender;\t// 复制</div><div class=\"line\"></div><div class=\"line\">- (void)paste:(id)sender;\t// 黏贴</div></pre></td></tr></table></figure>\n<p>下面以剪切方法举例，看看怎么处理光标的问题，需要注意的地方请看对应的注释：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)cut:(id)sender</div><div class=\"line\">&#123;</div><div class=\"line\">    // 1.从textView中拿到对应的纯文本，比如：笑死了[笑死]</div><div class=\"line\">    NSString *string = [self.attributedText pp_plainTextForRange:self.selectedRange];</div><div class=\"line\">    if (string.length) &#123;</div><div class=\"line\">      \t// 2. 将纯文本写入到剪贴板中</div><div class=\"line\">        [UIPasteboard generalPasteboard].string = string;</div><div class=\"line\"></div><div class=\"line\">      \t// 3. 记住当前的光标位置</div><div class=\"line\">        NSRange selectedRange = self.selectedRange;</div><div class=\"line\">        NSMutableAttributedString *attributeContent = [[NSMutableAttributedString alloc] initWithAttributedString:self.attributedText];</div><div class=\"line\">      \t// 4. 将检测到是表情的文本替换成对应的图片</div><div class=\"line\">        [attributeContent replaceCharactersInRange:self.selectedRange withString:@&quot;&quot;];</div><div class=\"line\">        self.attributedText = attributeContent;</div><div class=\"line\">      </div><div class=\"line\">      \t// 5. 重新设置光标</div><div class=\"line\">        self.selectedRange = NSMakeRange(selectedRange.location, 0);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>技术点的分析就是以上这些，详细的代码可以clone代码查看：<a href=\"https://github.com/VernonVan/PPStickerKeyboard\">https://github.com/VernonVan/PPStickerKeyboard</a></p>\n"},{"title":"ruanpapa和又吉君的日常之二","date":"2017-04-10T00:50:05.000Z","_content":"\n## ruanpapa和又吉君的日常之二\n\n> 清明节放假，又吉君就算计着和小伙伴出去玩，去哪儿呢，不如：**烟花三月下扬州** 吧！\n>\n> ### 谁想到这一玩ruanpapa就不高兴了\n>\n> ### 前段时间还说又吉君是“小肾脏 ”的papa，竟然发小脾气了！\n>\n> ![特别的昵称](http://upload-images.jianshu.io/upload_images/5431890-a5faad624a4c040a.jpg)\n>\n> <p align=\"center\"><font color=\"9E9E9E\"><u>特别的昵称</u></font></p>\n>\n> <br>\n\n\n## 他发什么脾气呢\n\n>![(´･ω･`)](http://upload-images.jianshu.io/upload_images/5431890-82b8059afc595d42.jpg)\n>\n><p align=\"center\"><font color=\"9E9E9E\"><u>(´･ω･`)</u></font></p>\n><br>\n>\n>*  对，就是因为老子出去玩了三天两天半没搭理他……这货无聊得要爆炸！\n>\n>* 嗯，于是他就发脾气了！\n>\n>* 发脾气了！\n>\n>* 脾气了！\n>\n>* 气了！\n>\n>* 了！\n>\n>* ！\n>\n>* ......\n>\n>   ​\n>\n>   papa啊，我的papa。  你鸡母鸡啊，你每次有小脾气我都蛮担心的！我怕你一不小心就不理我了……但是我又觉得你不会不理我...很矛盾的心理_(:3 」∠)_然后我想讨好你吧，又不知道我自己哪里不对……\n>\n>   所以！你可不可以下次不要发脾气呀！有不开心的事要和我讲噢！我好好听着！！\n\n\n## 最后放几张扬州的图充充篇幅....\n\n\n![不知道哪个巷子里的路灯...](http://upload-images.jianshu.io/upload_images/5431890-0cff0046db87663f.jpg)\n\n<p align=\"center\"><font color=\"9E9E9E\"><u>不知道哪个巷子里的路灯...</u></font></p>\n<br>\n\n![何园的亭子](http://upload-images.jianshu.io/upload_images/5431890-507ed4d57fa25230.jpg)\n\n<p align=\"center\"><font color=\"9E9E9E\"><u>何园的亭子</u></font></p>\n<br>\n\n![桃花](http://upload-images.jianshu.io/upload_images/5431890-b79184fa44bc8e33.jpg)\n\n<p align=\"center\"><font color=\"9E9E9E\"><u>桃花</u></font></p>\n<br>\n\n![长长的夹道](http://upload-images.jianshu.io/upload_images/5431890-298a91a209912a45.jpg)\n\n<p align=\"center\"><font color=\"9E9E9E\"><u>长长的夹道</u></font></p>\n<br>\n\n- 我是又吉君，一个集ruanpapa和好脾气于一身的大可爱！\n\n<br>\n<br>\n<p align=\"right\">by：又吉君</p>","source":"_posts/ruanpapa和又吉君的日常之二.md","raw":"---\ntitle: ruanpapa和又吉君的日常之二\ndate: 2017-04-10 08:50:05\ntags:\ncategories:\n- ruanpapa&又吉君的日常\n---\n\n## ruanpapa和又吉君的日常之二\n\n> 清明节放假，又吉君就算计着和小伙伴出去玩，去哪儿呢，不如：**烟花三月下扬州** 吧！\n>\n> ### 谁想到这一玩ruanpapa就不高兴了\n>\n> ### 前段时间还说又吉君是“小肾脏 ”的papa，竟然发小脾气了！\n>\n> ![特别的昵称](http://upload-images.jianshu.io/upload_images/5431890-a5faad624a4c040a.jpg)\n>\n> <p align=\"center\"><font color=\"9E9E9E\"><u>特别的昵称</u></font></p>\n>\n> <br>\n\n\n## 他发什么脾气呢\n\n>![(´･ω･`)](http://upload-images.jianshu.io/upload_images/5431890-82b8059afc595d42.jpg)\n>\n><p align=\"center\"><font color=\"9E9E9E\"><u>(´･ω･`)</u></font></p>\n><br>\n>\n>*  对，就是因为老子出去玩了三天两天半没搭理他……这货无聊得要爆炸！\n>\n>* 嗯，于是他就发脾气了！\n>\n>* 发脾气了！\n>\n>* 脾气了！\n>\n>* 气了！\n>\n>* 了！\n>\n>* ！\n>\n>* ......\n>\n>   ​\n>\n>   papa啊，我的papa。  你鸡母鸡啊，你每次有小脾气我都蛮担心的！我怕你一不小心就不理我了……但是我又觉得你不会不理我...很矛盾的心理_(:3 」∠)_然后我想讨好你吧，又不知道我自己哪里不对……\n>\n>   所以！你可不可以下次不要发脾气呀！有不开心的事要和我讲噢！我好好听着！！\n\n\n## 最后放几张扬州的图充充篇幅....\n\n\n![不知道哪个巷子里的路灯...](http://upload-images.jianshu.io/upload_images/5431890-0cff0046db87663f.jpg)\n\n<p align=\"center\"><font color=\"9E9E9E\"><u>不知道哪个巷子里的路灯...</u></font></p>\n<br>\n\n![何园的亭子](http://upload-images.jianshu.io/upload_images/5431890-507ed4d57fa25230.jpg)\n\n<p align=\"center\"><font color=\"9E9E9E\"><u>何园的亭子</u></font></p>\n<br>\n\n![桃花](http://upload-images.jianshu.io/upload_images/5431890-b79184fa44bc8e33.jpg)\n\n<p align=\"center\"><font color=\"9E9E9E\"><u>桃花</u></font></p>\n<br>\n\n![长长的夹道](http://upload-images.jianshu.io/upload_images/5431890-298a91a209912a45.jpg)\n\n<p align=\"center\"><font color=\"9E9E9E\"><u>长长的夹道</u></font></p>\n<br>\n\n- 我是又吉君，一个集ruanpapa和好脾气于一身的大可爱！\n\n<br>\n<br>\n<p align=\"right\">by：又吉君</p>","slug":"ruanpapa和又吉君的日常之二","published":1,"updated":"2017-04-11T02:20:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg4j8vyn000rvfwxiwjk4au6","content":"<h2 id=\"ruanpapa和又吉君的日常之二\"><a href=\"#ruanpapa和又吉君的日常之二\" class=\"headerlink\" title=\"ruanpapa和又吉君的日常之二\"></a>ruanpapa和又吉君的日常之二</h2><blockquote>\n<p>清明节放假，又吉君就算计着和小伙伴出去玩，去哪儿呢，不如：<strong>烟花三月下扬州</strong> 吧！</p>\n<h3 id=\"谁想到这一玩ruanpapa就不高兴了\"><a href=\"#谁想到这一玩ruanpapa就不高兴了\" class=\"headerlink\" title=\"谁想到这一玩ruanpapa就不高兴了\"></a>谁想到这一玩ruanpapa就不高兴了</h3><h3 id=\"前段时间还说又吉君是“小肾脏-”的papa，竟然发小脾气了！\"><a href=\"#前段时间还说又吉君是“小肾脏-”的papa，竟然发小脾气了！\" class=\"headerlink\" title=\"前段时间还说又吉君是“小肾脏 ”的papa，竟然发小脾气了！\"></a>前段时间还说又吉君是“小肾脏 ”的papa，竟然发小脾气了！</h3><p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-a5faad624a4c040a.jpg\" alt=\"特别的昵称\"></p>\n<p align=\"center\"><font color=\"9E9E9E\"><u>特别的昵称</u></font></p>\n\n<p><br></p>\n</blockquote>\n<h2 id=\"他发什么脾气呢\"><a href=\"#他发什么脾气呢\" class=\"headerlink\" title=\"他发什么脾气呢\"></a>他发什么脾气呢</h2><blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-82b8059afc595d42.jpg\" alt=\"(´･ω･`)\"></p>\n<p></p><p align=\"center\"><font color=\"9E9E9E\"><u>(´･ω･`)</u></font></p><br><br><p></p>\n<ul>\n<li><p>对，就是因为老子出去玩了三天两天半没搭理他……这货无聊得要爆炸！</p>\n</li>\n<li><p>嗯，于是他就发脾气了！</p>\n</li>\n<li><p>发脾气了！</p>\n</li>\n<li><p>脾气了！</p>\n</li>\n<li><p>气了！</p>\n</li>\n<li><p>了！</p>\n</li>\n<li><p>！</p>\n</li>\n<li><p>……</p>\n<p>​</p>\n<p>papa啊，我的papa。  你鸡母鸡啊，你每次有小脾气我都蛮担心的！我怕你一不小心就不理我了……但是我又觉得你不会不理我…很矛盾的心理<em>(:3 」∠)</em>然后我想讨好你吧，又不知道我自己哪里不对……</p>\n<p>所以！你可不可以下次不要发脾气呀！有不开心的事要和我讲噢！我好好听着！！</p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"最后放几张扬州的图充充篇幅…\"><a href=\"#最后放几张扬州的图充充篇幅…\" class=\"headerlink\" title=\"最后放几张扬州的图充充篇幅….\"></a>最后放几张扬州的图充充篇幅….</h2><p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-0cff0046db87663f.jpg\" alt=\"不知道哪个巷子里的路灯...\"></p>\n<p align=\"center\"><font color=\"9E9E9E\"><u>不知道哪个巷子里的路灯…</u></font></p><br><br><br><br><img src=\"http://upload-images.jianshu.io/upload_images/5431890-507ed4d57fa25230.jpg\" alt=\"何园的亭子\"><br><br><p align=\"center\"><font color=\"9E9E9E\"><u>何园的亭子</u></font></p><br><br><br><br><img src=\"http://upload-images.jianshu.io/upload_images/5431890-b79184fa44bc8e33.jpg\" alt=\"桃花\"><br><br><p align=\"center\"><font color=\"9E9E9E\"><u>桃花</u></font></p><br><br><br><br><img src=\"http://upload-images.jianshu.io/upload_images/5431890-298a91a209912a45.jpg\" alt=\"长长的夹道\"><br><br><p align=\"center\"><font color=\"9E9E9E\"><u>长长的夹道</u></font></p><br><br><br><br>- 我是又吉君，一个集ruanpapa和好脾气于一身的大可爱！<br><br><br><br><br><br><p align=\"right\">by：又吉君</p>","excerpt":"","more":"<h2 id=\"ruanpapa和又吉君的日常之二\"><a href=\"#ruanpapa和又吉君的日常之二\" class=\"headerlink\" title=\"ruanpapa和又吉君的日常之二\"></a>ruanpapa和又吉君的日常之二</h2><blockquote>\n<p>清明节放假，又吉君就算计着和小伙伴出去玩，去哪儿呢，不如：<strong>烟花三月下扬州</strong> 吧！</p>\n<h3 id=\"谁想到这一玩ruanpapa就不高兴了\"><a href=\"#谁想到这一玩ruanpapa就不高兴了\" class=\"headerlink\" title=\"谁想到这一玩ruanpapa就不高兴了\"></a>谁想到这一玩ruanpapa就不高兴了</h3><h3 id=\"前段时间还说又吉君是“小肾脏-”的papa，竟然发小脾气了！\"><a href=\"#前段时间还说又吉君是“小肾脏-”的papa，竟然发小脾气了！\" class=\"headerlink\" title=\"前段时间还说又吉君是“小肾脏 ”的papa，竟然发小脾气了！\"></a>前段时间还说又吉君是“小肾脏 ”的papa，竟然发小脾气了！</h3><p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-a5faad624a4c040a.jpg\" alt=\"特别的昵称\"></p>\n<p align=\"center\"><font color=\"9E9E9E\"><u>特别的昵称</u></font></p>\n\n<p><br></p>\n</blockquote>\n<h2 id=\"他发什么脾气呢\"><a href=\"#他发什么脾气呢\" class=\"headerlink\" title=\"他发什么脾气呢\"></a>他发什么脾气呢</h2><blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-82b8059afc595d42.jpg\" alt=\"(´･ω･`)\"></p>\n<p><p align=\"center\"><font color=\"9E9E9E\"><u>(´･ω･`)</u></font></p><br><br></p>\n<ul>\n<li><p>对，就是因为老子出去玩了三天两天半没搭理他……这货无聊得要爆炸！</p>\n</li>\n<li><p>嗯，于是他就发脾气了！</p>\n</li>\n<li><p>发脾气了！</p>\n</li>\n<li><p>脾气了！</p>\n</li>\n<li><p>气了！</p>\n</li>\n<li><p>了！</p>\n</li>\n<li><p>！</p>\n</li>\n<li><p>……</p>\n<p>​</p>\n<p>papa啊，我的papa。  你鸡母鸡啊，你每次有小脾气我都蛮担心的！我怕你一不小心就不理我了……但是我又觉得你不会不理我…很矛盾的心理<em>(:3 」∠)</em>然后我想讨好你吧，又不知道我自己哪里不对……</p>\n<p>所以！你可不可以下次不要发脾气呀！有不开心的事要和我讲噢！我好好听着！！</p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"最后放几张扬州的图充充篇幅…\"><a href=\"#最后放几张扬州的图充充篇幅…\" class=\"headerlink\" title=\"最后放几张扬州的图充充篇幅….\"></a>最后放几张扬州的图充充篇幅….</h2><p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-0cff0046db87663f.jpg\" alt=\"不知道哪个巷子里的路灯...\"></p>\n<p align=\"center\"><font color=\"9E9E9E\"><u>不知道哪个巷子里的路灯…</u></font></p><br><br><br><br><img src=\"http://upload-images.jianshu.io/upload_images/5431890-507ed4d57fa25230.jpg\" alt=\"何园的亭子\"><br><br><p align=\"center\"><font color=\"9E9E9E\"><u>何园的亭子</u></font></p><br><br><br><br><img src=\"http://upload-images.jianshu.io/upload_images/5431890-b79184fa44bc8e33.jpg\" alt=\"桃花\"><br><br><p align=\"center\"><font color=\"9E9E9E\"><u>桃花</u></font></p><br><br><br><br><img src=\"http://upload-images.jianshu.io/upload_images/5431890-298a91a209912a45.jpg\" alt=\"长长的夹道\"><br><br><p align=\"center\"><font color=\"9E9E9E\"><u>长长的夹道</u></font></p><br><br><br><br>- 我是又吉君，一个集ruanpapa和好脾气于一身的大可爱！<br><br><br><br><br><br><p align=\"right\">by：又吉君</p>"},{"title":"ruanpapa和又吉君的日常之三","date":"2017-04-11T01:46:24.000Z","_content":"\n## ruanpapa和又吉君的日常之三\n\n > 前几天周末，我闲着没事画了一下水彩画。去年说要学一下水彩画，到今年才练了两次手˚✧₊⁎❝᷀ົཽ≀ˍ̮ ❝᷀ົཽ⁎⁺˳✧༚\n >\n > - **骚逼**    的秀一下：\n >\n > ![又吉君的第二次水彩](http://upload-images.jianshu.io/upload_images/5431890-edfdec991f26f35a.jpg)\n >\n >    ​\n >\n >    <p align=\"center\"><font color=\"9E9E9E\"><u>又吉君的第二次水彩</u></font></p>\n >\n >    <br>\n >\n >    <p align=\"center\">（没有纸...拿的素描纸画的....）</p>\n >\n >   ​\n\n\n### 于是，ruanpapa叫我教他画画\n\n### 哈哈哈哈哈哈哈哈哈\n\n* 我就让他自己先瞎画，随意涂鸦一下\n   ![好奇的ruanpapa](http://upload-images.jianshu.io/upload_images/5431890-79043c46600a0f44.jpg)\n\n   <p align=\"center\"><font color=\"9E9E9E\"><u>好奇的ruanpapa</u></font></p>\n\n   <br>\n\n* 于是，我就给他做了个示范，在相册里随意选了几张图片，在微信里编辑起来了。\n   **如下图：**\n   ![又吉君有剧情的示范](http://upload-images.jianshu.io/upload_images/5431890-b2e9236ecaf56952.jpg)\n\n   <p align=\"center\"><font color=\"9E9E9E\"><u>又吉君有剧情的示范</u></font></p>\n\n   <br>\n\n* 然后......**哈哈哈哈哈哈哈哈哈哈哈哈**，他竟然画成这个样子！！！！！！！！太可爱了！！(〃ω〃)\n   ![ruanpapa 的涂鸦](http://upload-images.jianshu.io/upload_images/5431890-4964c7dac40f7e83.jpg)\n\n   <p align=\"center\"><font color=\"9E9E9E\"><u>ruanpapa的涂鸦</u></font></p>\n\n   <br>\n\n* 哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈！！！！！！\n\n* 虽然现在画风这么可爱，但是想想以后可能还会在博客里看到papa的进步噢！！！感觉棒棒的呢！！！(・ω・)ノ\n\n* papa你要努力成为我这样的灵魂画师噢！！**哈哈哈哈哈啊哈哈哈哈哈哈**\n\n\n* 我是又吉君，一个集ruanpapa和灵魂画手于一身的大可爱！\n\n  ![喵～](http://upload-images.jianshu.io/upload_images/5431890-086ab893f76633bf.jpg)\n\n\n<p align=\"center\"><font color=\"9E9E9E\"><u>喵~</u></font></p>\n\n<br>\n<br>\n<p align=\"right\">by：又吉君</p>","source":"_posts/ruanpapa和又吉君的日常之三.md","raw":"---\ntitle: ruanpapa和又吉君的日常之三\ndate: 2017-04-11 09:46:24\ntags:\ncategories:\n- ruanpapa&又吉君的日常\n---\n\n## ruanpapa和又吉君的日常之三\n\n > 前几天周末，我闲着没事画了一下水彩画。去年说要学一下水彩画，到今年才练了两次手˚✧₊⁎❝᷀ົཽ≀ˍ̮ ❝᷀ົཽ⁎⁺˳✧༚\n >\n > - **骚逼**    的秀一下：\n >\n > ![又吉君的第二次水彩](http://upload-images.jianshu.io/upload_images/5431890-edfdec991f26f35a.jpg)\n >\n >    ​\n >\n >    <p align=\"center\"><font color=\"9E9E9E\"><u>又吉君的第二次水彩</u></font></p>\n >\n >    <br>\n >\n >    <p align=\"center\">（没有纸...拿的素描纸画的....）</p>\n >\n >   ​\n\n\n### 于是，ruanpapa叫我教他画画\n\n### 哈哈哈哈哈哈哈哈哈\n\n* 我就让他自己先瞎画，随意涂鸦一下\n   ![好奇的ruanpapa](http://upload-images.jianshu.io/upload_images/5431890-79043c46600a0f44.jpg)\n\n   <p align=\"center\"><font color=\"9E9E9E\"><u>好奇的ruanpapa</u></font></p>\n\n   <br>\n\n* 于是，我就给他做了个示范，在相册里随意选了几张图片，在微信里编辑起来了。\n   **如下图：**\n   ![又吉君有剧情的示范](http://upload-images.jianshu.io/upload_images/5431890-b2e9236ecaf56952.jpg)\n\n   <p align=\"center\"><font color=\"9E9E9E\"><u>又吉君有剧情的示范</u></font></p>\n\n   <br>\n\n* 然后......**哈哈哈哈哈哈哈哈哈哈哈哈**，他竟然画成这个样子！！！！！！！！太可爱了！！(〃ω〃)\n   ![ruanpapa 的涂鸦](http://upload-images.jianshu.io/upload_images/5431890-4964c7dac40f7e83.jpg)\n\n   <p align=\"center\"><font color=\"9E9E9E\"><u>ruanpapa的涂鸦</u></font></p>\n\n   <br>\n\n* 哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈！！！！！！\n\n* 虽然现在画风这么可爱，但是想想以后可能还会在博客里看到papa的进步噢！！！感觉棒棒的呢！！！(・ω・)ノ\n\n* papa你要努力成为我这样的灵魂画师噢！！**哈哈哈哈哈啊哈哈哈哈哈哈**\n\n\n* 我是又吉君，一个集ruanpapa和灵魂画手于一身的大可爱！\n\n  ![喵～](http://upload-images.jianshu.io/upload_images/5431890-086ab893f76633bf.jpg)\n\n\n<p align=\"center\"><font color=\"9E9E9E\"><u>喵~</u></font></p>\n\n<br>\n<br>\n<p align=\"right\">by：又吉君</p>","slug":"ruanpapa和又吉君的日常之三","published":1,"updated":"2017-04-11T02:19:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg4j8vyo000wvfwxchtafdr5","content":"<h2 id=\"ruanpapa和又吉君的日常之三\"><a href=\"#ruanpapa和又吉君的日常之三\" class=\"headerlink\" title=\"ruanpapa和又吉君的日常之三\"></a>ruanpapa和又吉君的日常之三</h2><blockquote>\n<p>前几天周末，我闲着没事画了一下水彩画。去年说要学一下水彩画，到今年才练了两次手˚✧₊⁎❝᷀ົཽ≀ˍ̮ ❝᷀ົཽ⁎⁺˳✧༚</p>\n<ul>\n<li><strong>骚逼</strong>    的秀一下：</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-edfdec991f26f35a.jpg\" alt=\"又吉君的第二次水彩\"></p>\n<p>   ​</p>\n   <p align=\"center\"><font color=\"9E9E9E\"><u>又吉君的第二次水彩</u></font></p>\n\n<p>   <br></p>\n   <p align=\"center\">（没有纸…拿的素描纸画的….）</p>\n\n<p>  ​</p>\n</blockquote>\n<h3 id=\"于是，ruanpapa叫我教他画画\"><a href=\"#于是，ruanpapa叫我教他画画\" class=\"headerlink\" title=\"于是，ruanpapa叫我教他画画\"></a>于是，ruanpapa叫我教他画画</h3><h3 id=\"哈哈哈哈哈哈哈哈哈\"><a href=\"#哈哈哈哈哈哈哈哈哈\" class=\"headerlink\" title=\"哈哈哈哈哈哈哈哈哈\"></a>哈哈哈哈哈哈哈哈哈</h3><ul>\n<li><p>我就让他自己先瞎画，随意涂鸦一下<br> <img src=\"http://upload-images.jianshu.io/upload_images/5431890-79043c46600a0f44.jpg\" alt=\"好奇的ruanpapa\"></p>\n <p align=\"center\"><font color=\"9E9E9E\"><u>好奇的ruanpapa</u></font></p>\n\n<p> <br></p>\n</li>\n<li><p>于是，我就给他做了个示范，在相册里随意选了几张图片，在微信里编辑起来了。<br> <strong>如下图：</strong><br> <img src=\"http://upload-images.jianshu.io/upload_images/5431890-b2e9236ecaf56952.jpg\" alt=\"又吉君有剧情的示范\"></p>\n <p align=\"center\"><font color=\"9E9E9E\"><u>又吉君有剧情的示范</u></font></p>\n\n<p> <br></p>\n</li>\n<li><p>然后……<strong>哈哈哈哈哈哈哈哈哈哈哈哈</strong>，他竟然画成这个样子！！！！！！！！太可爱了！！(〃ω〃)<br> <img src=\"http://upload-images.jianshu.io/upload_images/5431890-4964c7dac40f7e83.jpg\" alt=\"ruanpapa 的涂鸦\"></p>\n <p align=\"center\"><font color=\"9E9E9E\"><u>ruanpapa的涂鸦</u></font></p>\n\n<p> <br></p>\n</li>\n<li><p>哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈！！！！！！</p>\n</li>\n<li><p>虽然现在画风这么可爱，但是想想以后可能还会在博客里看到papa的进步噢！！！感觉棒棒的呢！！！(・ω・)ノ</p>\n</li>\n<li><p>papa你要努力成为我这样的灵魂画师噢！！<strong>哈哈哈哈哈啊哈哈哈哈哈哈</strong></p>\n</li>\n</ul>\n<ul>\n<li><p>我是又吉君，一个集ruanpapa和灵魂画手于一身的大可爱！</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-086ab893f76633bf.jpg\" alt=\"喵～\"></p>\n</li>\n</ul>\n<p align=\"center\"><font color=\"9E9E9E\"><u>喵~</u></font></p>\n\n<p><br><br><br></p>\n<p align=\"right\">by：又吉君</p>","excerpt":"","more":"<h2 id=\"ruanpapa和又吉君的日常之三\"><a href=\"#ruanpapa和又吉君的日常之三\" class=\"headerlink\" title=\"ruanpapa和又吉君的日常之三\"></a>ruanpapa和又吉君的日常之三</h2><blockquote>\n<p>前几天周末，我闲着没事画了一下水彩画。去年说要学一下水彩画，到今年才练了两次手˚✧₊⁎❝᷀ົཽ≀ˍ̮ ❝᷀ົཽ⁎⁺˳✧༚</p>\n<ul>\n<li><strong>骚逼</strong>    的秀一下：</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-edfdec991f26f35a.jpg\" alt=\"又吉君的第二次水彩\"></p>\n<p>   ​</p>\n   <p align=\"center\"><font color=\"9E9E9E\"><u>又吉君的第二次水彩</u></font></p>\n\n<p>   <br></p>\n   <p align=\"center\">（没有纸…拿的素描纸画的….）</p>\n\n<p>  ​</p>\n</blockquote>\n<h3 id=\"于是，ruanpapa叫我教他画画\"><a href=\"#于是，ruanpapa叫我教他画画\" class=\"headerlink\" title=\"于是，ruanpapa叫我教他画画\"></a>于是，ruanpapa叫我教他画画</h3><h3 id=\"哈哈哈哈哈哈哈哈哈\"><a href=\"#哈哈哈哈哈哈哈哈哈\" class=\"headerlink\" title=\"哈哈哈哈哈哈哈哈哈\"></a>哈哈哈哈哈哈哈哈哈</h3><ul>\n<li><p>我就让他自己先瞎画，随意涂鸦一下<br> <img src=\"http://upload-images.jianshu.io/upload_images/5431890-79043c46600a0f44.jpg\" alt=\"好奇的ruanpapa\"></p>\n <p align=\"center\"><font color=\"9E9E9E\"><u>好奇的ruanpapa</u></font></p>\n\n<p> <br></p>\n</li>\n<li><p>于是，我就给他做了个示范，在相册里随意选了几张图片，在微信里编辑起来了。<br> <strong>如下图：</strong><br> <img src=\"http://upload-images.jianshu.io/upload_images/5431890-b2e9236ecaf56952.jpg\" alt=\"又吉君有剧情的示范\"></p>\n <p align=\"center\"><font color=\"9E9E9E\"><u>又吉君有剧情的示范</u></font></p>\n\n<p> <br></p>\n</li>\n<li><p>然后……<strong>哈哈哈哈哈哈哈哈哈哈哈哈</strong>，他竟然画成这个样子！！！！！！！！太可爱了！！(〃ω〃)<br> <img src=\"http://upload-images.jianshu.io/upload_images/5431890-4964c7dac40f7e83.jpg\" alt=\"ruanpapa 的涂鸦\"></p>\n <p align=\"center\"><font color=\"9E9E9E\"><u>ruanpapa的涂鸦</u></font></p>\n\n<p> <br></p>\n</li>\n<li><p>哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈！！！！！！</p>\n</li>\n<li><p>虽然现在画风这么可爱，但是想想以后可能还会在博客里看到papa的进步噢！！！感觉棒棒的呢！！！(・ω・)ノ</p>\n</li>\n<li><p>papa你要努力成为我这样的灵魂画师噢！！<strong>哈哈哈哈哈啊哈哈哈哈哈哈</strong></p>\n</li>\n</ul>\n<ul>\n<li><p>我是又吉君，一个集ruanpapa和灵魂画手于一身的大可爱！</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-086ab893f76633bf.jpg\" alt=\"喵～\"></p>\n</li>\n</ul>\n<p align=\"center\"><font color=\"9E9E9E\"><u>喵~</u></font></p>\n\n<p><br><br><br></p>\n<p align=\"right\">by：又吉君</p>"},{"title":"ruanpapa和又吉君的日常之五","date":"2017-04-26T03:03:17.000Z","_content":"\n## ruanpapa和又吉君的日常\n\n> 感觉好久没有更新了，主要是零零碎碎一些日常不太好写。 想着，既然如此零碎！那就写一篇零零碎碎的日常好了，反正就我和papa两人看。(￣^￣)\n\n### 先讲述一些ruanpapa的强迫症\n\n> 我家papa呢，直男到不能再直了。as is known to all，所有直男都有那么点“硬邦邦”的原则，比如：小洁癖，鞋子一定要放鞋架上，不允许整整齐齐的东西有一丝错位等等等等等，要不然就要叽叽咕咕一大堆。\n\n### “papa的强迫症超级好笑噢！”\n\n>  - 一次，他问我要课表，然后我就坦然的给他看我的课有多满！！！本以为他要安慰一下我，然后再哄哄我没事没事课多好好学就好了……我都准备好撒个娇，结果，他就来了这么一句！**“你能不能把左上角的小红点去掉，再给我发一份”**\n>    (╯‵□′)╯︵┻━┻\n>    ┻━┻︵╰(‵□′)╯︵┻━┻\n>    **老子日了你的狗！**\n>     ![课程表不起眼的小点](http://upload-images.jianshu.io/upload_images/5431890-8e87538b62248c5f.jpg)\n\n> <p align=\"center\"><font color=\"9E9E9E\"><u>课程表不起眼的小点</u></font></p>\n>\n> * 他某次很烦恼的跟我讲：\n>   -“宝宝，我找了三四个壁纸软件都找不到我想要的壁纸。”\n>   -“你想要什么样的”\n>   -“就是那种能不被图标遮住的....被图标遮住的壁纸我看着难受”\n>   -“............”\n>   “我干脆给你做一个吧..”\n>   ![这就是他不爽的理由](http://upload-images.jianshu.io/upload_images/5431890-437fed0289250be6.jpg)\n>\n>   <p align=\"center\"><font color=\"9E9E9E\"><u>这就是他不爽的理由</u></font></p>\n>\n> * 于是我就给他做了一张。\n>\n>   ![_(┐「ε:)_](http://upload-images.jianshu.io/upload_images/5431890-2599e513e3ded9fa.jpg)\n>\n>   <p align=\"center\"><font color=\"9E9E9E\"><u>_(┐「ε:)_</u></font></p>\n>\n>   ​\n>\n>   ![我tm有什么办法！！](http://upload-images.jianshu.io/upload_images/5431890-32a5b58070d58a02.jpg)\n>\n>   <p align=\"center\"><font color=\"9E9E9E\"><u>_我tm有什么办法！！_</u></font></p>\n>\n>   ​\n>\n>   **老子有什么办法！！！！鼠标手绘！！你让我怎么样！！！ಥ_ಥ**\n\n\n* 然后嘛！我就一直给他做壁纸了....不能挡着图标的壁纸...... 有谁也有图标强迫症也可以拿去用好了……\n  ![小绿](http://upload-images.jianshu.io/upload_images/5431890-46fead901d3a0cff.jpg)\n\n  <p align=\"center\"><font color=\"9E9E9E\"><u>_小绿_</u></font></p>\n\n  ​\n\n  ![小蓝](http://upload-images.jianshu.io/upload_images/5431890-abac2286f800bd00.jpg)\n\n  <p align=\"center\"><font color=\"9E9E9E\"><u>_小蓝_</u></font></p>\n\n### “淘宝卖家要气死了”\n\n> * 我把最喜欢的一支笔弄丢了，于是在淘宝找了半天，就想要一毛一样的，然后papa就很负责任的帮我一本正经的找，由于随机发颜色，所以很苦恼，就一家一家的问可不可以指定颜色....于是，找到一家！！！！\n>   ![嘿嘿嘿](http://upload-images.jianshu.io/upload_images/5431890-405a6aee5bdd0ae8.jpg)\n>\n>   <p align=\"center\"><font color=\"9E9E9E\"><u>_嘿嘿嘿_</u></font></p>\n>\n>   ​\n>\n>   ​\n>\n> * **哈哈哈哈哈哈！说完那句之后，这个淘宝卖家就没再回复一句.....快递也没告诉我发啥....但是我还是买了哈哈哈哈哈哈哈哈哈哈哈**\n\n\n### “去你妈的六碗饭！”\n\n> * 前段时间和其他两个小伙伴去吃午饭，吃了个鸡公煲，三人一共吃了八碗饭……鸡公煲小哥哥上饭的时候都**卧槽**了好大一声....那天是早上三个人都起晚了赶去上课没吃早餐，结果饿得一塌糊涂……\n>\n> * 觉得很好玩，每个人吃了两碗多点，就和papa讲了一下觉得好笑，结果这小讨厌“污蔑我”吃了六碗！！！！！！\n>\n>   ![去你妈的六碗饭](http://upload-images.jianshu.io/upload_images/5431890-abc50c31d245580f.jpg)\n>\n>   <p align=\"center\"><font color=\"9E9E9E\"><u>_去你妈的六碗饭_</u></font></p>\n>\n>   ​\n>\n> * 不过养我的预算是应该  **提 高**  了\n>\n> * 应该  **提 高**  了\n>\n> * **提 高**  了\n>\n> * **提 高**\n>\n> * **高**\n>\n> * 耶！✌️\n\n* 我是又吉君！ 一个需要提高预算的孩子！！\n\n![汪～](http://upload-images.jianshu.io/upload_images/5431890-ab475351e7890445.jpg)\n\n<p align=\"center\"><font color=\"9E9E9E\"><u>_汪～_</u></font></p>\n\n<br>\n<br>\n<p align=\"right\">by：又吉君</p>","source":"_posts/ruanpapa和又吉君的日常之五.md","raw":"---\ntitle: ruanpapa和又吉君的日常之五\ndate: 2017-04-26 11:03:17\ntags:\ncategories:\n- ruanpapa&又吉君的日常\n---\n\n## ruanpapa和又吉君的日常\n\n> 感觉好久没有更新了，主要是零零碎碎一些日常不太好写。 想着，既然如此零碎！那就写一篇零零碎碎的日常好了，反正就我和papa两人看。(￣^￣)\n\n### 先讲述一些ruanpapa的强迫症\n\n> 我家papa呢，直男到不能再直了。as is known to all，所有直男都有那么点“硬邦邦”的原则，比如：小洁癖，鞋子一定要放鞋架上，不允许整整齐齐的东西有一丝错位等等等等等，要不然就要叽叽咕咕一大堆。\n\n### “papa的强迫症超级好笑噢！”\n\n>  - 一次，他问我要课表，然后我就坦然的给他看我的课有多满！！！本以为他要安慰一下我，然后再哄哄我没事没事课多好好学就好了……我都准备好撒个娇，结果，他就来了这么一句！**“你能不能把左上角的小红点去掉，再给我发一份”**\n>    (╯‵□′)╯︵┻━┻\n>    ┻━┻︵╰(‵□′)╯︵┻━┻\n>    **老子日了你的狗！**\n>     ![课程表不起眼的小点](http://upload-images.jianshu.io/upload_images/5431890-8e87538b62248c5f.jpg)\n\n> <p align=\"center\"><font color=\"9E9E9E\"><u>课程表不起眼的小点</u></font></p>\n>\n> * 他某次很烦恼的跟我讲：\n>   -“宝宝，我找了三四个壁纸软件都找不到我想要的壁纸。”\n>   -“你想要什么样的”\n>   -“就是那种能不被图标遮住的....被图标遮住的壁纸我看着难受”\n>   -“............”\n>   “我干脆给你做一个吧..”\n>   ![这就是他不爽的理由](http://upload-images.jianshu.io/upload_images/5431890-437fed0289250be6.jpg)\n>\n>   <p align=\"center\"><font color=\"9E9E9E\"><u>这就是他不爽的理由</u></font></p>\n>\n> * 于是我就给他做了一张。\n>\n>   ![_(┐「ε:)_](http://upload-images.jianshu.io/upload_images/5431890-2599e513e3ded9fa.jpg)\n>\n>   <p align=\"center\"><font color=\"9E9E9E\"><u>_(┐「ε:)_</u></font></p>\n>\n>   ​\n>\n>   ![我tm有什么办法！！](http://upload-images.jianshu.io/upload_images/5431890-32a5b58070d58a02.jpg)\n>\n>   <p align=\"center\"><font color=\"9E9E9E\"><u>_我tm有什么办法！！_</u></font></p>\n>\n>   ​\n>\n>   **老子有什么办法！！！！鼠标手绘！！你让我怎么样！！！ಥ_ಥ**\n\n\n* 然后嘛！我就一直给他做壁纸了....不能挡着图标的壁纸...... 有谁也有图标强迫症也可以拿去用好了……\n  ![小绿](http://upload-images.jianshu.io/upload_images/5431890-46fead901d3a0cff.jpg)\n\n  <p align=\"center\"><font color=\"9E9E9E\"><u>_小绿_</u></font></p>\n\n  ​\n\n  ![小蓝](http://upload-images.jianshu.io/upload_images/5431890-abac2286f800bd00.jpg)\n\n  <p align=\"center\"><font color=\"9E9E9E\"><u>_小蓝_</u></font></p>\n\n### “淘宝卖家要气死了”\n\n> * 我把最喜欢的一支笔弄丢了，于是在淘宝找了半天，就想要一毛一样的，然后papa就很负责任的帮我一本正经的找，由于随机发颜色，所以很苦恼，就一家一家的问可不可以指定颜色....于是，找到一家！！！！\n>   ![嘿嘿嘿](http://upload-images.jianshu.io/upload_images/5431890-405a6aee5bdd0ae8.jpg)\n>\n>   <p align=\"center\"><font color=\"9E9E9E\"><u>_嘿嘿嘿_</u></font></p>\n>\n>   ​\n>\n>   ​\n>\n> * **哈哈哈哈哈哈！说完那句之后，这个淘宝卖家就没再回复一句.....快递也没告诉我发啥....但是我还是买了哈哈哈哈哈哈哈哈哈哈哈**\n\n\n### “去你妈的六碗饭！”\n\n> * 前段时间和其他两个小伙伴去吃午饭，吃了个鸡公煲，三人一共吃了八碗饭……鸡公煲小哥哥上饭的时候都**卧槽**了好大一声....那天是早上三个人都起晚了赶去上课没吃早餐，结果饿得一塌糊涂……\n>\n> * 觉得很好玩，每个人吃了两碗多点，就和papa讲了一下觉得好笑，结果这小讨厌“污蔑我”吃了六碗！！！！！！\n>\n>   ![去你妈的六碗饭](http://upload-images.jianshu.io/upload_images/5431890-abc50c31d245580f.jpg)\n>\n>   <p align=\"center\"><font color=\"9E9E9E\"><u>_去你妈的六碗饭_</u></font></p>\n>\n>   ​\n>\n> * 不过养我的预算是应该  **提 高**  了\n>\n> * 应该  **提 高**  了\n>\n> * **提 高**  了\n>\n> * **提 高**\n>\n> * **高**\n>\n> * 耶！✌️\n\n* 我是又吉君！ 一个需要提高预算的孩子！！\n\n![汪～](http://upload-images.jianshu.io/upload_images/5431890-ab475351e7890445.jpg)\n\n<p align=\"center\"><font color=\"9E9E9E\"><u>_汪～_</u></font></p>\n\n<br>\n<br>\n<p align=\"right\">by：又吉君</p>","slug":"ruanpapa和又吉君的日常之五","published":1,"updated":"2017-04-26T04:55:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg4j8vyp000zvfwx8uc555x6","content":"<h2 id=\"ruanpapa和又吉君的日常\"><a href=\"#ruanpapa和又吉君的日常\" class=\"headerlink\" title=\"ruanpapa和又吉君的日常\"></a>ruanpapa和又吉君的日常</h2><blockquote>\n<p>感觉好久没有更新了，主要是零零碎碎一些日常不太好写。 想着，既然如此零碎！那就写一篇零零碎碎的日常好了，反正就我和papa两人看。(￣^￣)</p>\n</blockquote>\n<h3 id=\"先讲述一些ruanpapa的强迫症\"><a href=\"#先讲述一些ruanpapa的强迫症\" class=\"headerlink\" title=\"先讲述一些ruanpapa的强迫症\"></a>先讲述一些ruanpapa的强迫症</h3><blockquote>\n<p>我家papa呢，直男到不能再直了。as is known to all，所有直男都有那么点“硬邦邦”的原则，比如：小洁癖，鞋子一定要放鞋架上，不允许整整齐齐的东西有一丝错位等等等等等，要不然就要叽叽咕咕一大堆。</p>\n</blockquote>\n<h3 id=\"“papa的强迫症超级好笑噢！”\"><a href=\"#“papa的强迫症超级好笑噢！”\" class=\"headerlink\" title=\"“papa的强迫症超级好笑噢！”\"></a>“papa的强迫症超级好笑噢！”</h3><blockquote>\n<ul>\n<li>一次，他问我要课表，然后我就坦然的给他看我的课有多满！！！本以为他要安慰一下我，然后再哄哄我没事没事课多好好学就好了……我都准备好撒个娇，结果，他就来了这么一句！<strong>“你能不能把左上角的小红点去掉，再给我发一份”</strong><br>(╯‵□′)╯︵┻━┻<br>┻━┻︵╰(‵□′)╯︵┻━┻<br><strong>老子日了你的狗！</strong><br> <img src=\"http://upload-images.jianshu.io/upload_images/5431890-8e87538b62248c5f.jpg\" alt=\"课程表不起眼的小点\"></li>\n</ul>\n<p align=\"center\"><font color=\"9E9E9E\"><u>课程表不起眼的小点</u></font></p>\n\n<ul>\n<li><p>他某次很烦恼的跟我讲：<br>-“宝宝，我找了三四个壁纸软件都找不到我想要的壁纸。”<br>-“你想要什么样的”<br>-“就是那种能不被图标遮住的….被图标遮住的壁纸我看着难受”<br>-“…………”<br>“我干脆给你做一个吧..”<br><img src=\"http://upload-images.jianshu.io/upload_images/5431890-437fed0289250be6.jpg\" alt=\"这就是他不爽的理由\"></p>\n<p align=\"center\"><font color=\"9E9E9E\"><u>这就是他不爽的理由</u></font></p>\n</li>\n<li><p>于是我就给他做了一张。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-2599e513e3ded9fa.jpg\" alt=\"_(┐「ε:)_\"></p>\n<p align=\"center\"><font color=\"9E9E9E\"><u><em>(┐「ε:)</em></u></font></p>\n\n<p>​</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-32a5b58070d58a02.jpg\" alt=\"我tm有什么办法！！\"></p>\n<p align=\"center\"><font color=\"9E9E9E\"><u><em>我tm有什么办法！！</em></u></font></p>\n\n<p>​</p>\n<p><strong>老子有什么办法！！！！鼠标手绘！！你让我怎么样！！！ಥ_ಥ</strong></p>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li><p>然后嘛！我就一直给他做壁纸了….不能挡着图标的壁纸…… 有谁也有图标强迫症也可以拿去用好了……<br><img src=\"http://upload-images.jianshu.io/upload_images/5431890-46fead901d3a0cff.jpg\" alt=\"小绿\"></p>\n<p align=\"center\"><font color=\"9E9E9E\"><u><em>小绿</em></u></font></p>\n\n<p>​</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-abac2286f800bd00.jpg\" alt=\"小蓝\"></p>\n<p align=\"center\"><font color=\"9E9E9E\"><u><em>小蓝</em></u></font></p>\n\n</li>\n</ul>\n<h3 id=\"“淘宝卖家要气死了”\"><a href=\"#“淘宝卖家要气死了”\" class=\"headerlink\" title=\"“淘宝卖家要气死了”\"></a>“淘宝卖家要气死了”</h3><blockquote>\n<ul>\n<li><p>我把最喜欢的一支笔弄丢了，于是在淘宝找了半天，就想要一毛一样的，然后papa就很负责任的帮我一本正经的找，由于随机发颜色，所以很苦恼，就一家一家的问可不可以指定颜色….于是，找到一家！！！！<br><img src=\"http://upload-images.jianshu.io/upload_images/5431890-405a6aee5bdd0ae8.jpg\" alt=\"嘿嘿嘿\"></p>\n<p align=\"center\"><font color=\"9E9E9E\"><u><em>嘿嘿嘿</em></u></font></p>\n\n<p>​</p>\n<p>​</p>\n</li>\n<li><p><strong>哈哈哈哈哈哈！说完那句之后，这个淘宝卖家就没再回复一句…..快递也没告诉我发啥….但是我还是买了哈哈哈哈哈哈哈哈哈哈哈</strong></p>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"“去你妈的六碗饭！”\"><a href=\"#“去你妈的六碗饭！”\" class=\"headerlink\" title=\"“去你妈的六碗饭！”\"></a>“去你妈的六碗饭！”</h3><blockquote>\n<ul>\n<li><p>前段时间和其他两个小伙伴去吃午饭，吃了个鸡公煲，三人一共吃了八碗饭……鸡公煲小哥哥上饭的时候都<strong>卧槽</strong>了好大一声….那天是早上三个人都起晚了赶去上课没吃早餐，结果饿得一塌糊涂……</p>\n</li>\n<li><p>觉得很好玩，每个人吃了两碗多点，就和papa讲了一下觉得好笑，结果这小讨厌“污蔑我”吃了六碗！！！！！！</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-abc50c31d245580f.jpg\" alt=\"去你妈的六碗饭\"></p>\n<p align=\"center\"><font color=\"9E9E9E\"><u><em>去你妈的六碗饭</em></u></font></p>\n\n<p>​</p>\n</li>\n<li><p>不过养我的预算是应该  <strong>提 高</strong>  了</p>\n</li>\n<li><p>应该  <strong>提 高</strong>  了</p>\n</li>\n<li><p><strong>提 高</strong>  了</p>\n</li>\n<li><p><strong>提 高</strong></p>\n</li>\n<li><p><strong>高</strong></p>\n</li>\n<li><p>耶！✌️</p>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>我是又吉君！ 一个需要提高预算的孩子！！</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-ab475351e7890445.jpg\" alt=\"汪～\"></p>\n<p align=\"center\"><font color=\"9E9E9E\"><u><em>汪～</em></u></font></p>\n\n<p><br><br><br></p>\n<p align=\"right\">by：又吉君</p>","excerpt":"","more":"<h2 id=\"ruanpapa和又吉君的日常\"><a href=\"#ruanpapa和又吉君的日常\" class=\"headerlink\" title=\"ruanpapa和又吉君的日常\"></a>ruanpapa和又吉君的日常</h2><blockquote>\n<p>感觉好久没有更新了，主要是零零碎碎一些日常不太好写。 想着，既然如此零碎！那就写一篇零零碎碎的日常好了，反正就我和papa两人看。(￣^￣)</p>\n</blockquote>\n<h3 id=\"先讲述一些ruanpapa的强迫症\"><a href=\"#先讲述一些ruanpapa的强迫症\" class=\"headerlink\" title=\"先讲述一些ruanpapa的强迫症\"></a>先讲述一些ruanpapa的强迫症</h3><blockquote>\n<p>我家papa呢，直男到不能再直了。as is known to all，所有直男都有那么点“硬邦邦”的原则，比如：小洁癖，鞋子一定要放鞋架上，不允许整整齐齐的东西有一丝错位等等等等等，要不然就要叽叽咕咕一大堆。</p>\n</blockquote>\n<h3 id=\"“papa的强迫症超级好笑噢！”\"><a href=\"#“papa的强迫症超级好笑噢！”\" class=\"headerlink\" title=\"“papa的强迫症超级好笑噢！”\"></a>“papa的强迫症超级好笑噢！”</h3><blockquote>\n<ul>\n<li>一次，他问我要课表，然后我就坦然的给他看我的课有多满！！！本以为他要安慰一下我，然后再哄哄我没事没事课多好好学就好了……我都准备好撒个娇，结果，他就来了这么一句！<strong>“你能不能把左上角的小红点去掉，再给我发一份”</strong><br>(╯‵□′)╯︵┻━┻<br>┻━┻︵╰(‵□′)╯︵┻━┻<br><strong>老子日了你的狗！</strong><br> <img src=\"http://upload-images.jianshu.io/upload_images/5431890-8e87538b62248c5f.jpg\" alt=\"课程表不起眼的小点\"></li>\n</ul>\n<p align=\"center\"><font color=\"9E9E9E\"><u>课程表不起眼的小点</u></font></p>\n\n<ul>\n<li><p>他某次很烦恼的跟我讲：<br>-“宝宝，我找了三四个壁纸软件都找不到我想要的壁纸。”<br>-“你想要什么样的”<br>-“就是那种能不被图标遮住的….被图标遮住的壁纸我看着难受”<br>-“…………”<br>“我干脆给你做一个吧..”<br><img src=\"http://upload-images.jianshu.io/upload_images/5431890-437fed0289250be6.jpg\" alt=\"这就是他不爽的理由\"></p>\n<p align=\"center\"><font color=\"9E9E9E\"><u>这就是他不爽的理由</u></font></p>\n</li>\n<li><p>于是我就给他做了一张。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-2599e513e3ded9fa.jpg\" alt=\"_(┐「ε:)_\"></p>\n<p align=\"center\"><font color=\"9E9E9E\"><u><em>(┐「ε:)</em></u></font></p>\n\n<p>​</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-32a5b58070d58a02.jpg\" alt=\"我tm有什么办法！！\"></p>\n<p align=\"center\"><font color=\"9E9E9E\"><u><em>我tm有什么办法！！</em></u></font></p>\n\n<p>​</p>\n<p><strong>老子有什么办法！！！！鼠标手绘！！你让我怎么样！！！ಥ_ಥ</strong></p>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li><p>然后嘛！我就一直给他做壁纸了….不能挡着图标的壁纸…… 有谁也有图标强迫症也可以拿去用好了……<br><img src=\"http://upload-images.jianshu.io/upload_images/5431890-46fead901d3a0cff.jpg\" alt=\"小绿\"></p>\n<p align=\"center\"><font color=\"9E9E9E\"><u><em>小绿</em></u></font></p>\n\n<p>​</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-abac2286f800bd00.jpg\" alt=\"小蓝\"></p>\n<p align=\"center\"><font color=\"9E9E9E\"><u><em>小蓝</em></u></font></p>\n\n</li>\n</ul>\n<h3 id=\"“淘宝卖家要气死了”\"><a href=\"#“淘宝卖家要气死了”\" class=\"headerlink\" title=\"“淘宝卖家要气死了”\"></a>“淘宝卖家要气死了”</h3><blockquote>\n<ul>\n<li><p>我把最喜欢的一支笔弄丢了，于是在淘宝找了半天，就想要一毛一样的，然后papa就很负责任的帮我一本正经的找，由于随机发颜色，所以很苦恼，就一家一家的问可不可以指定颜色….于是，找到一家！！！！<br><img src=\"http://upload-images.jianshu.io/upload_images/5431890-405a6aee5bdd0ae8.jpg\" alt=\"嘿嘿嘿\"></p>\n<p align=\"center\"><font color=\"9E9E9E\"><u><em>嘿嘿嘿</em></u></font></p>\n\n<p>​</p>\n<p>​</p>\n</li>\n<li><p><strong>哈哈哈哈哈哈！说完那句之后，这个淘宝卖家就没再回复一句…..快递也没告诉我发啥….但是我还是买了哈哈哈哈哈哈哈哈哈哈哈</strong></p>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"“去你妈的六碗饭！”\"><a href=\"#“去你妈的六碗饭！”\" class=\"headerlink\" title=\"“去你妈的六碗饭！”\"></a>“去你妈的六碗饭！”</h3><blockquote>\n<ul>\n<li><p>前段时间和其他两个小伙伴去吃午饭，吃了个鸡公煲，三人一共吃了八碗饭……鸡公煲小哥哥上饭的时候都<strong>卧槽</strong>了好大一声….那天是早上三个人都起晚了赶去上课没吃早餐，结果饿得一塌糊涂……</p>\n</li>\n<li><p>觉得很好玩，每个人吃了两碗多点，就和papa讲了一下觉得好笑，结果这小讨厌“污蔑我”吃了六碗！！！！！！</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-abc50c31d245580f.jpg\" alt=\"去你妈的六碗饭\"></p>\n<p align=\"center\"><font color=\"9E9E9E\"><u><em>去你妈的六碗饭</em></u></font></p>\n\n<p>​</p>\n</li>\n<li><p>不过养我的预算是应该  <strong>提 高</strong>  了</p>\n</li>\n<li><p>应该  <strong>提 高</strong>  了</p>\n</li>\n<li><p><strong>提 高</strong>  了</p>\n</li>\n<li><p><strong>提 高</strong></p>\n</li>\n<li><p><strong>高</strong></p>\n</li>\n<li><p>耶！✌️</p>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>我是又吉君！ 一个需要提高预算的孩子！！</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-ab475351e7890445.jpg\" alt=\"汪～\"></p>\n<p align=\"center\"><font color=\"9E9E9E\"><u><em>汪～</em></u></font></p>\n\n<p><br><br><br></p>\n<p align=\"right\">by：又吉君</p>"},{"title":"ruanpapa和又吉君的日常之六","date":"2017-05-25T11:12:44.000Z","_content":"\n>  **从苏州回来之后，迎来了第一个比较重要的日子。**\n>\n>  **papa突然跟我说！！！**\n>\n>  **“我星期六请你吃大餐啊！！！”**\n\n\n\n![完全反应不过来的又吉君](http://upload-images.jianshu.io/upload_images/5431890-01164f67324236ec.jpg)<p align=\"center\"><font color=\"9E9E9E\"><u>完全反应不过来的又吉君</u></font></p>\n\n<br>\n\n\n\n### 就是！！！5.20！！！\n然而我还是一脸糊涂：\n\n一直都没在意过的节日....突然开始还真像那么回事！主要是：\n\n#### 有！得！吃！\n\n\n\n![嘿嘿嘿嘿](http://upload-images.jianshu.io/upload_images/5431890-4aa1d67479db5d07.jpg)\n\n <p align=\"center\"><font color=\"9E9E9E\"><u>嘿嘿嘿嘿</u></font></p>\n\n<br>\n\n\n\n> 于是红包雨一下！！papa和我都有得吃了！！！\n>\n> **但是** ！！\n>\n> papa竟然和舍舍过二人世界去了！午饭还是舍舍请他吃的！！！！！\n>\n> 嗯！我的papa可能一直是个 🤞\n>\n> sad！_(┐「ε:)_\n\n\n\n### 悲伤的我脑洞一开，决定实施秀恩爱计划\n\n- 异地恋一定要秀一秀的！（可惜papa不爱秀）\n- 于是.......\n- 吃的东西经过我的手都变成这样了！！！\n\n​\n\n![徐州的虾+广州的麻辣香锅](http://upload-images.jianshu.io/upload_images/5431890-408407567043ba5b.jpg)<p align=\"center\"><font color=\"9E9E9E\"><u>徐州的虾+广州的麻辣香锅</u></font></p>\n\n<br>\n\n\n![酸奶酪+奶茶](http://upload-images.jianshu.io/upload_images/5431890-8aee97c7c90ead14.jpg)<p align=\"center\"><font color=\"9E9E9E\"><u>酸奶酪+奶茶</u></font></p>\n\n<br>\n ![绿健奶业+蜜雪冰城](http://upload-images.jianshu.io/upload_images/5431890-f7569fcfbe04f772.jpg)<p align=\"center\"><font color=\"9E9E9E\"><u>绿健奶业+蜜雪冰城</u></font></p>\n\n<br>\n\n\n\n> papa呀！！超级谢谢你噢！！你要一直这样！！！\n>\n> ### 不跟我一起吃至少也要让我吃！！！\n>\n> \n>\n> ## 吃！！\n>\n> \n>\n> # 吃！\n\n- 身体和灵魂必须有一个在路上！！\n\n 。\n\n 。\n\n 。\n\n 。\n\n 。\n\n 。\n\n 。\n\n 。\n\n 。\n\n 。\n\n 。\n\n 。\n\n 要么旅行！要么边旅行边吃！！\n\n<br>\n<br>\n<p align=\"right\">by：又吉君</p>","source":"_posts/ruanpapa和又吉君的日常之六.md","raw":"---\ntitle: ruanpapa和又吉君的日常之六\ndate: 2017-05-25 19:12:44\ntags:\ncategories:\n- ruanpapa&又吉君的日常\n---\n\n>  **从苏州回来之后，迎来了第一个比较重要的日子。**\n>\n>  **papa突然跟我说！！！**\n>\n>  **“我星期六请你吃大餐啊！！！”**\n\n\n\n![完全反应不过来的又吉君](http://upload-images.jianshu.io/upload_images/5431890-01164f67324236ec.jpg)<p align=\"center\"><font color=\"9E9E9E\"><u>完全反应不过来的又吉君</u></font></p>\n\n<br>\n\n\n\n### 就是！！！5.20！！！\n然而我还是一脸糊涂：\n\n一直都没在意过的节日....突然开始还真像那么回事！主要是：\n\n#### 有！得！吃！\n\n\n\n![嘿嘿嘿嘿](http://upload-images.jianshu.io/upload_images/5431890-4aa1d67479db5d07.jpg)\n\n <p align=\"center\"><font color=\"9E9E9E\"><u>嘿嘿嘿嘿</u></font></p>\n\n<br>\n\n\n\n> 于是红包雨一下！！papa和我都有得吃了！！！\n>\n> **但是** ！！\n>\n> papa竟然和舍舍过二人世界去了！午饭还是舍舍请他吃的！！！！！\n>\n> 嗯！我的papa可能一直是个 🤞\n>\n> sad！_(┐「ε:)_\n\n\n\n### 悲伤的我脑洞一开，决定实施秀恩爱计划\n\n- 异地恋一定要秀一秀的！（可惜papa不爱秀）\n- 于是.......\n- 吃的东西经过我的手都变成这样了！！！\n\n​\n\n![徐州的虾+广州的麻辣香锅](http://upload-images.jianshu.io/upload_images/5431890-408407567043ba5b.jpg)<p align=\"center\"><font color=\"9E9E9E\"><u>徐州的虾+广州的麻辣香锅</u></font></p>\n\n<br>\n\n\n![酸奶酪+奶茶](http://upload-images.jianshu.io/upload_images/5431890-8aee97c7c90ead14.jpg)<p align=\"center\"><font color=\"9E9E9E\"><u>酸奶酪+奶茶</u></font></p>\n\n<br>\n ![绿健奶业+蜜雪冰城](http://upload-images.jianshu.io/upload_images/5431890-f7569fcfbe04f772.jpg)<p align=\"center\"><font color=\"9E9E9E\"><u>绿健奶业+蜜雪冰城</u></font></p>\n\n<br>\n\n\n\n> papa呀！！超级谢谢你噢！！你要一直这样！！！\n>\n> ### 不跟我一起吃至少也要让我吃！！！\n>\n> \n>\n> ## 吃！！\n>\n> \n>\n> # 吃！\n\n- 身体和灵魂必须有一个在路上！！\n\n 。\n\n 。\n\n 。\n\n 。\n\n 。\n\n 。\n\n 。\n\n 。\n\n 。\n\n 。\n\n 。\n\n 。\n\n 要么旅行！要么边旅行边吃！！\n\n<br>\n<br>\n<p align=\"right\">by：又吉君</p>","slug":"ruanpapa和又吉君的日常之六","published":1,"updated":"2017-05-25T12:18:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg4j8vyq0013vfwx04sh26y3","content":"<blockquote>\n<p> <strong>从苏州回来之后，迎来了第一个比较重要的日子。</strong></p>\n<p> <strong>papa突然跟我说！！！</strong></p>\n<p> <strong>“我星期六请你吃大餐啊！！！”</strong></p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-01164f67324236ec.jpg\" alt=\"完全反应不过来的又吉君\"></p><p align=\"center\"><font color=\"9E9E9E\"><u>完全反应不过来的又吉君</u></font></p><p></p>\n<p><br></p>\n<h3 id=\"就是！！！5-20！！！\"><a href=\"#就是！！！5-20！！！\" class=\"headerlink\" title=\"就是！！！5.20！！！\"></a>就是！！！5.20！！！</h3><p>然而我还是一脸糊涂：</p>\n<p>一直都没在意过的节日….突然开始还真像那么回事！主要是：</p>\n<h4 id=\"有！得！吃！\"><a href=\"#有！得！吃！\" class=\"headerlink\" title=\"有！得！吃！\"></a>有！得！吃！</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-4aa1d67479db5d07.jpg\" alt=\"嘿嘿嘿嘿\"></p>\n <p align=\"center\"><font color=\"9E9E9E\"><u>嘿嘿嘿嘿</u></font></p>\n\n<p><br></p>\n<blockquote>\n<p>于是红包雨一下！！papa和我都有得吃了！！！</p>\n<p><strong>但是</strong> ！！</p>\n<p>papa竟然和舍舍过二人世界去了！午饭还是舍舍请他吃的！！！！！</p>\n<p>嗯！我的papa可能一直是个 🤞</p>\n<p>sad！<em>(┐「ε:)</em></p>\n</blockquote>\n<h3 id=\"悲伤的我脑洞一开，决定实施秀恩爱计划\"><a href=\"#悲伤的我脑洞一开，决定实施秀恩爱计划\" class=\"headerlink\" title=\"悲伤的我脑洞一开，决定实施秀恩爱计划\"></a>悲伤的我脑洞一开，决定实施秀恩爱计划</h3><ul>\n<li>异地恋一定要秀一秀的！（可惜papa不爱秀）</li>\n<li>于是…….</li>\n<li>吃的东西经过我的手都变成这样了！！！</li>\n</ul>\n<p>​</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-408407567043ba5b.jpg\" alt=\"徐州的虾+广州的麻辣香锅\"></p><p align=\"center\"><font color=\"9E9E9E\"><u>徐州的虾+广州的麻辣香锅</u></font></p><p></p>\n<p><br></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-8aee97c7c90ead14.jpg\" alt=\"酸奶酪+奶茶\"></p><p align=\"center\"><font color=\"9E9E9E\"><u>酸奶酪+奶茶</u></font></p><p></p>\n<p><br><br> <img src=\"http://upload-images.jianshu.io/upload_images/5431890-f7569fcfbe04f772.jpg\" alt=\"绿健奶业+蜜雪冰城\"></p><p align=\"center\"><font color=\"9E9E9E\"><u>绿健奶业+蜜雪冰城</u></font></p><p></p>\n<p><br></p>\n<blockquote>\n<p>papa呀！！超级谢谢你噢！！你要一直这样！！！</p>\n<h3 id=\"不跟我一起吃至少也要让我吃！！！\"><a href=\"#不跟我一起吃至少也要让我吃！！！\" class=\"headerlink\" title=\"不跟我一起吃至少也要让我吃！！！\"></a>不跟我一起吃至少也要让我吃！！！</h3><h2 id=\"吃！！\"><a href=\"#吃！！\" class=\"headerlink\" title=\"吃！！\"></a>吃！！</h2><h1 id=\"吃！\"><a href=\"#吃！\" class=\"headerlink\" title=\"吃！\"></a>吃！</h1></blockquote>\n<ul>\n<li><p>身体和灵魂必须有一个在路上！！</p>\n<p>。</p>\n<p>。</p>\n<p>。</p>\n<p>。</p>\n<p>。</p>\n<p>。</p>\n<p>。</p>\n<p>。</p>\n<p>。</p>\n<p>。</p>\n<p>。</p>\n<p>。</p>\n<p>要么旅行！要么边旅行边吃！！</p>\n</li>\n</ul>\n<p><br><br><br></p>\n<p align=\"right\">by：又吉君</p>","excerpt":"","more":"<blockquote>\n<p> <strong>从苏州回来之后，迎来了第一个比较重要的日子。</strong></p>\n<p> <strong>papa突然跟我说！！！</strong></p>\n<p> <strong>“我星期六请你吃大餐啊！！！”</strong></p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-01164f67324236ec.jpg\" alt=\"完全反应不过来的又吉君\"><p align=\"center\"><font color=\"9E9E9E\"><u>完全反应不过来的又吉君</u></font></p></p>\n<p><br></p>\n<h3 id=\"就是！！！5-20！！！\"><a href=\"#就是！！！5-20！！！\" class=\"headerlink\" title=\"就是！！！5.20！！！\"></a>就是！！！5.20！！！</h3><p>然而我还是一脸糊涂：</p>\n<p>一直都没在意过的节日….突然开始还真像那么回事！主要是：</p>\n<h4 id=\"有！得！吃！\"><a href=\"#有！得！吃！\" class=\"headerlink\" title=\"有！得！吃！\"></a>有！得！吃！</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-4aa1d67479db5d07.jpg\" alt=\"嘿嘿嘿嘿\"></p>\n <p align=\"center\"><font color=\"9E9E9E\"><u>嘿嘿嘿嘿</u></font></p>\n\n<p><br></p>\n<blockquote>\n<p>于是红包雨一下！！papa和我都有得吃了！！！</p>\n<p><strong>但是</strong> ！！</p>\n<p>papa竟然和舍舍过二人世界去了！午饭还是舍舍请他吃的！！！！！</p>\n<p>嗯！我的papa可能一直是个 🤞</p>\n<p>sad！<em>(┐「ε:)</em></p>\n</blockquote>\n<h3 id=\"悲伤的我脑洞一开，决定实施秀恩爱计划\"><a href=\"#悲伤的我脑洞一开，决定实施秀恩爱计划\" class=\"headerlink\" title=\"悲伤的我脑洞一开，决定实施秀恩爱计划\"></a>悲伤的我脑洞一开，决定实施秀恩爱计划</h3><ul>\n<li>异地恋一定要秀一秀的！（可惜papa不爱秀）</li>\n<li>于是…….</li>\n<li>吃的东西经过我的手都变成这样了！！！</li>\n</ul>\n<p>​</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-408407567043ba5b.jpg\" alt=\"徐州的虾+广州的麻辣香锅\"><p align=\"center\"><font color=\"9E9E9E\"><u>徐州的虾+广州的麻辣香锅</u></font></p></p>\n<p><br></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-8aee97c7c90ead14.jpg\" alt=\"酸奶酪+奶茶\"><p align=\"center\"><font color=\"9E9E9E\"><u>酸奶酪+奶茶</u></font></p></p>\n<p><br><br> <img src=\"http://upload-images.jianshu.io/upload_images/5431890-f7569fcfbe04f772.jpg\" alt=\"绿健奶业+蜜雪冰城\"><p align=\"center\"><font color=\"9E9E9E\"><u>绿健奶业+蜜雪冰城</u></font></p></p>\n<p><br></p>\n<blockquote>\n<p>papa呀！！超级谢谢你噢！！你要一直这样！！！</p>\n<h3 id=\"不跟我一起吃至少也要让我吃！！！\"><a href=\"#不跟我一起吃至少也要让我吃！！！\" class=\"headerlink\" title=\"不跟我一起吃至少也要让我吃！！！\"></a>不跟我一起吃至少也要让我吃！！！</h3><h2 id=\"吃！！\"><a href=\"#吃！！\" class=\"headerlink\" title=\"吃！！\"></a>吃！！</h2><h1 id=\"吃！\"><a href=\"#吃！\" class=\"headerlink\" title=\"吃！\"></a>吃！</h1></blockquote>\n<ul>\n<li><p>身体和灵魂必须有一个在路上！！</p>\n<p>。</p>\n<p>。</p>\n<p>。</p>\n<p>。</p>\n<p>。</p>\n<p>。</p>\n<p>。</p>\n<p>。</p>\n<p>。</p>\n<p>。</p>\n<p>。</p>\n<p>。</p>\n<p>要么旅行！要么边旅行边吃！！</p>\n</li>\n</ul>\n<p><br><br><br></p>\n<p align=\"right\">by：又吉君</p>"},{"title":"ruanpapa和又吉君的日常之零","date":"2017-03-30T05:37:32.000Z","_content":"\n### ruanpapa和又吉君到底是什么鬼？\n> * ruanpapa，多年草本植物，性温和，不易上火，无毒无公害。植株上长着不明自来卷毛发，无花期，只结果。茎干呈黑黄，估计大晚上的容易被踩到。\n> * 又吉君，小型食肉动物，性情多变，不易有攻击行为，嗜睡，好吃，眼睛白长了。喜欢晒太阳，毛发蓬松，天气干燥易炸毛，皮肤黄里透白，太阳光下会发光。\n\n### 两货怎么认识的\n- 有一天晚上又吉君出门捕食，走了十公里遇到了这棵草，不留神就踩到了。于是这棵草就赖上又吉君了。时不时给懒惰的又吉君投个食，于是又吉君就更懒惰了。\n\n### 相处模式\n* -“宝宝，给我个亲亲”\n  -“拒绝”\n  -“不给？？？？？！那好吧……”\n\n* -“papapapa，帮我找个软件/教程”\n  -“好的！٩(๑❛ᴗ❛๑)۶”\n\n* -“papa！你这是什么鬼！丑死\n  了！！！！！！！！！”\n  -“.......”\n\n* -“宝宝，我们睡觉吧”\n  -“睡你麻痹！起来嗨”\n\n* -“papa，我好困(´･ω･`)”\n  -“这就困了？？”\n  “........”\n\n  “宝宝？？？”\n\n  “妈的！睡着了！！！？”\n\n### 实际情况\n* 知乎相识\n* 认识三个月\n* 五一去旅游\n* .......\n\n> **未来那么长，请多多指教啊！**\n\n![嘿，旁边的傻papa](http://upload-images.jianshu.io/upload_images/5431890-d5b9a953241a5596.jpg)  \n<p align=\"center\"><font color=\"9E9E9E\"><u>嘿，旁边的傻papa</u></font></p>\n\n<br>\n<br>\n<p align=\"right\">by：又吉君</p>\n\n\n​                                        ","source":"_posts/ruanpapa和又吉君的日常之零.md","raw":"---\ntitle: ruanpapa和又吉君的日常之零\ndate: 2017-03-30 13:37:32\ntags:\ncategories:\n- ruanpapa&又吉君的日常\n---\n\n### ruanpapa和又吉君到底是什么鬼？\n> * ruanpapa，多年草本植物，性温和，不易上火，无毒无公害。植株上长着不明自来卷毛发，无花期，只结果。茎干呈黑黄，估计大晚上的容易被踩到。\n> * 又吉君，小型食肉动物，性情多变，不易有攻击行为，嗜睡，好吃，眼睛白长了。喜欢晒太阳，毛发蓬松，天气干燥易炸毛，皮肤黄里透白，太阳光下会发光。\n\n### 两货怎么认识的\n- 有一天晚上又吉君出门捕食，走了十公里遇到了这棵草，不留神就踩到了。于是这棵草就赖上又吉君了。时不时给懒惰的又吉君投个食，于是又吉君就更懒惰了。\n\n### 相处模式\n* -“宝宝，给我个亲亲”\n  -“拒绝”\n  -“不给？？？？？！那好吧……”\n\n* -“papapapa，帮我找个软件/教程”\n  -“好的！٩(๑❛ᴗ❛๑)۶”\n\n* -“papa！你这是什么鬼！丑死\n  了！！！！！！！！！”\n  -“.......”\n\n* -“宝宝，我们睡觉吧”\n  -“睡你麻痹！起来嗨”\n\n* -“papa，我好困(´･ω･`)”\n  -“这就困了？？”\n  “........”\n\n  “宝宝？？？”\n\n  “妈的！睡着了！！！？”\n\n### 实际情况\n* 知乎相识\n* 认识三个月\n* 五一去旅游\n* .......\n\n> **未来那么长，请多多指教啊！**\n\n![嘿，旁边的傻papa](http://upload-images.jianshu.io/upload_images/5431890-d5b9a953241a5596.jpg)  \n<p align=\"center\"><font color=\"9E9E9E\"><u>嘿，旁边的傻papa</u></font></p>\n\n<br>\n<br>\n<p align=\"right\">by：又吉君</p>\n\n\n​                                        ","slug":"ruanpapa和又吉君的日常之零","published":1,"updated":"2017-04-11T02:00:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg4j8vyr0015vfwxjsryxlbo","content":"<h3 id=\"ruanpapa和又吉君到底是什么鬼？\"><a href=\"#ruanpapa和又吉君到底是什么鬼？\" class=\"headerlink\" title=\"ruanpapa和又吉君到底是什么鬼？\"></a>ruanpapa和又吉君到底是什么鬼？</h3><blockquote>\n<ul>\n<li>ruanpapa，多年草本植物，性温和，不易上火，无毒无公害。植株上长着不明自来卷毛发，无花期，只结果。茎干呈黑黄，估计大晚上的容易被踩到。</li>\n<li>又吉君，小型食肉动物，性情多变，不易有攻击行为，嗜睡，好吃，眼睛白长了。喜欢晒太阳，毛发蓬松，天气干燥易炸毛，皮肤黄里透白，太阳光下会发光。</li>\n</ul>\n</blockquote>\n<h3 id=\"两货怎么认识的\"><a href=\"#两货怎么认识的\" class=\"headerlink\" title=\"两货怎么认识的\"></a>两货怎么认识的</h3><ul>\n<li>有一天晚上又吉君出门捕食，走了十公里遇到了这棵草，不留神就踩到了。于是这棵草就赖上又吉君了。时不时给懒惰的又吉君投个食，于是又吉君就更懒惰了。</li>\n</ul>\n<h3 id=\"相处模式\"><a href=\"#相处模式\" class=\"headerlink\" title=\"相处模式\"></a>相处模式</h3><ul>\n<li><p>-“宝宝，给我个亲亲”<br>-“拒绝”<br>-“不给？？？？？！那好吧……”</p>\n</li>\n<li><p>-“papapapa，帮我找个软件/教程”<br>-“好的！٩(๑❛ᴗ❛๑)۶”</p>\n</li>\n<li><p>-“papa！你这是什么鬼！丑死<br>了！！！！！！！！！”<br>-“…….”</p>\n</li>\n<li><p>-“宝宝，我们睡觉吧”<br>-“睡你麻痹！起来嗨”</p>\n</li>\n<li><p>-“papa，我好困(´･ω･`)”<br>-“这就困了？？”<br>“……..”</p>\n<p>“宝宝？？？”</p>\n<p>“妈的！睡着了！！！？”</p>\n</li>\n</ul>\n<h3 id=\"实际情况\"><a href=\"#实际情况\" class=\"headerlink\" title=\"实际情况\"></a>实际情况</h3><ul>\n<li>知乎相识</li>\n<li>认识三个月</li>\n<li>五一去旅游</li>\n<li>…….</li>\n</ul>\n<blockquote>\n<p><strong>未来那么长，请多多指教啊！</strong></p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-d5b9a953241a5596.jpg\" alt=\"嘿，旁边的傻papa\">  </p>\n<p align=\"center\"><font color=\"9E9E9E\"><u>嘿，旁边的傻papa</u></font></p>\n\n<p><br><br><br></p>\n<p align=\"right\">by：又吉君</p>\n\n\n<p>​                                        </p>\n","excerpt":"","more":"<h3 id=\"ruanpapa和又吉君到底是什么鬼？\"><a href=\"#ruanpapa和又吉君到底是什么鬼？\" class=\"headerlink\" title=\"ruanpapa和又吉君到底是什么鬼？\"></a>ruanpapa和又吉君到底是什么鬼？</h3><blockquote>\n<ul>\n<li>ruanpapa，多年草本植物，性温和，不易上火，无毒无公害。植株上长着不明自来卷毛发，无花期，只结果。茎干呈黑黄，估计大晚上的容易被踩到。</li>\n<li>又吉君，小型食肉动物，性情多变，不易有攻击行为，嗜睡，好吃，眼睛白长了。喜欢晒太阳，毛发蓬松，天气干燥易炸毛，皮肤黄里透白，太阳光下会发光。</li>\n</ul>\n</blockquote>\n<h3 id=\"两货怎么认识的\"><a href=\"#两货怎么认识的\" class=\"headerlink\" title=\"两货怎么认识的\"></a>两货怎么认识的</h3><ul>\n<li>有一天晚上又吉君出门捕食，走了十公里遇到了这棵草，不留神就踩到了。于是这棵草就赖上又吉君了。时不时给懒惰的又吉君投个食，于是又吉君就更懒惰了。</li>\n</ul>\n<h3 id=\"相处模式\"><a href=\"#相处模式\" class=\"headerlink\" title=\"相处模式\"></a>相处模式</h3><ul>\n<li><p>-“宝宝，给我个亲亲”<br>-“拒绝”<br>-“不给？？？？？！那好吧……”</p>\n</li>\n<li><p>-“papapapa，帮我找个软件/教程”<br>-“好的！٩(๑❛ᴗ❛๑)۶”</p>\n</li>\n<li><p>-“papa！你这是什么鬼！丑死<br>了！！！！！！！！！”<br>-“…….”</p>\n</li>\n<li><p>-“宝宝，我们睡觉吧”<br>-“睡你麻痹！起来嗨”</p>\n</li>\n<li><p>-“papa，我好困(´･ω･`)”<br>-“这就困了？？”<br>“……..”</p>\n<p>“宝宝？？？”</p>\n<p>“妈的！睡着了！！！？”</p>\n</li>\n</ul>\n<h3 id=\"实际情况\"><a href=\"#实际情况\" class=\"headerlink\" title=\"实际情况\"></a>实际情况</h3><ul>\n<li>知乎相识</li>\n<li>认识三个月</li>\n<li>五一去旅游</li>\n<li>…….</li>\n</ul>\n<blockquote>\n<p><strong>未来那么长，请多多指教啊！</strong></p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5431890-d5b9a953241a5596.jpg\" alt=\"嘿，旁边的傻papa\">  </p>\n<p align=\"center\"><font color=\"9E9E9E\"><u>嘿，旁边的傻papa</u></font></p>\n\n<p><br><br><br></p>\n<p align=\"right\">by：又吉君</p>\n\n\n<p>​                                        </p>\n"},{"title":"ruanpapa和又吉君的日常之四","date":"2017-04-18T01:02:31.000Z","_content":"\n## 万恶之源\n> 又吉君：papa，今晚我不能陪你，我得做个Flash课件......\n>\n> 我：纳尼？？？？？Flash这么out的东西咱别用了嘛，又耗电又难看的\n>\n> 又吉君：没办法啊，我也没打算参加的，老师非要我们每一个人交作品，算期末分数的......\n>\n> 我：那我不打扰你了，你要乖乖的做完噢（满怀着对又吉君的想念我一个人睡了）\n\n万万没想到，第二天我起来发现又吉君竟然熬夜到了2点钟，而且还有好几个地方都有问题：按钮没响应、场景跳转不正常.....桥豆麻袋，这些听起来怎么像是代码的东西。于是在拯救又吉君于水深火热中的坚定信念以及程序猿的强烈自尊的驱使下，我果断接下了这个光荣而艰巨的任务！\n\n\n\n## 假装标题\n这任务是接下来了，海口也夸下了。可是一打开Adobe Flash Professional CS6我就懵逼了：这他喵的都是什么鬼啊\n\n![一脸懵逼](http://upload-images.jianshu.io/upload_images/698554-bb15f7c8352a0e81.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<p align=\"center\"><font color=\"9E9E9E\"><u>一脸懵逼</u></font></p>\n\n我这自己的Flash作业还是网上抄的呢，上课的时候都在玩手机，而且这上古时代的ActionScript语法简直逆天的难用，难怪乔老爷子10几年前就断定Flash命不久矣了。我的天老爷，难道这次要翻车了？\n\n\n\n> 又吉君：papa，你看一下main场景的那个按钮为什么没有响应啊，明明跟其他按钮一样的代码，就是没有反应，你知道怎么弄的吧\n>\n> 我：那当然知道啦，也不看看我是谁！（内心OS：Excuse me？场景是什么鬼Σ(☉▽☉\"a 代码？这个还能用代码控制？这么神奇的吗 !!!∑(ﾟДﾟノ)ノ\n>\n> 又吉君：噢再帮我插一个视频到flash里，谢谢papa~\n>\n> 我：谢什么谢，这么简单我三下五除二就搞定了，我做出来你亲我一下就行了（内心OS：视频？那不是还要播放暂停音量控制一大堆的咯.....）\n\n\n\n没办法，自己吹的牛皮，跪着也要吹完。于是Google+百度、中文+英文搜索：Flash场景快捷键是什么、insert video in flash、flash如何内嵌视频、1+1=?......等等一系列的词条，外加各种硬编码、magic code（希望部门老大永远不会看到这些代码，不然我肯定要被开除了），总算是把又吉君的所有要求都完成了✺◟(∗❛ัᴗ❛ั∗)◞✺\n\n\n\n## 皆大欢喜\n事情发展到这里并不能算完，这个逼装的只能算及格水平，算不得一个高质量的逼，于是：\n> 我：拿去吧，以后这么简单的东西早点给我嘛，省的你自己在那里弄那么久，心疼死我了\n>\n> 又吉君：哎呀！你都做好了吖！好棒啊你，mua~\n> <div align=center> \n> <img src=\"http://upload-images.jianshu.io/upload_images/698554-9424ee87eb6e498f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"  width=280  alt=\"迷妹又吉君\"/>\n> </div>\n> <p align=\"center\"><font color=\"9E9E9E\"><u>迷妹又吉君</u></font></p>\n> 我：唉，没挑战啊这任务，配不上我的身价啊\n>\n> 又吉君：么么么，爱死你啦~\n\n\n\n总算装了一个满意的逼，我人生装过无数的逼，但是最满意的，无疑是这一个（逃~\n\n<br>\n<br>\n<p align=\"right\">by：又吉君的ruanpapa</p>","source":"_posts/ruanpapa和又吉君的日常之四.md","raw":"---\ntitle: ruanpapa和又吉君的日常之四\ndate: 2017-04-18 09:02:31\ntags:\ncategories:\n- ruanpapa&又吉君的日常\n---\n\n## 万恶之源\n> 又吉君：papa，今晚我不能陪你，我得做个Flash课件......\n>\n> 我：纳尼？？？？？Flash这么out的东西咱别用了嘛，又耗电又难看的\n>\n> 又吉君：没办法啊，我也没打算参加的，老师非要我们每一个人交作品，算期末分数的......\n>\n> 我：那我不打扰你了，你要乖乖的做完噢（满怀着对又吉君的想念我一个人睡了）\n\n万万没想到，第二天我起来发现又吉君竟然熬夜到了2点钟，而且还有好几个地方都有问题：按钮没响应、场景跳转不正常.....桥豆麻袋，这些听起来怎么像是代码的东西。于是在拯救又吉君于水深火热中的坚定信念以及程序猿的强烈自尊的驱使下，我果断接下了这个光荣而艰巨的任务！\n\n\n\n## 假装标题\n这任务是接下来了，海口也夸下了。可是一打开Adobe Flash Professional CS6我就懵逼了：这他喵的都是什么鬼啊\n\n![一脸懵逼](http://upload-images.jianshu.io/upload_images/698554-bb15f7c8352a0e81.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<p align=\"center\"><font color=\"9E9E9E\"><u>一脸懵逼</u></font></p>\n\n我这自己的Flash作业还是网上抄的呢，上课的时候都在玩手机，而且这上古时代的ActionScript语法简直逆天的难用，难怪乔老爷子10几年前就断定Flash命不久矣了。我的天老爷，难道这次要翻车了？\n\n\n\n> 又吉君：papa，你看一下main场景的那个按钮为什么没有响应啊，明明跟其他按钮一样的代码，就是没有反应，你知道怎么弄的吧\n>\n> 我：那当然知道啦，也不看看我是谁！（内心OS：Excuse me？场景是什么鬼Σ(☉▽☉\"a 代码？这个还能用代码控制？这么神奇的吗 !!!∑(ﾟДﾟノ)ノ\n>\n> 又吉君：噢再帮我插一个视频到flash里，谢谢papa~\n>\n> 我：谢什么谢，这么简单我三下五除二就搞定了，我做出来你亲我一下就行了（内心OS：视频？那不是还要播放暂停音量控制一大堆的咯.....）\n\n\n\n没办法，自己吹的牛皮，跪着也要吹完。于是Google+百度、中文+英文搜索：Flash场景快捷键是什么、insert video in flash、flash如何内嵌视频、1+1=?......等等一系列的词条，外加各种硬编码、magic code（希望部门老大永远不会看到这些代码，不然我肯定要被开除了），总算是把又吉君的所有要求都完成了✺◟(∗❛ัᴗ❛ั∗)◞✺\n\n\n\n## 皆大欢喜\n事情发展到这里并不能算完，这个逼装的只能算及格水平，算不得一个高质量的逼，于是：\n> 我：拿去吧，以后这么简单的东西早点给我嘛，省的你自己在那里弄那么久，心疼死我了\n>\n> 又吉君：哎呀！你都做好了吖！好棒啊你，mua~\n> <div align=center> \n> <img src=\"http://upload-images.jianshu.io/upload_images/698554-9424ee87eb6e498f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"  width=280  alt=\"迷妹又吉君\"/>\n> </div>\n> <p align=\"center\"><font color=\"9E9E9E\"><u>迷妹又吉君</u></font></p>\n> 我：唉，没挑战啊这任务，配不上我的身价啊\n>\n> 又吉君：么么么，爱死你啦~\n\n\n\n总算装了一个满意的逼，我人生装过无数的逼，但是最满意的，无疑是这一个（逃~\n\n<br>\n<br>\n<p align=\"right\">by：又吉君的ruanpapa</p>","slug":"ruanpapa和又吉君的日常之四","published":1,"updated":"2017-04-26T04:00:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg4j8vys0018vfwxj4rjs92j","content":"<h2 id=\"万恶之源\"><a href=\"#万恶之源\" class=\"headerlink\" title=\"万恶之源\"></a>万恶之源</h2><blockquote>\n<p>又吉君：papa，今晚我不能陪你，我得做个Flash课件……</p>\n<p>我：纳尼？？？？？Flash这么out的东西咱别用了嘛，又耗电又难看的</p>\n<p>又吉君：没办法啊，我也没打算参加的，老师非要我们每一个人交作品，算期末分数的……</p>\n<p>我：那我不打扰你了，你要乖乖的做完噢（满怀着对又吉君的想念我一个人睡了）</p>\n</blockquote>\n<p>万万没想到，第二天我起来发现又吉君竟然熬夜到了2点钟，而且还有好几个地方都有问题：按钮没响应、场景跳转不正常…..桥豆麻袋，这些听起来怎么像是代码的东西。于是在拯救又吉君于水深火热中的坚定信念以及程序猿的强烈自尊的驱使下，我果断接下了这个光荣而艰巨的任务！</p>\n<h2 id=\"假装标题\"><a href=\"#假装标题\" class=\"headerlink\" title=\"假装标题\"></a>假装标题</h2><p>这任务是接下来了，海口也夸下了。可是一打开Adobe Flash Professional CS6我就懵逼了：这他喵的都是什么鬼啊</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-bb15f7c8352a0e81.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"一脸懵逼\"></p>\n<p align=\"center\"><font color=\"9E9E9E\"><u>一脸懵逼</u></font></p>\n\n<p>我这自己的Flash作业还是网上抄的呢，上课的时候都在玩手机，而且这上古时代的ActionScript语法简直逆天的难用，难怪乔老爷子10几年前就断定Flash命不久矣了。我的天老爷，难道这次要翻车了？</p>\n<blockquote>\n<p>又吉君：papa，你看一下main场景的那个按钮为什么没有响应啊，明明跟其他按钮一样的代码，就是没有反应，你知道怎么弄的吧</p>\n<p>我：那当然知道啦，也不看看我是谁！（内心OS：Excuse me？场景是什么鬼Σ(☉▽☉”a 代码？这个还能用代码控制？这么神奇的吗 !!!∑(ﾟДﾟノ)ノ</p>\n<p>又吉君：噢再帮我插一个视频到flash里，谢谢papa~</p>\n<p>我：谢什么谢，这么简单我三下五除二就搞定了，我做出来你亲我一下就行了（内心OS：视频？那不是还要播放暂停音量控制一大堆的咯…..）</p>\n</blockquote>\n<p>没办法，自己吹的牛皮，跪着也要吹完。于是Google+百度、中文+英文搜索：Flash场景快捷键是什么、insert video in flash、flash如何内嵌视频、1+1=?……等等一系列的词条，外加各种硬编码、magic code（希望部门老大永远不会看到这些代码，不然我肯定要被开除了），总算是把又吉君的所有要求都完成了✺◟(∗❛ัᴗ❛ั∗)◞✺</p>\n<h2 id=\"皆大欢喜\"><a href=\"#皆大欢喜\" class=\"headerlink\" title=\"皆大欢喜\"></a>皆大欢喜</h2><p>事情发展到这里并不能算完，这个逼装的只能算及格水平，算不得一个高质量的逼，于是：</p>\n<blockquote>\n<p>我：拿去吧，以后这么简单的东西早点给我嘛，省的你自己在那里弄那么久，心疼死我了</p>\n<p>又吉君：哎呀！你都做好了吖！好棒啊你，mua~</p>\n<p><div align=\"center\"><br><img src=\"http://upload-images.jianshu.io/upload_images/698554-9424ee87eb6e498f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" width=\"280\" alt=\"迷妹又吉君\"><br></div></p>\n<p></p><p align=\"center\"><font color=\"9E9E9E\"><u>迷妹又吉君</u></font></p><br>我：唉，没挑战啊这任务，配不上我的身价啊<p></p>\n<p>又吉君：么么么，爱死你啦~</p>\n</blockquote>\n<p>总算装了一个满意的逼，我人生装过无数的逼，但是最满意的，无疑是这一个（逃~</p>\n<p><br><br><br></p>\n<p align=\"right\">by：又吉君的ruanpapa</p>","excerpt":"","more":"<h2 id=\"万恶之源\"><a href=\"#万恶之源\" class=\"headerlink\" title=\"万恶之源\"></a>万恶之源</h2><blockquote>\n<p>又吉君：papa，今晚我不能陪你，我得做个Flash课件……</p>\n<p>我：纳尼？？？？？Flash这么out的东西咱别用了嘛，又耗电又难看的</p>\n<p>又吉君：没办法啊，我也没打算参加的，老师非要我们每一个人交作品，算期末分数的……</p>\n<p>我：那我不打扰你了，你要乖乖的做完噢（满怀着对又吉君的想念我一个人睡了）</p>\n</blockquote>\n<p>万万没想到，第二天我起来发现又吉君竟然熬夜到了2点钟，而且还有好几个地方都有问题：按钮没响应、场景跳转不正常…..桥豆麻袋，这些听起来怎么像是代码的东西。于是在拯救又吉君于水深火热中的坚定信念以及程序猿的强烈自尊的驱使下，我果断接下了这个光荣而艰巨的任务！</p>\n<h2 id=\"假装标题\"><a href=\"#假装标题\" class=\"headerlink\" title=\"假装标题\"></a>假装标题</h2><p>这任务是接下来了，海口也夸下了。可是一打开Adobe Flash Professional CS6我就懵逼了：这他喵的都是什么鬼啊</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-bb15f7c8352a0e81.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"一脸懵逼\"></p>\n<p align=\"center\"><font color=\"9E9E9E\"><u>一脸懵逼</u></font></p>\n\n<p>我这自己的Flash作业还是网上抄的呢，上课的时候都在玩手机，而且这上古时代的ActionScript语法简直逆天的难用，难怪乔老爷子10几年前就断定Flash命不久矣了。我的天老爷，难道这次要翻车了？</p>\n<blockquote>\n<p>又吉君：papa，你看一下main场景的那个按钮为什么没有响应啊，明明跟其他按钮一样的代码，就是没有反应，你知道怎么弄的吧</p>\n<p>我：那当然知道啦，也不看看我是谁！（内心OS：Excuse me？场景是什么鬼Σ(☉▽☉”a 代码？这个还能用代码控制？这么神奇的吗 !!!∑(ﾟДﾟノ)ノ</p>\n<p>又吉君：噢再帮我插一个视频到flash里，谢谢papa~</p>\n<p>我：谢什么谢，这么简单我三下五除二就搞定了，我做出来你亲我一下就行了（内心OS：视频？那不是还要播放暂停音量控制一大堆的咯…..）</p>\n</blockquote>\n<p>没办法，自己吹的牛皮，跪着也要吹完。于是Google+百度、中文+英文搜索：Flash场景快捷键是什么、insert video in flash、flash如何内嵌视频、1+1=?……等等一系列的词条，外加各种硬编码、magic code（希望部门老大永远不会看到这些代码，不然我肯定要被开除了），总算是把又吉君的所有要求都完成了✺◟(∗❛ัᴗ❛ั∗)◞✺</p>\n<h2 id=\"皆大欢喜\"><a href=\"#皆大欢喜\" class=\"headerlink\" title=\"皆大欢喜\"></a>皆大欢喜</h2><p>事情发展到这里并不能算完，这个逼装的只能算及格水平，算不得一个高质量的逼，于是：</p>\n<blockquote>\n<p>我：拿去吧，以后这么简单的东西早点给我嘛，省的你自己在那里弄那么久，心疼死我了</p>\n<p>又吉君：哎呀！你都做好了吖！好棒啊你，mua~</p>\n<p><div align=center><br><img src=\"http://upload-images.jianshu.io/upload_images/698554-9424ee87eb6e498f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"  width=280  alt=\"迷妹又吉君\"/><br></div></p>\n<p><p align=\"center\"><font color=\"9E9E9E\"><u>迷妹又吉君</u></font></p><br>我：唉，没挑战啊这任务，配不上我的身价啊</p>\n<p>又吉君：么么么，爱死你啦~</p>\n</blockquote>\n<p>总算装了一个满意的逼，我人生装过无数的逼，但是最满意的，无疑是这一个（逃~</p>\n<p><br><br><br></p>\n<p align=\"right\">by：又吉君的ruanpapa</p>"},{"title":"《指数基金投资指南》读后感","date":"2018-03-02T15:36:37.000Z","_content":"\n自己正式工作也已经半年多了，刚参加工作虽然工资不是很高，但是自己还是比较有规划的，没有比较花钱的嗜好，也有记账的习惯，所以慢慢也攒下了一点钱。有了钱就要考虑怎么安置的问题，自己经过了几个月业余时间的学习与权衡，最终确定了自己的投资理财方案：\n\n1. 这半年多攒下的钱留1万左右放到余额宝作为日常花销（餐饮、房租水电、购物等），以后每个月发了工资都会补充这部分到1万左右，足以应付自己的2~3个月的日常生活所需。最近因为国家把货币基金纳入了M2，总量1.6万亿的余额宝也开始了每日限额发售，不过现在还是有其他的替代品的，比如微信零钱通、支付宝中的余利宝、天天基金的活期宝等，这些都属于低风险、收益稳定的货币基金，七日年化收益率都有4.2%~4.4%，高过余额宝的4.1%，T+1日开始计算收益，同时实时转出，从资金灵活度、收益等角度都不输余额宝。\n\n2. 其余攒下的钱都购买银行的低风险的理财产品，年化收益能到4.8%~5.2%左右，通常期限都为90天以上，一年以下。不过在到期日之前无法赎回，可以说是完全没有灵活度的，不过相当的稳定。考虑到自己暂时不用添置大件，所以这笔钱放在低风险中比较高收益的产品中是最为理想的。\n\n3. 以后每个月发了工资，会填充一部分到第1点中，其余的大部分会根据自己的眼光进行基金定投。基金定投自己之前实习期间已经进行过了一段时间的学习与尝试，后来为了买电脑全取了出来，所以那次3个月定投没有赚到什么钱。现在有了稳定的收入，自己又再进行了一番学习。比较看好价值平均策略，这一部分留到关于《价值平均策略：获得高投资收益的安全简便方法》的读后感再分享，另一个就是一直都有留意的雪球大V[银行螺丝钉](https://xueqiu.com/u/3079173340)的\"盈利收益率\"获取超额收益的方法，接下来讲讲自己看完钉大的《指数基金投资指南》感想。\n\n   ​\n\n本书作者[@银行螺丝钉](https://xueqiu.com/u/3079173340)是一个90后，看起来有着超出年龄的成熟稳重，不仅从外观长相、说话谈吐，还从在雪球、微信公众号的耐心回答都能体现，同时他还坚持每天更新基金的估值表3年多，这样稳重、有毅力的人总是比较让人放心。同时他专注于低估值指数基金投资，以格雷厄姆和巴菲特为师，建立起基于估值的投资体系，以我个人对巴菲特的了解，他所坚持的价值投资、长期持有的风格是比较适合我的，而不是通过大量的技术分析，对赌高风险博取高收益，所以我选择尝试钉大所提倡的“盈利收益率”进行估值以期获得超额收益的定投方法。\n\n盈利收益率的定义是：盈利收益率=股票盈利/股票市值，其实也就是市盈率的倒数，这个指标反映了该股票的单位盈利能力。根据对全世界各个国家的股市历史数据进行观察，发现绝大多数股市，在熊市最低谷的时候，盈利收益率都会在10%以上，这是格雷厄姆买股票的第一个标准。第二个标准是只有当股票的盈利收益率是国债利率的两倍以上时，我们才会去考虑股票。\n\n**(1). 盈利收益率要大于10%**\n\n**(2). 盈利收益率要在国债利率的两倍以上**\n\n符合这两个标准的就是当前低估的股票基金，我们可以不断定投符合这两个标准的基金，当越是低估时，我们定投对应的那一期的额度越要增加，这样我们在低位买入的份额会更多，当基金到了高位，我们就能获得更多的收益。\n\n当基金估值从低估回到正常估值的时候，我们就停止定投，转为持有基金，等到估值到了高估的时候，我们就可以分批卖出我们持有的基金。以沪深300指数为例，估值主要集中在10-18PE，低于10PE就是低估阶段，此时坚持定投；10-18PE为正常估值，持有基金；高于18PE就是高估阶段，分批卖出。具体哪些基金处于估值的哪个阶段，可以关注钉大的微信公众号，每个交易日更新估值数据。\n\n我个人还是比较看好这种方式的，也解决了之前普通定投的卖出止损等的一些问题。最后就是心态的问题，短期内要有拥抱下跌的准备，现在的下跌亏损意味着我们在低点多买入了份额，而这不正是很多人在回测复盘的时候想要做到的吗，千万不要被黎明前的黑暗所吓倒！","source":"_posts/《指数基金投资指南》读后感.md","raw":"---\ntitle: 《指数基金投资指南》读后感\ndate: 2018-03-02 23:36:37\ntags:\n- 投资理财\n- 基金定投\n- 读后感\ncategories:\n- 投资理财\n---\n\n自己正式工作也已经半年多了，刚参加工作虽然工资不是很高，但是自己还是比较有规划的，没有比较花钱的嗜好，也有记账的习惯，所以慢慢也攒下了一点钱。有了钱就要考虑怎么安置的问题，自己经过了几个月业余时间的学习与权衡，最终确定了自己的投资理财方案：\n\n1. 这半年多攒下的钱留1万左右放到余额宝作为日常花销（餐饮、房租水电、购物等），以后每个月发了工资都会补充这部分到1万左右，足以应付自己的2~3个月的日常生活所需。最近因为国家把货币基金纳入了M2，总量1.6万亿的余额宝也开始了每日限额发售，不过现在还是有其他的替代品的，比如微信零钱通、支付宝中的余利宝、天天基金的活期宝等，这些都属于低风险、收益稳定的货币基金，七日年化收益率都有4.2%~4.4%，高过余额宝的4.1%，T+1日开始计算收益，同时实时转出，从资金灵活度、收益等角度都不输余额宝。\n\n2. 其余攒下的钱都购买银行的低风险的理财产品，年化收益能到4.8%~5.2%左右，通常期限都为90天以上，一年以下。不过在到期日之前无法赎回，可以说是完全没有灵活度的，不过相当的稳定。考虑到自己暂时不用添置大件，所以这笔钱放在低风险中比较高收益的产品中是最为理想的。\n\n3. 以后每个月发了工资，会填充一部分到第1点中，其余的大部分会根据自己的眼光进行基金定投。基金定投自己之前实习期间已经进行过了一段时间的学习与尝试，后来为了买电脑全取了出来，所以那次3个月定投没有赚到什么钱。现在有了稳定的收入，自己又再进行了一番学习。比较看好价值平均策略，这一部分留到关于《价值平均策略：获得高投资收益的安全简便方法》的读后感再分享，另一个就是一直都有留意的雪球大V[银行螺丝钉](https://xueqiu.com/u/3079173340)的\"盈利收益率\"获取超额收益的方法，接下来讲讲自己看完钉大的《指数基金投资指南》感想。\n\n   ​\n\n本书作者[@银行螺丝钉](https://xueqiu.com/u/3079173340)是一个90后，看起来有着超出年龄的成熟稳重，不仅从外观长相、说话谈吐，还从在雪球、微信公众号的耐心回答都能体现，同时他还坚持每天更新基金的估值表3年多，这样稳重、有毅力的人总是比较让人放心。同时他专注于低估值指数基金投资，以格雷厄姆和巴菲特为师，建立起基于估值的投资体系，以我个人对巴菲特的了解，他所坚持的价值投资、长期持有的风格是比较适合我的，而不是通过大量的技术分析，对赌高风险博取高收益，所以我选择尝试钉大所提倡的“盈利收益率”进行估值以期获得超额收益的定投方法。\n\n盈利收益率的定义是：盈利收益率=股票盈利/股票市值，其实也就是市盈率的倒数，这个指标反映了该股票的单位盈利能力。根据对全世界各个国家的股市历史数据进行观察，发现绝大多数股市，在熊市最低谷的时候，盈利收益率都会在10%以上，这是格雷厄姆买股票的第一个标准。第二个标准是只有当股票的盈利收益率是国债利率的两倍以上时，我们才会去考虑股票。\n\n**(1). 盈利收益率要大于10%**\n\n**(2). 盈利收益率要在国债利率的两倍以上**\n\n符合这两个标准的就是当前低估的股票基金，我们可以不断定投符合这两个标准的基金，当越是低估时，我们定投对应的那一期的额度越要增加，这样我们在低位买入的份额会更多，当基金到了高位，我们就能获得更多的收益。\n\n当基金估值从低估回到正常估值的时候，我们就停止定投，转为持有基金，等到估值到了高估的时候，我们就可以分批卖出我们持有的基金。以沪深300指数为例，估值主要集中在10-18PE，低于10PE就是低估阶段，此时坚持定投；10-18PE为正常估值，持有基金；高于18PE就是高估阶段，分批卖出。具体哪些基金处于估值的哪个阶段，可以关注钉大的微信公众号，每个交易日更新估值数据。\n\n我个人还是比较看好这种方式的，也解决了之前普通定投的卖出止损等的一些问题。最后就是心态的问题，短期内要有拥抱下跌的准备，现在的下跌亏损意味着我们在低点多买入了份额，而这不正是很多人在回测复盘的时候想要做到的吗，千万不要被黎明前的黑暗所吓倒！","slug":"《指数基金投资指南》读后感","published":1,"updated":"2018-03-03T06:46:36.695Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg4j8w2l001svfwx3vl9ulj5","content":"<p>自己正式工作也已经半年多了，刚参加工作虽然工资不是很高，但是自己还是比较有规划的，没有比较花钱的嗜好，也有记账的习惯，所以慢慢也攒下了一点钱。有了钱就要考虑怎么安置的问题，自己经过了几个月业余时间的学习与权衡，最终确定了自己的投资理财方案：</p>\n<ol>\n<li><p>这半年多攒下的钱留1万左右放到余额宝作为日常花销（餐饮、房租水电、购物等），以后每个月发了工资都会补充这部分到1万左右，足以应付自己的2~3个月的日常生活所需。最近因为国家把货币基金纳入了M2，总量1.6万亿的余额宝也开始了每日限额发售，不过现在还是有其他的替代品的，比如微信零钱通、支付宝中的余利宝、天天基金的活期宝等，这些都属于低风险、收益稳定的货币基金，七日年化收益率都有4.2%~4.4%，高过余额宝的4.1%，T+1日开始计算收益，同时实时转出，从资金灵活度、收益等角度都不输余额宝。</p>\n</li>\n<li><p>其余攒下的钱都购买银行的低风险的理财产品，年化收益能到4.8%~5.2%左右，通常期限都为90天以上，一年以下。不过在到期日之前无法赎回，可以说是完全没有灵活度的，不过相当的稳定。考虑到自己暂时不用添置大件，所以这笔钱放在低风险中比较高收益的产品中是最为理想的。</p>\n</li>\n<li><p>以后每个月发了工资，会填充一部分到第1点中，其余的大部分会根据自己的眼光进行基金定投。基金定投自己之前实习期间已经进行过了一段时间的学习与尝试，后来为了买电脑全取了出来，所以那次3个月定投没有赚到什么钱。现在有了稳定的收入，自己又再进行了一番学习。比较看好价值平均策略，这一部分留到关于《价值平均策略：获得高投资收益的安全简便方法》的读后感再分享，另一个就是一直都有留意的雪球大V<a href=\"https://xueqiu.com/u/3079173340\" target=\"_blank\" rel=\"external\">银行螺丝钉</a>的”盈利收益率”获取超额收益的方法，接下来讲讲自己看完钉大的《指数基金投资指南》感想。</p>\n<p>​</p>\n</li>\n</ol>\n<p>本书作者<a href=\"https://xueqiu.com/u/3079173340\" target=\"_blank\" rel=\"external\">@银行螺丝钉</a>是一个90后，看起来有着超出年龄的成熟稳重，不仅从外观长相、说话谈吐，还从在雪球、微信公众号的耐心回答都能体现，同时他还坚持每天更新基金的估值表3年多，这样稳重、有毅力的人总是比较让人放心。同时他专注于低估值指数基金投资，以格雷厄姆和巴菲特为师，建立起基于估值的投资体系，以我个人对巴菲特的了解，他所坚持的价值投资、长期持有的风格是比较适合我的，而不是通过大量的技术分析，对赌高风险博取高收益，所以我选择尝试钉大所提倡的“盈利收益率”进行估值以期获得超额收益的定投方法。</p>\n<p>盈利收益率的定义是：盈利收益率=股票盈利/股票市值，其实也就是市盈率的倒数，这个指标反映了该股票的单位盈利能力。根据对全世界各个国家的股市历史数据进行观察，发现绝大多数股市，在熊市最低谷的时候，盈利收益率都会在10%以上，这是格雷厄姆买股票的第一个标准。第二个标准是只有当股票的盈利收益率是国债利率的两倍以上时，我们才会去考虑股票。</p>\n<p><strong>(1). 盈利收益率要大于10%</strong></p>\n<p><strong>(2). 盈利收益率要在国债利率的两倍以上</strong></p>\n<p>符合这两个标准的就是当前低估的股票基金，我们可以不断定投符合这两个标准的基金，当越是低估时，我们定投对应的那一期的额度越要增加，这样我们在低位买入的份额会更多，当基金到了高位，我们就能获得更多的收益。</p>\n<p>当基金估值从低估回到正常估值的时候，我们就停止定投，转为持有基金，等到估值到了高估的时候，我们就可以分批卖出我们持有的基金。以沪深300指数为例，估值主要集中在10-18PE，低于10PE就是低估阶段，此时坚持定投；10-18PE为正常估值，持有基金；高于18PE就是高估阶段，分批卖出。具体哪些基金处于估值的哪个阶段，可以关注钉大的微信公众号，每个交易日更新估值数据。</p>\n<p>我个人还是比较看好这种方式的，也解决了之前普通定投的卖出止损等的一些问题。最后就是心态的问题，短期内要有拥抱下跌的准备，现在的下跌亏损意味着我们在低点多买入了份额，而这不正是很多人在回测复盘的时候想要做到的吗，千万不要被黎明前的黑暗所吓倒！</p>\n","excerpt":"","more":"<p>自己正式工作也已经半年多了，刚参加工作虽然工资不是很高，但是自己还是比较有规划的，没有比较花钱的嗜好，也有记账的习惯，所以慢慢也攒下了一点钱。有了钱就要考虑怎么安置的问题，自己经过了几个月业余时间的学习与权衡，最终确定了自己的投资理财方案：</p>\n<ol>\n<li><p>这半年多攒下的钱留1万左右放到余额宝作为日常花销（餐饮、房租水电、购物等），以后每个月发了工资都会补充这部分到1万左右，足以应付自己的2~3个月的日常生活所需。最近因为国家把货币基金纳入了M2，总量1.6万亿的余额宝也开始了每日限额发售，不过现在还是有其他的替代品的，比如微信零钱通、支付宝中的余利宝、天天基金的活期宝等，这些都属于低风险、收益稳定的货币基金，七日年化收益率都有4.2%~4.4%，高过余额宝的4.1%，T+1日开始计算收益，同时实时转出，从资金灵活度、收益等角度都不输余额宝。</p>\n</li>\n<li><p>其余攒下的钱都购买银行的低风险的理财产品，年化收益能到4.8%~5.2%左右，通常期限都为90天以上，一年以下。不过在到期日之前无法赎回，可以说是完全没有灵活度的，不过相当的稳定。考虑到自己暂时不用添置大件，所以这笔钱放在低风险中比较高收益的产品中是最为理想的。</p>\n</li>\n<li><p>以后每个月发了工资，会填充一部分到第1点中，其余的大部分会根据自己的眼光进行基金定投。基金定投自己之前实习期间已经进行过了一段时间的学习与尝试，后来为了买电脑全取了出来，所以那次3个月定投没有赚到什么钱。现在有了稳定的收入，自己又再进行了一番学习。比较看好价值平均策略，这一部分留到关于《价值平均策略：获得高投资收益的安全简便方法》的读后感再分享，另一个就是一直都有留意的雪球大V<a href=\"https://xueqiu.com/u/3079173340\">银行螺丝钉</a>的”盈利收益率”获取超额收益的方法，接下来讲讲自己看完钉大的《指数基金投资指南》感想。</p>\n<p>​</p>\n</li>\n</ol>\n<p>本书作者<a href=\"https://xueqiu.com/u/3079173340\">@银行螺丝钉</a>是一个90后，看起来有着超出年龄的成熟稳重，不仅从外观长相、说话谈吐，还从在雪球、微信公众号的耐心回答都能体现，同时他还坚持每天更新基金的估值表3年多，这样稳重、有毅力的人总是比较让人放心。同时他专注于低估值指数基金投资，以格雷厄姆和巴菲特为师，建立起基于估值的投资体系，以我个人对巴菲特的了解，他所坚持的价值投资、长期持有的风格是比较适合我的，而不是通过大量的技术分析，对赌高风险博取高收益，所以我选择尝试钉大所提倡的“盈利收益率”进行估值以期获得超额收益的定投方法。</p>\n<p>盈利收益率的定义是：盈利收益率=股票盈利/股票市值，其实也就是市盈率的倒数，这个指标反映了该股票的单位盈利能力。根据对全世界各个国家的股市历史数据进行观察，发现绝大多数股市，在熊市最低谷的时候，盈利收益率都会在10%以上，这是格雷厄姆买股票的第一个标准。第二个标准是只有当股票的盈利收益率是国债利率的两倍以上时，我们才会去考虑股票。</p>\n<p><strong>(1). 盈利收益率要大于10%</strong></p>\n<p><strong>(2). 盈利收益率要在国债利率的两倍以上</strong></p>\n<p>符合这两个标准的就是当前低估的股票基金，我们可以不断定投符合这两个标准的基金，当越是低估时，我们定投对应的那一期的额度越要增加，这样我们在低位买入的份额会更多，当基金到了高位，我们就能获得更多的收益。</p>\n<p>当基金估值从低估回到正常估值的时候，我们就停止定投，转为持有基金，等到估值到了高估的时候，我们就可以分批卖出我们持有的基金。以沪深300指数为例，估值主要集中在10-18PE，低于10PE就是低估阶段，此时坚持定投；10-18PE为正常估值，持有基金；高于18PE就是高估阶段，分批卖出。具体哪些基金处于估值的哪个阶段，可以关注钉大的微信公众号，每个交易日更新估值数据。</p>\n<p>我个人还是比较看好这种方式的，也解决了之前普通定投的卖出止损等的一些问题。最后就是心态的问题，短期内要有拥抱下跌的准备，现在的下跌亏损意味着我们在低点多买入了份额，而这不正是很多人在回测复盘的时候想要做到的吗，千万不要被黎明前的黑暗所吓倒！</p>\n"},{"title":"短暂而快乐--苏州行","date":"2017-05-15T01:26:50.000Z","_content":"\n> 倒计时45天.....似乎还是遥不可及的事情，日常挑逗我的又吉宝宝(づ￣3￣)づ╭❤～\n> 倒计时30天......还一个月呐O__O \"…该写代码写代码，该吃饭吃饭\n> 倒计时14天......完全没办法压抑自己的激动了，每天和又吉宝宝憧憬着到了苏州要玩什么吃什么，各种叮嘱对方带这个带那个的，连到时候一起看《虫师》都决定好了\n> 倒计时7天......反而冷静了下来，两个人都少了提及苏州旅游的话题，约定好这星期要一起认真学习认真工作，内心却为即将到来的见面而翻腾\n> 倒计时1天......还写个毛的代码啊，一天都没写够10行代码，可惜又吉宝宝整整一天的课，我这满腔的兴奋没地方诉说/(ㄒoㄒ)/~~\n\n终于熬到了下班了！！！三步并作两步冲回宿舍背上我的小书包，奔着机场就去了。一路上，无视因为放假堵塞的地铁站，无视闷热的天气，无视自己的第一次坐飞机。苏州，我来啦！！！\n\n**行程一览：天河-->白云机场-->硕放机场-->无锡火车站-->苏州火车站** \n\n![超级欢脱](http://upload-images.jianshu.io/upload_images/698554-3da74167361aa6cb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<p align=\"center\"><font color=\"9E9E9E\"><u>超级欢脱</u></font></p>\n\n<br>\n\n无锡火车站外左等右等，终于等来了载着我朝思暮想的又吉宝宝的火车。踏上第4节车厢一眼就看到座位上探头探脑寻找着我的小又吉，赶快戴上帽子压低头附身跟着前面的人走向那个朝思暮想了几个月的那个家伙。一屁股坐下又吉宝宝旁边，这小傻瓜竟然第一句话是问我要不要吃她带的枣糕(喵喵喵？？？汪汪汪？？？你就这开场白吗？？？) 这货竟然敢对我那么冷淡，一把握住她的手，不由分说牵的死死的：这才像话嘛，劳资山长水远的飞奔而来，可不得好好牵牵小手啊吼！\n但是，还没坐几分钟，位置的主人就来了，只好起身站在了走道上，她呢，身子一侧又睡了！！！我这个暴脾气啊：你就这么冷淡吗，看不到我有位置都不回去坐，站在这儿不就是为了看你吗？你还这么心大？待会儿下车你就知道错了！口亨！！！\n\n![气死我啦](http://upload-images.jianshu.io/upload_images/698554-857da72b6b770c92.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<p align=\"center\"><font color=\"9E9E9E\"><u>气死我啦</u></font></p>\n\n<br>\n\n28分钟的火车我就跟站了28小时一样，明明两步外坐着自己心爱的女人(虽然睡得🐖一样)，自己却没办法触碰到她。/(ㄒoㄒ)/~总算捱到了下车，发现我出省连网都没得上了，于是我全程像个考拉一样贴在了宝宝身上，又吉宝宝找肯德基准备待到天亮，而我的关注点就全在牵着又吉宝宝的手上~摸摸手~搭搭肩膀~掐掐脸~管她去哪儿呢，爱去哪去哪！\n\n清晨的苏州真的是很舒适宜居，爱人在旁，清风拂面，绿树相伴，天空蓝蓝的，空气凉凉的，好奇的盯着这江南每一处建筑，每一个过去的人，通宵没睡的倦意也一扫而光，贪婪的享受这闲适的一切。步行来到早已计划好的平江路，果真名不虚传，俩人都赞不绝口，背阴像隔开了旭日初升的热气，两旁的店面都满满的江南水乡风格。俩人在沿河的石阶上上坐了好久好久，完全没有第一次见的陌生感，聊聊平江路，聊聊待会儿的行程，聊聊喝茶，聊聊坐飞机坐车的事情，一点都不想走了。接着去了闻名遐迩的拙政园，真的是人山人海啊，游完一遍俩人一致认为这里言过其实了.....\n\n来到酒店顺利办了入住，进入房间的时候终于能松一口气了，顾不上放下行李，紧紧抱住了眼前这个人，情不自禁的亲吻她。简单的洗漱过后终于能躺下了，瞬间倦意袭来，抱着软软的又吉宝宝睡了过去，就像抱住了全世界，俩人相拥而眠，然后......就睡死过去啦:-D\n\n### 宇宙第一可爱的又吉宝宝\n\n醒来的第一眼就能看到心爱的人，看着熟睡的她，轻轻的吐着气呼吸，长长的眼睫毛一动一动的，像只乖巧的小猫咪，我情不自禁心上像开了一朵花，轻轻的亲了她糖果味的嘴唇仿佛拥有了全世界， 凑过去抱住了她又睡了过去......订了喜欢吃的海鲜外卖，总是忍不住看着她吃东西，心都要萌化了好吗？怎么有这么可爱的人！！\n\n### 心灵手巧的又吉宝宝(插叙)\n\n吉：“papapapapa~你看你看，这个日本的羊毛毡狗系列好萌啊啊啊啊啊！！！！”\npa：“买买买！喜欢就买！！！”\n俩人一通找，发现正版一个竟然要几百块钱。囧，买个鬼啊买，根本买不起好吗？(话说不就一个手工羊毛毡制品吗，卖那么贵干嘛哦！)\n吉：“可我真的喜欢嘛......诶不如我自己来做吧”？\npa：“呃......你行吗”？(手残星人表示不可思议)\n然后我就华丽丽的忘了这一茬了(｀・ω・´)\n没想到她竟然真的买了材料，花了一个下午加晚上给我扎了一个羊毛毡出来，还带到苏州来送给我(感动cry)\n完全不输给正版的好吗！！！看这胖乎乎的身体，看这蠢萌的脸，看这傲娇的......屁股，哈哈哈哈啊哈哈\n![羊毛毡小狗狗](http://upload-images.jianshu.io/upload_images/698554-956dd5f4addca414.jpg)\n\n<p align=\"center\"><font color=\"9E9E9E\"><u>羊毛毡小狗狗</u></font></p>\n\n<br>\n\n### 小拖延的又吉宝宝\n\n三催四请让她去洗澡都不听话，我走过去一把熊抱起来，扔到床上：“立刻马上找你换洗的衣服”！然后一把抱起丢到浴室：“你！立刻洗澡！！ 别废话！！！”  她悻悻地关上门洗澡，一脸不甘愿的表情我就知道她肯定还想再玩会儿。没门！小样儿，还治不了你了！(╬￣皿￣)=\n\n### 毫不客气的又吉宝宝\n\n吉：“papa，我这脚好痛噢(ಥ_ಥ)你帮我揉一下~” 我还在想开口问为什么脚痛呢。啪！一只大白腿就架在了我肚皮上，脚趾都快碰到我嘴了。好气又好笑٩(๑❛ᴗ❛๑)۶ 揉揉揉，这三天尽给她揉脚了(๑¯∀¯๑)\n\n<br>\n\n<br>\n\n欢乐的时光总是特别短暂，转眼到了该分别的时候(;´༎ຶД༎ຶ`) 浑浑噩噩的回到了广州，满满的不舍得......不过呢，下一次的行程也安排好了，我又可以开始倒数啦~\\(≧≦)/~啦啦啦\n\n<br>\n<br>\n<p align=\"right\">by：又吉君的ruanpapa</p>","source":"_posts/短暂而快乐-苏州行.md","raw":"---\ntitle: 短暂而快乐--苏州行\ndate: 2017-05-15 09:26:50\ntags:\ncategories:\n- ruanpapa&又吉君的日常\n---\n\n> 倒计时45天.....似乎还是遥不可及的事情，日常挑逗我的又吉宝宝(づ￣3￣)づ╭❤～\n> 倒计时30天......还一个月呐O__O \"…该写代码写代码，该吃饭吃饭\n> 倒计时14天......完全没办法压抑自己的激动了，每天和又吉宝宝憧憬着到了苏州要玩什么吃什么，各种叮嘱对方带这个带那个的，连到时候一起看《虫师》都决定好了\n> 倒计时7天......反而冷静了下来，两个人都少了提及苏州旅游的话题，约定好这星期要一起认真学习认真工作，内心却为即将到来的见面而翻腾\n> 倒计时1天......还写个毛的代码啊，一天都没写够10行代码，可惜又吉宝宝整整一天的课，我这满腔的兴奋没地方诉说/(ㄒoㄒ)/~~\n\n终于熬到了下班了！！！三步并作两步冲回宿舍背上我的小书包，奔着机场就去了。一路上，无视因为放假堵塞的地铁站，无视闷热的天气，无视自己的第一次坐飞机。苏州，我来啦！！！\n\n**行程一览：天河-->白云机场-->硕放机场-->无锡火车站-->苏州火车站** \n\n![超级欢脱](http://upload-images.jianshu.io/upload_images/698554-3da74167361aa6cb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<p align=\"center\"><font color=\"9E9E9E\"><u>超级欢脱</u></font></p>\n\n<br>\n\n无锡火车站外左等右等，终于等来了载着我朝思暮想的又吉宝宝的火车。踏上第4节车厢一眼就看到座位上探头探脑寻找着我的小又吉，赶快戴上帽子压低头附身跟着前面的人走向那个朝思暮想了几个月的那个家伙。一屁股坐下又吉宝宝旁边，这小傻瓜竟然第一句话是问我要不要吃她带的枣糕(喵喵喵？？？汪汪汪？？？你就这开场白吗？？？) 这货竟然敢对我那么冷淡，一把握住她的手，不由分说牵的死死的：这才像话嘛，劳资山长水远的飞奔而来，可不得好好牵牵小手啊吼！\n但是，还没坐几分钟，位置的主人就来了，只好起身站在了走道上，她呢，身子一侧又睡了！！！我这个暴脾气啊：你就这么冷淡吗，看不到我有位置都不回去坐，站在这儿不就是为了看你吗？你还这么心大？待会儿下车你就知道错了！口亨！！！\n\n![气死我啦](http://upload-images.jianshu.io/upload_images/698554-857da72b6b770c92.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<p align=\"center\"><font color=\"9E9E9E\"><u>气死我啦</u></font></p>\n\n<br>\n\n28分钟的火车我就跟站了28小时一样，明明两步外坐着自己心爱的女人(虽然睡得🐖一样)，自己却没办法触碰到她。/(ㄒoㄒ)/~总算捱到了下车，发现我出省连网都没得上了，于是我全程像个考拉一样贴在了宝宝身上，又吉宝宝找肯德基准备待到天亮，而我的关注点就全在牵着又吉宝宝的手上~摸摸手~搭搭肩膀~掐掐脸~管她去哪儿呢，爱去哪去哪！\n\n清晨的苏州真的是很舒适宜居，爱人在旁，清风拂面，绿树相伴，天空蓝蓝的，空气凉凉的，好奇的盯着这江南每一处建筑，每一个过去的人，通宵没睡的倦意也一扫而光，贪婪的享受这闲适的一切。步行来到早已计划好的平江路，果真名不虚传，俩人都赞不绝口，背阴像隔开了旭日初升的热气，两旁的店面都满满的江南水乡风格。俩人在沿河的石阶上上坐了好久好久，完全没有第一次见的陌生感，聊聊平江路，聊聊待会儿的行程，聊聊喝茶，聊聊坐飞机坐车的事情，一点都不想走了。接着去了闻名遐迩的拙政园，真的是人山人海啊，游完一遍俩人一致认为这里言过其实了.....\n\n来到酒店顺利办了入住，进入房间的时候终于能松一口气了，顾不上放下行李，紧紧抱住了眼前这个人，情不自禁的亲吻她。简单的洗漱过后终于能躺下了，瞬间倦意袭来，抱着软软的又吉宝宝睡了过去，就像抱住了全世界，俩人相拥而眠，然后......就睡死过去啦:-D\n\n### 宇宙第一可爱的又吉宝宝\n\n醒来的第一眼就能看到心爱的人，看着熟睡的她，轻轻的吐着气呼吸，长长的眼睫毛一动一动的，像只乖巧的小猫咪，我情不自禁心上像开了一朵花，轻轻的亲了她糖果味的嘴唇仿佛拥有了全世界， 凑过去抱住了她又睡了过去......订了喜欢吃的海鲜外卖，总是忍不住看着她吃东西，心都要萌化了好吗？怎么有这么可爱的人！！\n\n### 心灵手巧的又吉宝宝(插叙)\n\n吉：“papapapapa~你看你看，这个日本的羊毛毡狗系列好萌啊啊啊啊啊！！！！”\npa：“买买买！喜欢就买！！！”\n俩人一通找，发现正版一个竟然要几百块钱。囧，买个鬼啊买，根本买不起好吗？(话说不就一个手工羊毛毡制品吗，卖那么贵干嘛哦！)\n吉：“可我真的喜欢嘛......诶不如我自己来做吧”？\npa：“呃......你行吗”？(手残星人表示不可思议)\n然后我就华丽丽的忘了这一茬了(｀・ω・´)\n没想到她竟然真的买了材料，花了一个下午加晚上给我扎了一个羊毛毡出来，还带到苏州来送给我(感动cry)\n完全不输给正版的好吗！！！看这胖乎乎的身体，看这蠢萌的脸，看这傲娇的......屁股，哈哈哈哈啊哈哈\n![羊毛毡小狗狗](http://upload-images.jianshu.io/upload_images/698554-956dd5f4addca414.jpg)\n\n<p align=\"center\"><font color=\"9E9E9E\"><u>羊毛毡小狗狗</u></font></p>\n\n<br>\n\n### 小拖延的又吉宝宝\n\n三催四请让她去洗澡都不听话，我走过去一把熊抱起来，扔到床上：“立刻马上找你换洗的衣服”！然后一把抱起丢到浴室：“你！立刻洗澡！！ 别废话！！！”  她悻悻地关上门洗澡，一脸不甘愿的表情我就知道她肯定还想再玩会儿。没门！小样儿，还治不了你了！(╬￣皿￣)=\n\n### 毫不客气的又吉宝宝\n\n吉：“papa，我这脚好痛噢(ಥ_ಥ)你帮我揉一下~” 我还在想开口问为什么脚痛呢。啪！一只大白腿就架在了我肚皮上，脚趾都快碰到我嘴了。好气又好笑٩(๑❛ᴗ❛๑)۶ 揉揉揉，这三天尽给她揉脚了(๑¯∀¯๑)\n\n<br>\n\n<br>\n\n欢乐的时光总是特别短暂，转眼到了该分别的时候(;´༎ຶД༎ຶ`) 浑浑噩噩的回到了广州，满满的不舍得......不过呢，下一次的行程也安排好了，我又可以开始倒数啦~\\(≧≦)/~啦啦啦\n\n<br>\n<br>\n<p align=\"right\">by：又吉君的ruanpapa</p>","slug":"短暂而快乐-苏州行","published":1,"updated":"2017-05-15T01:37:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg4j8w2m001uvfwx6waeyjwb","content":"<blockquote>\n<p>倒计时45天…..似乎还是遥不可及的事情，日常挑逗我的又吉宝宝(づ￣3￣)づ╭❤～<br>倒计时30天……还一个月呐O__O “…该写代码写代码，该吃饭吃饭<br>倒计时14天……完全没办法压抑自己的激动了，每天和又吉宝宝憧憬着到了苏州要玩什么吃什么，各种叮嘱对方带这个带那个的，连到时候一起看《虫师》都决定好了<br>倒计时7天……反而冷静了下来，两个人都少了提及苏州旅游的话题，约定好这星期要一起认真学习认真工作，内心却为即将到来的见面而翻腾<br>倒计时1天……还写个毛的代码啊，一天都没写够10行代码，可惜又吉宝宝整整一天的课，我这满腔的兴奋没地方诉说/(ㄒoㄒ)/~~</p>\n</blockquote>\n<p>终于熬到了下班了！！！三步并作两步冲回宿舍背上我的小书包，奔着机场就去了。一路上，无视因为放假堵塞的地铁站，无视闷热的天气，无视自己的第一次坐飞机。苏州，我来啦！！！</p>\n<p><strong>行程一览：天河–&gt;白云机场–&gt;硕放机场–&gt;无锡火车站–&gt;苏州火车站</strong> </p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-3da74167361aa6cb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"超级欢脱\"></p>\n<p align=\"center\"><font color=\"9E9E9E\"><u>超级欢脱</u></font></p>\n\n<p><br></p>\n<p>无锡火车站外左等右等，终于等来了载着我朝思暮想的又吉宝宝的火车。踏上第4节车厢一眼就看到座位上探头探脑寻找着我的小又吉，赶快戴上帽子压低头附身跟着前面的人走向那个朝思暮想了几个月的那个家伙。一屁股坐下又吉宝宝旁边，这小傻瓜竟然第一句话是问我要不要吃她带的枣糕(喵喵喵？？？汪汪汪？？？你就这开场白吗？？？) 这货竟然敢对我那么冷淡，一把握住她的手，不由分说牵的死死的：这才像话嘛，劳资山长水远的飞奔而来，可不得好好牵牵小手啊吼！<br>但是，还没坐几分钟，位置的主人就来了，只好起身站在了走道上，她呢，身子一侧又睡了！！！我这个暴脾气啊：你就这么冷淡吗，看不到我有位置都不回去坐，站在这儿不就是为了看你吗？你还这么心大？待会儿下车你就知道错了！口亨！！！</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-857da72b6b770c92.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"气死我啦\"></p>\n<p align=\"center\"><font color=\"9E9E9E\"><u>气死我啦</u></font></p>\n\n<p><br></p>\n<p>28分钟的火车我就跟站了28小时一样，明明两步外坐着自己心爱的女人(虽然睡得🐖一样)，自己却没办法触碰到她。/(ㄒoㄒ)/~总算捱到了下车，发现我出省连网都没得上了，于是我全程像个考拉一样贴在了宝宝身上，又吉宝宝找肯德基准备待到天亮，而我的关注点就全在牵着又吉宝宝的手上~摸摸手~搭搭肩膀~掐掐脸~管她去哪儿呢，爱去哪去哪！</p>\n<p>清晨的苏州真的是很舒适宜居，爱人在旁，清风拂面，绿树相伴，天空蓝蓝的，空气凉凉的，好奇的盯着这江南每一处建筑，每一个过去的人，通宵没睡的倦意也一扫而光，贪婪的享受这闲适的一切。步行来到早已计划好的平江路，果真名不虚传，俩人都赞不绝口，背阴像隔开了旭日初升的热气，两旁的店面都满满的江南水乡风格。俩人在沿河的石阶上上坐了好久好久，完全没有第一次见的陌生感，聊聊平江路，聊聊待会儿的行程，聊聊喝茶，聊聊坐飞机坐车的事情，一点都不想走了。接着去了闻名遐迩的拙政园，真的是人山人海啊，游完一遍俩人一致认为这里言过其实了…..</p>\n<p>来到酒店顺利办了入住，进入房间的时候终于能松一口气了，顾不上放下行李，紧紧抱住了眼前这个人，情不自禁的亲吻她。简单的洗漱过后终于能躺下了，瞬间倦意袭来，抱着软软的又吉宝宝睡了过去，就像抱住了全世界，俩人相拥而眠，然后……就睡死过去啦:-D</p>\n<h3 id=\"宇宙第一可爱的又吉宝宝\"><a href=\"#宇宙第一可爱的又吉宝宝\" class=\"headerlink\" title=\"宇宙第一可爱的又吉宝宝\"></a>宇宙第一可爱的又吉宝宝</h3><p>醒来的第一眼就能看到心爱的人，看着熟睡的她，轻轻的吐着气呼吸，长长的眼睫毛一动一动的，像只乖巧的小猫咪，我情不自禁心上像开了一朵花，轻轻的亲了她糖果味的嘴唇仿佛拥有了全世界， 凑过去抱住了她又睡了过去……订了喜欢吃的海鲜外卖，总是忍不住看着她吃东西，心都要萌化了好吗？怎么有这么可爱的人！！</p>\n<h3 id=\"心灵手巧的又吉宝宝-插叙\"><a href=\"#心灵手巧的又吉宝宝-插叙\" class=\"headerlink\" title=\"心灵手巧的又吉宝宝(插叙)\"></a>心灵手巧的又吉宝宝(插叙)</h3><p>吉：“papapapapa~你看你看，这个日本的羊毛毡狗系列好萌啊啊啊啊啊！！！！”<br>pa：“买买买！喜欢就买！！！”<br>俩人一通找，发现正版一个竟然要几百块钱。囧，买个鬼啊买，根本买不起好吗？(话说不就一个手工羊毛毡制品吗，卖那么贵干嘛哦！)<br>吉：“可我真的喜欢嘛……诶不如我自己来做吧”？<br>pa：“呃……你行吗”？(手残星人表示不可思议)<br>然后我就华丽丽的忘了这一茬了(｀・ω・´)<br>没想到她竟然真的买了材料，花了一个下午加晚上给我扎了一个羊毛毡出来，还带到苏州来送给我(感动cry)<br>完全不输给正版的好吗！！！看这胖乎乎的身体，看这蠢萌的脸，看这傲娇的……屁股，哈哈哈哈啊哈哈<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-956dd5f4addca414.jpg\" alt=\"羊毛毡小狗狗\"></p>\n<p align=\"center\"><font color=\"9E9E9E\"><u>羊毛毡小狗狗</u></font></p>\n\n<p><br></p>\n<h3 id=\"小拖延的又吉宝宝\"><a href=\"#小拖延的又吉宝宝\" class=\"headerlink\" title=\"小拖延的又吉宝宝\"></a>小拖延的又吉宝宝</h3><p>三催四请让她去洗澡都不听话，我走过去一把熊抱起来，扔到床上：“立刻马上找你换洗的衣服”！然后一把抱起丢到浴室：“你！立刻洗澡！！ 别废话！！！”  她悻悻地关上门洗澡，一脸不甘愿的表情我就知道她肯定还想再玩会儿。没门！小样儿，还治不了你了！(╬￣皿￣)=</p>\n<h3 id=\"毫不客气的又吉宝宝\"><a href=\"#毫不客气的又吉宝宝\" class=\"headerlink\" title=\"毫不客气的又吉宝宝\"></a>毫不客气的又吉宝宝</h3><p>吉：“papa，我这脚好痛噢(ಥ_ಥ)你帮我揉一下~” 我还在想开口问为什么脚痛呢。啪！一只大白腿就架在了我肚皮上，脚趾都快碰到我嘴了。好气又好笑٩(๑❛ᴗ❛๑)۶ 揉揉揉，这三天尽给她揉脚了(๑¯∀¯๑)</p>\n<p><br></p>\n<p><br></p>\n<p>欢乐的时光总是特别短暂，转眼到了该分别的时候(;´༎ຶД༎ຶ`) 浑浑噩噩的回到了广州，满满的不舍得……不过呢，下一次的行程也安排好了，我又可以开始倒数啦~(≧≦)/~啦啦啦</p>\n<p><br><br><br></p>\n<p align=\"right\">by：又吉君的ruanpapa</p>","excerpt":"","more":"<blockquote>\n<p>倒计时45天…..似乎还是遥不可及的事情，日常挑逗我的又吉宝宝(づ￣3￣)づ╭❤～<br>倒计时30天……还一个月呐O__O “…该写代码写代码，该吃饭吃饭<br>倒计时14天……完全没办法压抑自己的激动了，每天和又吉宝宝憧憬着到了苏州要玩什么吃什么，各种叮嘱对方带这个带那个的，连到时候一起看《虫师》都决定好了<br>倒计时7天……反而冷静了下来，两个人都少了提及苏州旅游的话题，约定好这星期要一起认真学习认真工作，内心却为即将到来的见面而翻腾<br>倒计时1天……还写个毛的代码啊，一天都没写够10行代码，可惜又吉宝宝整整一天的课，我这满腔的兴奋没地方诉说/(ㄒoㄒ)/~~</p>\n</blockquote>\n<p>终于熬到了下班了！！！三步并作两步冲回宿舍背上我的小书包，奔着机场就去了。一路上，无视因为放假堵塞的地铁站，无视闷热的天气，无视自己的第一次坐飞机。苏州，我来啦！！！</p>\n<p><strong>行程一览：天河–&gt;白云机场–&gt;硕放机场–&gt;无锡火车站–&gt;苏州火车站</strong> </p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-3da74167361aa6cb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"超级欢脱\"></p>\n<p align=\"center\"><font color=\"9E9E9E\"><u>超级欢脱</u></font></p>\n\n<p><br></p>\n<p>无锡火车站外左等右等，终于等来了载着我朝思暮想的又吉宝宝的火车。踏上第4节车厢一眼就看到座位上探头探脑寻找着我的小又吉，赶快戴上帽子压低头附身跟着前面的人走向那个朝思暮想了几个月的那个家伙。一屁股坐下又吉宝宝旁边，这小傻瓜竟然第一句话是问我要不要吃她带的枣糕(喵喵喵？？？汪汪汪？？？你就这开场白吗？？？) 这货竟然敢对我那么冷淡，一把握住她的手，不由分说牵的死死的：这才像话嘛，劳资山长水远的飞奔而来，可不得好好牵牵小手啊吼！<br>但是，还没坐几分钟，位置的主人就来了，只好起身站在了走道上，她呢，身子一侧又睡了！！！我这个暴脾气啊：你就这么冷淡吗，看不到我有位置都不回去坐，站在这儿不就是为了看你吗？你还这么心大？待会儿下车你就知道错了！口亨！！！</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-857da72b6b770c92.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"气死我啦\"></p>\n<p align=\"center\"><font color=\"9E9E9E\"><u>气死我啦</u></font></p>\n\n<p><br></p>\n<p>28分钟的火车我就跟站了28小时一样，明明两步外坐着自己心爱的女人(虽然睡得🐖一样)，自己却没办法触碰到她。/(ㄒoㄒ)/~总算捱到了下车，发现我出省连网都没得上了，于是我全程像个考拉一样贴在了宝宝身上，又吉宝宝找肯德基准备待到天亮，而我的关注点就全在牵着又吉宝宝的手上~摸摸手~搭搭肩膀~掐掐脸~管她去哪儿呢，爱去哪去哪！</p>\n<p>清晨的苏州真的是很舒适宜居，爱人在旁，清风拂面，绿树相伴，天空蓝蓝的，空气凉凉的，好奇的盯着这江南每一处建筑，每一个过去的人，通宵没睡的倦意也一扫而光，贪婪的享受这闲适的一切。步行来到早已计划好的平江路，果真名不虚传，俩人都赞不绝口，背阴像隔开了旭日初升的热气，两旁的店面都满满的江南水乡风格。俩人在沿河的石阶上上坐了好久好久，完全没有第一次见的陌生感，聊聊平江路，聊聊待会儿的行程，聊聊喝茶，聊聊坐飞机坐车的事情，一点都不想走了。接着去了闻名遐迩的拙政园，真的是人山人海啊，游完一遍俩人一致认为这里言过其实了…..</p>\n<p>来到酒店顺利办了入住，进入房间的时候终于能松一口气了，顾不上放下行李，紧紧抱住了眼前这个人，情不自禁的亲吻她。简单的洗漱过后终于能躺下了，瞬间倦意袭来，抱着软软的又吉宝宝睡了过去，就像抱住了全世界，俩人相拥而眠，然后……就睡死过去啦:-D</p>\n<h3 id=\"宇宙第一可爱的又吉宝宝\"><a href=\"#宇宙第一可爱的又吉宝宝\" class=\"headerlink\" title=\"宇宙第一可爱的又吉宝宝\"></a>宇宙第一可爱的又吉宝宝</h3><p>醒来的第一眼就能看到心爱的人，看着熟睡的她，轻轻的吐着气呼吸，长长的眼睫毛一动一动的，像只乖巧的小猫咪，我情不自禁心上像开了一朵花，轻轻的亲了她糖果味的嘴唇仿佛拥有了全世界， 凑过去抱住了她又睡了过去……订了喜欢吃的海鲜外卖，总是忍不住看着她吃东西，心都要萌化了好吗？怎么有这么可爱的人！！</p>\n<h3 id=\"心灵手巧的又吉宝宝-插叙\"><a href=\"#心灵手巧的又吉宝宝-插叙\" class=\"headerlink\" title=\"心灵手巧的又吉宝宝(插叙)\"></a>心灵手巧的又吉宝宝(插叙)</h3><p>吉：“papapapapa~你看你看，这个日本的羊毛毡狗系列好萌啊啊啊啊啊！！！！”<br>pa：“买买买！喜欢就买！！！”<br>俩人一通找，发现正版一个竟然要几百块钱。囧，买个鬼啊买，根本买不起好吗？(话说不就一个手工羊毛毡制品吗，卖那么贵干嘛哦！)<br>吉：“可我真的喜欢嘛……诶不如我自己来做吧”？<br>pa：“呃……你行吗”？(手残星人表示不可思议)<br>然后我就华丽丽的忘了这一茬了(｀・ω・´)<br>没想到她竟然真的买了材料，花了一个下午加晚上给我扎了一个羊毛毡出来，还带到苏州来送给我(感动cry)<br>完全不输给正版的好吗！！！看这胖乎乎的身体，看这蠢萌的脸，看这傲娇的……屁股，哈哈哈哈啊哈哈<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-956dd5f4addca414.jpg\" alt=\"羊毛毡小狗狗\"></p>\n<p align=\"center\"><font color=\"9E9E9E\"><u>羊毛毡小狗狗</u></font></p>\n\n<p><br></p>\n<h3 id=\"小拖延的又吉宝宝\"><a href=\"#小拖延的又吉宝宝\" class=\"headerlink\" title=\"小拖延的又吉宝宝\"></a>小拖延的又吉宝宝</h3><p>三催四请让她去洗澡都不听话，我走过去一把熊抱起来，扔到床上：“立刻马上找你换洗的衣服”！然后一把抱起丢到浴室：“你！立刻洗澡！！ 别废话！！！”  她悻悻地关上门洗澡，一脸不甘愿的表情我就知道她肯定还想再玩会儿。没门！小样儿，还治不了你了！(╬￣皿￣)=</p>\n<h3 id=\"毫不客气的又吉宝宝\"><a href=\"#毫不客气的又吉宝宝\" class=\"headerlink\" title=\"毫不客气的又吉宝宝\"></a>毫不客气的又吉宝宝</h3><p>吉：“papa，我这脚好痛噢(ಥ_ಥ)你帮我揉一下~” 我还在想开口问为什么脚痛呢。啪！一只大白腿就架在了我肚皮上，脚趾都快碰到我嘴了。好气又好笑٩(๑❛ᴗ❛๑)۶ 揉揉揉，这三天尽给她揉脚了(๑¯∀¯๑)</p>\n<p><br></p>\n<p><br></p>\n<p>欢乐的时光总是特别短暂，转眼到了该分别的时候(;´༎ຶД༎ຶ`) 浑浑噩噩的回到了广州，满满的不舍得……不过呢，下一次的行程也安排好了，我又可以开始倒数啦~(≧≦)/~啦啦啦</p>\n<p><br><br><br></p>\n<p align=\"right\">by：又吉君的ruanpapa</p>"},{"title":"Source Editor Extension — Xcode 格式化 Import 的插件","date":"2018-02-01T09:06:35.000Z","_content":"\n## 背景\nXcode 秉承了 Apple 封闭的传统，提供的可自定义的选项比起其他 IDE 来说是比较少的，不过在 Xcode 7 之前（包含 Xcode 7）我们还是可以通过插件实现 Xcode 的自定义，甚至还出现了像  [Alcatraz](https://github.com/alcatraz/Alcatraz) 的专门的插件管理工具，开源社区中也有诸如 [VVDocumenter-Xcode](https://link.jianshu.com/?t=https://github.com/onevcat/VVDocumenter-Xcode)、[CocoaPods](https://github.com/CocoaPods/CocoaPods) 等知名的插件，不过这些便利随着 Xcode 8 的发布成为了过去式。\n出于安全性考虑（比如说 Xcode ghost 事件），Apple 从 Xcode 8 开始不再支持第三方的插件。Apple 方面提供了基于 App Extension 的解决方案 -- Xcode Source Editor Extension，这是一个相当简单的方案，能且仅能完成有限的文本编辑辅助，很大部分之前第三方插件能完成的任务都没办法实现了。聊胜于无吧 😑\n（本文会介绍 Source Editor Extension 的开发以及分发相关的知识，本文对应的 Demo 在：https://github.com/VernonVan/PPImportArrangerExtension）\n\n\n\n## 创建插件\n\n1. 创建一个 Cocoa App：Source Editor Extension 不能独立存在，必须依附于 Cocoa App。\n  ![Cocoa App](http://upload-images.jianshu.io/upload_images/698554-a00fabcbca0f7353.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n  ​\n\n2. File -> New -> Target -> Xcode Source Editor Extension 添加一个 Target，并激活这个 Target。\n  ![Xcode Source Editor Extension](http://upload-images.jianshu.io/upload_images/698554-0c32ca262d291557.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  ![激活 target](http://upload-images.jianshu.io/upload_images/698554-b6a7d64355a372d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这样就创建好了一个可运行的 Source Editor Extension，相当的简单。🧐\n\n\n\n## 关键概念\n\n![文件结构](http://upload-images.jianshu.io/upload_images/698554-0e6f169643d8a20f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- SourceEditorExtension 类：遵循 XCSourceEditorExtension 协议的类，XCSourceEditorExtension 协议的头文件如下：\n\n```Objective-C\n@protocol XCSourceEditorExtension <NSObject>\n\n@optional\n\n- (void)extensionDidFinishLaunching;\n\n@property (readonly, copy) NSArray <NSDictionary <XCSourceEditorCommandDefinitionKey, id> *> *commandDefinitions;\n\n@end\n```\nXCSourceEditorExtension 协议只有一个方法和一个属性，extensionDidFinishLaunching 方法是用来在插件加载好后是对插件进行一些准备工作的，根据 [WWDC](https://developer.apple.com/videos/play/wwdc2016/414/) 的说法，各个插件与 Xcode 本身的初始化过程是在不同进程上进行的，同样地，插件的崩溃并不会引起 Xcode 的崩溃。commandDefinitions 属性则可以动态返回插件的菜单项。\n\nSourceEditorCommand 类：遵循 XCSourceEditorCommand 协议的类，实现插件功能的核心类，对应到插件的菜单项，可以一个菜单项对应到一个 Command 类，也可以多个菜单项对应到一个 Command 类，XCSourceEditorCommand 协议头文件定义如下：\n```Objective-C\n@protocol XCSourceEditorCommand <NSObject>\n\n@required\n\n- (void)performCommandWithInvocation:(XCSourceEditorCommandInvocation *)invocation completionHandler:(void (^)(NSError * _Nullable nilOrError))completionHandler;\n\n@end\n```\nXCSourceEditorCommandInvocation 类型的参数 invocation 主要是点击的菜单项的标识、当前文本信息（文本字符串数组、选中区间等）以及点击取消按钮的回调事件，completionHandler 参数则是用来通知 Xcode 本插件已经完成了自己的操作，需要保证一定要调用 completionHandler！否则会出现下图所示的提示，然后菜单项就会变灰不能再点击：\n![插件 busy](http://upload-images.jianshu.io/upload_images/698554-f57b5a31a603f5f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![菜单项变灰](http://upload-images.jianshu.io/upload_images/698554-8e6d0b4a636883f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- Info.plist：Info.plist 文件用于静态配置插件对应的菜单项，如下图所示，XCSourceEditorExtensionPrincipalClass 对应到上文说的 XCSourceEditorExtension 类，XCSourceEditorCommandDefinitions 指定菜单项，XCSourceEditorCommandClassName 对应到上文说的 SourceEditorCommand 类，XCSourceEditorCommandIdentifier 是每个具体菜单项的标识，XCSourceEditorCommandName 是菜单项的描述。\n\n![Info.plist](http://upload-images.jianshu.io/upload_images/698554-54682412d2c5b04a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 保证 TARGETS 组下的两个 Target 用的同一个签名。\n\n\n## 实现步骤\n\n本 Demo 要实现的功能就是按照字母顺序重新排列当前文件的所有 Import，强迫症们一定知道我在说什么🤣，先来看一下效果：\n![效果图](http://upload-images.jianshu.io/upload_images/698554-58e34917de432fbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![演示效果](http://upload-images.jianshu.io/upload_images/698554-9638491f62073029.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n可以点击 Editor -> ImportArranger -> Arrange Imports 重新排列所有的 Imports，甚至还可以为其设置快键键。\n\n实现步骤反而没有什么可说的，主要是操作 invocation.buffer.lines 和 invocation.buffer.selections，分别对应的是当前文件的所有行和当前文件的选择区域，都是可变类型的数组，做完自定义的操作后操作数组即可更新当前文件。注意：**不管是哪条执行路径，一定要保证调用到 completionHandler**。其他需要留意的地方都在代码中的注释中给出：\n```Objective-C\n- (void)performCommandWithInvocation:(XCSourceEditorCommandInvocation *)invocation completionHandler:(void (^)(NSError *_Nullable nilOrError))completionHandler\n{\n    NSMutableArray<NSString *> *lines = invocation.buffer.lines;\n    if (!lines || !lines.count) {\n        completionHandler(nil);\n        return;\n    }\n\n    NSMutableArray<NSString *> *importLines = [[NSMutableArray alloc] init];\n    NSInteger firstLine = -1;\n    for (NSUInteger index = 0, max = lines.count; index < max; index++) {\n        NSString *line = lines[index];\n        NSString *pureLine = [line stringByReplacingOccurrencesOfString:@\" \" withString:@\"\"];       // 去掉多余的空格，以防被空格干扰没检测到 #import\n        // 支持 Objective-C、Swift、C 语言的导入方式\n        if ([pureLine hasPrefix:@\"#import\"] || [pureLine hasPrefix:@\"import\"] || [pureLine hasPrefix:@\"@class\"]\n            || [pureLine hasPrefix:@\"@import\"] || [pureLine hasPrefix:@\"#include\"]) {     \n            [importLines addObject:line];\n            if (firstLine == -1) {\n                firstLine = index;      // 记住第一行 #import 所在的行数，用来等下重新插入的位置\n            }\n        }\n    }\n\n    if (!importLines.count) {\n        completionHandler(nil);\n        return;\n    }\n\n    [invocation.buffer.lines removeObjectsInArray:importLines];\n\n    NSArray *noRepeatArray = [[NSSet setWithArray:importLines] allObjects];         // 去掉重复的 #import\n    NSMutableArray<NSString *> *sortedImports = [[NSMutableArray alloc] initWithArray:[noRepeatArray sortedArrayUsingSelector:@selector(caseInsensitiveCompare:)]];\n\n    // 引用系统文件在前，用户自定义的文件在后\n    NSMutableArray *systemImports = [[NSMutableArray alloc] init];\n    for (NSString *line in sortedImports) {\n        if ([line containsString:@\"<\"]) {\n            [systemImports addObject:line];\n        }\n    }\n    if (systemImports.count) {\n        [sortedImports removeObjectsInArray:systemImports];\n        [sortedImports insertObjects:systemImports atIndexes:[NSIndexSet indexSetWithIndexesInRange:NSMakeRange(0, systemImports.count)]];\n    }\n\n    if (firstLine >= 0 && firstLine < invocation.buffer.lines.count) {\n        // 重新插入排好序的 #import 行\n        [invocation.buffer.lines insertObjects:sortedImports atIndexes:[NSIndexSet indexSetWithIndexesInRange:NSMakeRange(firstLine, sortedImports.count)]];\n        // 选中所有 #import 行\n        [invocation.buffer.selections addObject:[[XCSourceTextRange alloc] initWithStart:XCSourceTextPositionMake(firstLine, 0) end:XCSourceTextPositionMake(firstLine + sortedImports.count, sortedImports.lastObject.length)]];\n    }\n\n    completionHandler(nil);\n}\n```\n\n选择这个插件作为当前 Scheme，选择 Xcode 运行，然后就会弹出一个黑色的 Xcode 供你调试了。\n![image.png](http://upload-images.jianshu.io/upload_images/698554-8fb83256d9e38800.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![调试插件](http://upload-images.jianshu.io/upload_images/698554-7410ea37b33422fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n## 分发\n插件开发测试完成之后，最重要的当然是将插件分发出去，供他人使用。Apple 在  [WWDC](https://developer.apple.com/videos/play/wwdc2016/414/) 说到 Xcode Source Editor Extension 是可以上架 Mac App Store 的，不过受限于 Source Editor Extension 功能实在太少，目前也没有在 Mac App Store 上看到很火的插件。更多是直接把 .app 文件上传到 Github 上供人下载（这里有人整理了一些不错的插件：https://github.com/theswiftdev/awesome-xcode-extensions），具体步骤如下：\n\n\n\n#### 打包\n\n测试完成后，找到 Products 下面的 .app 文件，注意需要保证上文中说的两个签名是一致的。然后就可以把这个 .app 上传到个人网站或者 Github 上供人下载使用了。\n![.app 文件](http://upload-images.jianshu.io/upload_images/698554-5202f8ddea721d38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n#### 安装\n\n当我们下载好了一个 .app 格式的插件之后，直接双击这个 .app 文件，然后在 系统偏好设置-> 扩展 -> Xcode Source Editor Extension 勾选该插件，最后重启 Xcode 就可以在 Editor 菜单中找到该插件了。\n![勾选插件](http://upload-images.jianshu.io/upload_images/698554-b35bafce22cccf86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n还可以在 Xcode 中为插件的菜单项设置快捷键。\n![设置快键键](http://upload-images.jianshu.io/upload_images/698554-d5f2a3622205f490.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n## 结语\n\n至少现有的 Xcode Source Editor Extension 还是比较受限的，接口少的可怜，可想象的空间不是很多，大部分之前第三方插件能做的事情都没办法完成了🤷‍♀️。还是默默希望 Apple 能以更加开放的姿态，提供更多的接口给开发者，Xcode 没办法满足所有人的喜好，起码，能让喜欢折腾的人把它变得更好 :-D","source":"_posts/格式化Import.md","raw":"---\ntitle: Source Editor Extension — Xcode 格式化 Import 的插件\ndate: 2018-02-01 17:06:35\ntags: \n- iOS\n- Xcode\ncategories:\n- ruanpapa--技术贴\n---\n\n## 背景\nXcode 秉承了 Apple 封闭的传统，提供的可自定义的选项比起其他 IDE 来说是比较少的，不过在 Xcode 7 之前（包含 Xcode 7）我们还是可以通过插件实现 Xcode 的自定义，甚至还出现了像  [Alcatraz](https://github.com/alcatraz/Alcatraz) 的专门的插件管理工具，开源社区中也有诸如 [VVDocumenter-Xcode](https://link.jianshu.com/?t=https://github.com/onevcat/VVDocumenter-Xcode)、[CocoaPods](https://github.com/CocoaPods/CocoaPods) 等知名的插件，不过这些便利随着 Xcode 8 的发布成为了过去式。\n出于安全性考虑（比如说 Xcode ghost 事件），Apple 从 Xcode 8 开始不再支持第三方的插件。Apple 方面提供了基于 App Extension 的解决方案 -- Xcode Source Editor Extension，这是一个相当简单的方案，能且仅能完成有限的文本编辑辅助，很大部分之前第三方插件能完成的任务都没办法实现了。聊胜于无吧 😑\n（本文会介绍 Source Editor Extension 的开发以及分发相关的知识，本文对应的 Demo 在：https://github.com/VernonVan/PPImportArrangerExtension）\n\n\n\n## 创建插件\n\n1. 创建一个 Cocoa App：Source Editor Extension 不能独立存在，必须依附于 Cocoa App。\n  ![Cocoa App](http://upload-images.jianshu.io/upload_images/698554-a00fabcbca0f7353.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n  ​\n\n2. File -> New -> Target -> Xcode Source Editor Extension 添加一个 Target，并激活这个 Target。\n  ![Xcode Source Editor Extension](http://upload-images.jianshu.io/upload_images/698554-0c32ca262d291557.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  ![激活 target](http://upload-images.jianshu.io/upload_images/698554-b6a7d64355a372d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这样就创建好了一个可运行的 Source Editor Extension，相当的简单。🧐\n\n\n\n## 关键概念\n\n![文件结构](http://upload-images.jianshu.io/upload_images/698554-0e6f169643d8a20f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- SourceEditorExtension 类：遵循 XCSourceEditorExtension 协议的类，XCSourceEditorExtension 协议的头文件如下：\n\n```Objective-C\n@protocol XCSourceEditorExtension <NSObject>\n\n@optional\n\n- (void)extensionDidFinishLaunching;\n\n@property (readonly, copy) NSArray <NSDictionary <XCSourceEditorCommandDefinitionKey, id> *> *commandDefinitions;\n\n@end\n```\nXCSourceEditorExtension 协议只有一个方法和一个属性，extensionDidFinishLaunching 方法是用来在插件加载好后是对插件进行一些准备工作的，根据 [WWDC](https://developer.apple.com/videos/play/wwdc2016/414/) 的说法，各个插件与 Xcode 本身的初始化过程是在不同进程上进行的，同样地，插件的崩溃并不会引起 Xcode 的崩溃。commandDefinitions 属性则可以动态返回插件的菜单项。\n\nSourceEditorCommand 类：遵循 XCSourceEditorCommand 协议的类，实现插件功能的核心类，对应到插件的菜单项，可以一个菜单项对应到一个 Command 类，也可以多个菜单项对应到一个 Command 类，XCSourceEditorCommand 协议头文件定义如下：\n```Objective-C\n@protocol XCSourceEditorCommand <NSObject>\n\n@required\n\n- (void)performCommandWithInvocation:(XCSourceEditorCommandInvocation *)invocation completionHandler:(void (^)(NSError * _Nullable nilOrError))completionHandler;\n\n@end\n```\nXCSourceEditorCommandInvocation 类型的参数 invocation 主要是点击的菜单项的标识、当前文本信息（文本字符串数组、选中区间等）以及点击取消按钮的回调事件，completionHandler 参数则是用来通知 Xcode 本插件已经完成了自己的操作，需要保证一定要调用 completionHandler！否则会出现下图所示的提示，然后菜单项就会变灰不能再点击：\n![插件 busy](http://upload-images.jianshu.io/upload_images/698554-f57b5a31a603f5f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![菜单项变灰](http://upload-images.jianshu.io/upload_images/698554-8e6d0b4a636883f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- Info.plist：Info.plist 文件用于静态配置插件对应的菜单项，如下图所示，XCSourceEditorExtensionPrincipalClass 对应到上文说的 XCSourceEditorExtension 类，XCSourceEditorCommandDefinitions 指定菜单项，XCSourceEditorCommandClassName 对应到上文说的 SourceEditorCommand 类，XCSourceEditorCommandIdentifier 是每个具体菜单项的标识，XCSourceEditorCommandName 是菜单项的描述。\n\n![Info.plist](http://upload-images.jianshu.io/upload_images/698554-54682412d2c5b04a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 保证 TARGETS 组下的两个 Target 用的同一个签名。\n\n\n## 实现步骤\n\n本 Demo 要实现的功能就是按照字母顺序重新排列当前文件的所有 Import，强迫症们一定知道我在说什么🤣，先来看一下效果：\n![效果图](http://upload-images.jianshu.io/upload_images/698554-58e34917de432fbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![演示效果](http://upload-images.jianshu.io/upload_images/698554-9638491f62073029.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n可以点击 Editor -> ImportArranger -> Arrange Imports 重新排列所有的 Imports，甚至还可以为其设置快键键。\n\n实现步骤反而没有什么可说的，主要是操作 invocation.buffer.lines 和 invocation.buffer.selections，分别对应的是当前文件的所有行和当前文件的选择区域，都是可变类型的数组，做完自定义的操作后操作数组即可更新当前文件。注意：**不管是哪条执行路径，一定要保证调用到 completionHandler**。其他需要留意的地方都在代码中的注释中给出：\n```Objective-C\n- (void)performCommandWithInvocation:(XCSourceEditorCommandInvocation *)invocation completionHandler:(void (^)(NSError *_Nullable nilOrError))completionHandler\n{\n    NSMutableArray<NSString *> *lines = invocation.buffer.lines;\n    if (!lines || !lines.count) {\n        completionHandler(nil);\n        return;\n    }\n\n    NSMutableArray<NSString *> *importLines = [[NSMutableArray alloc] init];\n    NSInteger firstLine = -1;\n    for (NSUInteger index = 0, max = lines.count; index < max; index++) {\n        NSString *line = lines[index];\n        NSString *pureLine = [line stringByReplacingOccurrencesOfString:@\" \" withString:@\"\"];       // 去掉多余的空格，以防被空格干扰没检测到 #import\n        // 支持 Objective-C、Swift、C 语言的导入方式\n        if ([pureLine hasPrefix:@\"#import\"] || [pureLine hasPrefix:@\"import\"] || [pureLine hasPrefix:@\"@class\"]\n            || [pureLine hasPrefix:@\"@import\"] || [pureLine hasPrefix:@\"#include\"]) {     \n            [importLines addObject:line];\n            if (firstLine == -1) {\n                firstLine = index;      // 记住第一行 #import 所在的行数，用来等下重新插入的位置\n            }\n        }\n    }\n\n    if (!importLines.count) {\n        completionHandler(nil);\n        return;\n    }\n\n    [invocation.buffer.lines removeObjectsInArray:importLines];\n\n    NSArray *noRepeatArray = [[NSSet setWithArray:importLines] allObjects];         // 去掉重复的 #import\n    NSMutableArray<NSString *> *sortedImports = [[NSMutableArray alloc] initWithArray:[noRepeatArray sortedArrayUsingSelector:@selector(caseInsensitiveCompare:)]];\n\n    // 引用系统文件在前，用户自定义的文件在后\n    NSMutableArray *systemImports = [[NSMutableArray alloc] init];\n    for (NSString *line in sortedImports) {\n        if ([line containsString:@\"<\"]) {\n            [systemImports addObject:line];\n        }\n    }\n    if (systemImports.count) {\n        [sortedImports removeObjectsInArray:systemImports];\n        [sortedImports insertObjects:systemImports atIndexes:[NSIndexSet indexSetWithIndexesInRange:NSMakeRange(0, systemImports.count)]];\n    }\n\n    if (firstLine >= 0 && firstLine < invocation.buffer.lines.count) {\n        // 重新插入排好序的 #import 行\n        [invocation.buffer.lines insertObjects:sortedImports atIndexes:[NSIndexSet indexSetWithIndexesInRange:NSMakeRange(firstLine, sortedImports.count)]];\n        // 选中所有 #import 行\n        [invocation.buffer.selections addObject:[[XCSourceTextRange alloc] initWithStart:XCSourceTextPositionMake(firstLine, 0) end:XCSourceTextPositionMake(firstLine + sortedImports.count, sortedImports.lastObject.length)]];\n    }\n\n    completionHandler(nil);\n}\n```\n\n选择这个插件作为当前 Scheme，选择 Xcode 运行，然后就会弹出一个黑色的 Xcode 供你调试了。\n![image.png](http://upload-images.jianshu.io/upload_images/698554-8fb83256d9e38800.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![调试插件](http://upload-images.jianshu.io/upload_images/698554-7410ea37b33422fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n## 分发\n插件开发测试完成之后，最重要的当然是将插件分发出去，供他人使用。Apple 在  [WWDC](https://developer.apple.com/videos/play/wwdc2016/414/) 说到 Xcode Source Editor Extension 是可以上架 Mac App Store 的，不过受限于 Source Editor Extension 功能实在太少，目前也没有在 Mac App Store 上看到很火的插件。更多是直接把 .app 文件上传到 Github 上供人下载（这里有人整理了一些不错的插件：https://github.com/theswiftdev/awesome-xcode-extensions），具体步骤如下：\n\n\n\n#### 打包\n\n测试完成后，找到 Products 下面的 .app 文件，注意需要保证上文中说的两个签名是一致的。然后就可以把这个 .app 上传到个人网站或者 Github 上供人下载使用了。\n![.app 文件](http://upload-images.jianshu.io/upload_images/698554-5202f8ddea721d38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n#### 安装\n\n当我们下载好了一个 .app 格式的插件之后，直接双击这个 .app 文件，然后在 系统偏好设置-> 扩展 -> Xcode Source Editor Extension 勾选该插件，最后重启 Xcode 就可以在 Editor 菜单中找到该插件了。\n![勾选插件](http://upload-images.jianshu.io/upload_images/698554-b35bafce22cccf86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n还可以在 Xcode 中为插件的菜单项设置快捷键。\n![设置快键键](http://upload-images.jianshu.io/upload_images/698554-d5f2a3622205f490.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n## 结语\n\n至少现有的 Xcode Source Editor Extension 还是比较受限的，接口少的可怜，可想象的空间不是很多，大部分之前第三方插件能做的事情都没办法完成了🤷‍♀️。还是默默希望 Apple 能以更加开放的姿态，提供更多的接口给开发者，Xcode 没办法满足所有人的喜好，起码，能让喜欢折腾的人把它变得更好 :-D","slug":"格式化Import","published":1,"updated":"2018-02-06T06:42:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg4j8w2o001xvfwxfowpog8l","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>Xcode 秉承了 Apple 封闭的传统，提供的可自定义的选项比起其他 IDE 来说是比较少的，不过在 Xcode 7 之前（包含 Xcode 7）我们还是可以通过插件实现 Xcode 的自定义，甚至还出现了像  <a href=\"https://github.com/alcatraz/Alcatraz\" target=\"_blank\" rel=\"external\">Alcatraz</a> 的专门的插件管理工具，开源社区中也有诸如 <a href=\"https://link.jianshu.com/?t=https://github.com/onevcat/VVDocumenter-Xcode\" target=\"_blank\" rel=\"external\">VVDocumenter-Xcode</a>、<a href=\"https://github.com/CocoaPods/CocoaPods\" target=\"_blank\" rel=\"external\">CocoaPods</a> 等知名的插件，不过这些便利随着 Xcode 8 的发布成为了过去式。<br>出于安全性考虑（比如说 Xcode ghost 事件），Apple 从 Xcode 8 开始不再支持第三方的插件。Apple 方面提供了基于 App Extension 的解决方案 – Xcode Source Editor Extension，这是一个相当简单的方案，能且仅能完成有限的文本编辑辅助，很大部分之前第三方插件能完成的任务都没办法实现了。聊胜于无吧 😑<br>（本文会介绍 Source Editor Extension 的开发以及分发相关的知识，本文对应的 Demo 在：<a href=\"https://github.com/VernonVan/PPImportArrangerExtension）\" target=\"_blank\" rel=\"external\">https://github.com/VernonVan/PPImportArrangerExtension）</a></p>\n<h2 id=\"创建插件\"><a href=\"#创建插件\" class=\"headerlink\" title=\"创建插件\"></a>创建插件</h2><ol>\n<li><p>创建一个 Cocoa App：Source Editor Extension 不能独立存在，必须依附于 Cocoa App。<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-a00fabcbca0f7353.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Cocoa App\"></p>\n<p>​</p>\n</li>\n<li><p>File -&gt; New -&gt; Target -&gt; Xcode Source Editor Extension 添加一个 Target，并激活这个 Target。<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-0c32ca262d291557.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Xcode Source Editor Extension\"><br><img src=\"http://upload-images.jianshu.io/upload_images/698554-b6a7d64355a372d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"激活 target\"></p>\n</li>\n</ol>\n<p>这样就创建好了一个可运行的 Source Editor Extension，相当的简单。🧐</p>\n<h2 id=\"关键概念\"><a href=\"#关键概念\" class=\"headerlink\" title=\"关键概念\"></a>关键概念</h2><p><img src=\"http://upload-images.jianshu.io/upload_images/698554-0e6f169643d8a20f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"文件结构\"></p>\n<ul>\n<li>SourceEditorExtension 类：遵循 XCSourceEditorExtension 协议的类，XCSourceEditorExtension 协议的头文件如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">@protocol XCSourceEditorExtension &lt;NSObject&gt;</div><div class=\"line\"></div><div class=\"line\">@optional</div><div class=\"line\"></div><div class=\"line\">- (void)extensionDidFinishLaunching;</div><div class=\"line\"></div><div class=\"line\">@property (readonly, copy) NSArray &lt;NSDictionary &lt;XCSourceEditorCommandDefinitionKey, id&gt; *&gt; *commandDefinitions;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>XCSourceEditorExtension 协议只有一个方法和一个属性，extensionDidFinishLaunching 方法是用来在插件加载好后是对插件进行一些准备工作的，根据 <a href=\"https://developer.apple.com/videos/play/wwdc2016/414/\" target=\"_blank\" rel=\"external\">WWDC</a> 的说法，各个插件与 Xcode 本身的初始化过程是在不同进程上进行的，同样地，插件的崩溃并不会引起 Xcode 的崩溃。commandDefinitions 属性则可以动态返回插件的菜单项。</p>\n<p>SourceEditorCommand 类：遵循 XCSourceEditorCommand 协议的类，实现插件功能的核心类，对应到插件的菜单项，可以一个菜单项对应到一个 Command 类，也可以多个菜单项对应到一个 Command 类，XCSourceEditorCommand 协议头文件定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">@protocol XCSourceEditorCommand &lt;NSObject&gt;</div><div class=\"line\"></div><div class=\"line\">@required</div><div class=\"line\"></div><div class=\"line\">- (void)performCommandWithInvocation:(XCSourceEditorCommandInvocation *)invocation completionHandler:(void (^)(NSError * _Nullable nilOrError))completionHandler;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>XCSourceEditorCommandInvocation 类型的参数 invocation 主要是点击的菜单项的标识、当前文本信息（文本字符串数组、选中区间等）以及点击取消按钮的回调事件，completionHandler 参数则是用来通知 Xcode 本插件已经完成了自己的操作，需要保证一定要调用 completionHandler！否则会出现下图所示的提示，然后菜单项就会变灰不能再点击：<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-f57b5a31a603f5f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"插件 busy\"><br><img src=\"http://upload-images.jianshu.io/upload_images/698554-8e6d0b4a636883f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"菜单项变灰\"></p>\n<ul>\n<li>Info.plist：Info.plist 文件用于静态配置插件对应的菜单项，如下图所示，XCSourceEditorExtensionPrincipalClass 对应到上文说的 XCSourceEditorExtension 类，XCSourceEditorCommandDefinitions 指定菜单项，XCSourceEditorCommandClassName 对应到上文说的 SourceEditorCommand 类，XCSourceEditorCommandIdentifier 是每个具体菜单项的标识，XCSourceEditorCommandName 是菜单项的描述。</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-54682412d2c5b04a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Info.plist\"></p>\n<ul>\n<li>保证 TARGETS 组下的两个 Target 用的同一个签名。</li>\n</ul>\n<h2 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h2><p>本 Demo 要实现的功能就是按照字母顺序重新排列当前文件的所有 Import，强迫症们一定知道我在说什么🤣，先来看一下效果：<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-58e34917de432fbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"效果图\"><br><img src=\"http://upload-images.jianshu.io/upload_images/698554-9638491f62073029.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"演示效果\"><br>可以点击 Editor -&gt; ImportArranger -&gt; Arrange Imports 重新排列所有的 Imports，甚至还可以为其设置快键键。</p>\n<p>实现步骤反而没有什么可说的，主要是操作 invocation.buffer.lines 和 invocation.buffer.selections，分别对应的是当前文件的所有行和当前文件的选择区域，都是可变类型的数组，做完自定义的操作后操作数组即可更新当前文件。注意：<strong>不管是哪条执行路径，一定要保证调用到 completionHandler</strong>。其他需要留意的地方都在代码中的注释中给出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)performCommandWithInvocation:(XCSourceEditorCommandInvocation *)invocation completionHandler:(void (^)(NSError *_Nullable nilOrError))completionHandler</div><div class=\"line\">&#123;</div><div class=\"line\">    NSMutableArray&lt;NSString *&gt; *lines = invocation.buffer.lines;</div><div class=\"line\">    if (!lines || !lines.count) &#123;</div><div class=\"line\">        completionHandler(nil);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    NSMutableArray&lt;NSString *&gt; *importLines = [[NSMutableArray alloc] init];</div><div class=\"line\">    NSInteger firstLine = -1;</div><div class=\"line\">    for (NSUInteger index = 0, max = lines.count; index &lt; max; index++) &#123;</div><div class=\"line\">        NSString *line = lines[index];</div><div class=\"line\">        NSString *pureLine = [line stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;];       // 去掉多余的空格，以防被空格干扰没检测到 #import</div><div class=\"line\">        // 支持 Objective-C、Swift、C 语言的导入方式</div><div class=\"line\">        if ([pureLine hasPrefix:@&quot;#import&quot;] || [pureLine hasPrefix:@&quot;import&quot;] || [pureLine hasPrefix:@&quot;@class&quot;]</div><div class=\"line\">            || [pureLine hasPrefix:@&quot;@import&quot;] || [pureLine hasPrefix:@&quot;#include&quot;]) &#123;     </div><div class=\"line\">            [importLines addObject:line];</div><div class=\"line\">            if (firstLine == -1) &#123;</div><div class=\"line\">                firstLine = index;      // 记住第一行 #import 所在的行数，用来等下重新插入的位置</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (!importLines.count) &#123;</div><div class=\"line\">        completionHandler(nil);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    [invocation.buffer.lines removeObjectsInArray:importLines];</div><div class=\"line\"></div><div class=\"line\">    NSArray *noRepeatArray = [[NSSet setWithArray:importLines] allObjects];         // 去掉重复的 #import</div><div class=\"line\">    NSMutableArray&lt;NSString *&gt; *sortedImports = [[NSMutableArray alloc] initWithArray:[noRepeatArray sortedArrayUsingSelector:@selector(caseInsensitiveCompare:)]];</div><div class=\"line\"></div><div class=\"line\">    // 引用系统文件在前，用户自定义的文件在后</div><div class=\"line\">    NSMutableArray *systemImports = [[NSMutableArray alloc] init];</div><div class=\"line\">    for (NSString *line in sortedImports) &#123;</div><div class=\"line\">        if ([line containsString:@&quot;&lt;&quot;]) &#123;</div><div class=\"line\">            [systemImports addObject:line];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (systemImports.count) &#123;</div><div class=\"line\">        [sortedImports removeObjectsInArray:systemImports];</div><div class=\"line\">        [sortedImports insertObjects:systemImports atIndexes:[NSIndexSet indexSetWithIndexesInRange:NSMakeRange(0, systemImports.count)]];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (firstLine &gt;= 0 &amp;&amp; firstLine &lt; invocation.buffer.lines.count) &#123;</div><div class=\"line\">        // 重新插入排好序的 #import 行</div><div class=\"line\">        [invocation.buffer.lines insertObjects:sortedImports atIndexes:[NSIndexSet indexSetWithIndexesInRange:NSMakeRange(firstLine, sortedImports.count)]];</div><div class=\"line\">        // 选中所有 #import 行</div><div class=\"line\">        [invocation.buffer.selections addObject:[[XCSourceTextRange alloc] initWithStart:XCSourceTextPositionMake(firstLine, 0) end:XCSourceTextPositionMake(firstLine + sortedImports.count, sortedImports.lastObject.length)]];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    completionHandler(nil);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>选择这个插件作为当前 Scheme，选择 Xcode 运行，然后就会弹出一个黑色的 Xcode 供你调试了。<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-8fb83256d9e38800.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><img src=\"http://upload-images.jianshu.io/upload_images/698554-7410ea37b33422fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"调试插件\"></p>\n<h2 id=\"分发\"><a href=\"#分发\" class=\"headerlink\" title=\"分发\"></a>分发</h2><p>插件开发测试完成之后，最重要的当然是将插件分发出去，供他人使用。Apple 在  <a href=\"https://developer.apple.com/videos/play/wwdc2016/414/\" target=\"_blank\" rel=\"external\">WWDC</a> 说到 Xcode Source Editor Extension 是可以上架 Mac App Store 的，不过受限于 Source Editor Extension 功能实在太少，目前也没有在 Mac App Store 上看到很火的插件。更多是直接把 .app 文件上传到 Github 上供人下载（这里有人整理了一些不错的插件：<a href=\"https://github.com/theswiftdev/awesome-xcode-extensions），具体步骤如下：\" target=\"_blank\" rel=\"external\">https://github.com/theswiftdev/awesome-xcode-extensions），具体步骤如下：</a></p>\n<h4 id=\"打包\"><a href=\"#打包\" class=\"headerlink\" title=\"打包\"></a>打包</h4><p>测试完成后，找到 Products 下面的 .app 文件，注意需要保证上文中说的两个签名是一致的。然后就可以把这个 .app 上传到个人网站或者 Github 上供人下载使用了。<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-5202f8ddea721d38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\".app 文件\"></p>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p>当我们下载好了一个 .app 格式的插件之后，直接双击这个 .app 文件，然后在 系统偏好设置-&gt; 扩展 -&gt; Xcode Source Editor Extension 勾选该插件，最后重启 Xcode 就可以在 Editor 菜单中找到该插件了。<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-b35bafce22cccf86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"勾选插件\"></p>\n<p>还可以在 Xcode 中为插件的菜单项设置快捷键。<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-d5f2a3622205f490.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"设置快键键\"></p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>至少现有的 Xcode Source Editor Extension 还是比较受限的，接口少的可怜，可想象的空间不是很多，大部分之前第三方插件能做的事情都没办法完成了🤷‍♀️。还是默默希望 Apple 能以更加开放的姿态，提供更多的接口给开发者，Xcode 没办法满足所有人的喜好，起码，能让喜欢折腾的人把它变得更好 :-D</p>\n","excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>Xcode 秉承了 Apple 封闭的传统，提供的可自定义的选项比起其他 IDE 来说是比较少的，不过在 Xcode 7 之前（包含 Xcode 7）我们还是可以通过插件实现 Xcode 的自定义，甚至还出现了像  <a href=\"https://github.com/alcatraz/Alcatraz\">Alcatraz</a> 的专门的插件管理工具，开源社区中也有诸如 <a href=\"https://link.jianshu.com/?t=https://github.com/onevcat/VVDocumenter-Xcode\">VVDocumenter-Xcode</a>、<a href=\"https://github.com/CocoaPods/CocoaPods\">CocoaPods</a> 等知名的插件，不过这些便利随着 Xcode 8 的发布成为了过去式。<br>出于安全性考虑（比如说 Xcode ghost 事件），Apple 从 Xcode 8 开始不再支持第三方的插件。Apple 方面提供了基于 App Extension 的解决方案 – Xcode Source Editor Extension，这是一个相当简单的方案，能且仅能完成有限的文本编辑辅助，很大部分之前第三方插件能完成的任务都没办法实现了。聊胜于无吧 😑<br>（本文会介绍 Source Editor Extension 的开发以及分发相关的知识，本文对应的 Demo 在：<a href=\"https://github.com/VernonVan/PPImportArrangerExtension）\">https://github.com/VernonVan/PPImportArrangerExtension）</a></p>\n<h2 id=\"创建插件\"><a href=\"#创建插件\" class=\"headerlink\" title=\"创建插件\"></a>创建插件</h2><ol>\n<li><p>创建一个 Cocoa App：Source Editor Extension 不能独立存在，必须依附于 Cocoa App。<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-a00fabcbca0f7353.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Cocoa App\"></p>\n<p>​</p>\n</li>\n<li><p>File -&gt; New -&gt; Target -&gt; Xcode Source Editor Extension 添加一个 Target，并激活这个 Target。<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-0c32ca262d291557.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Xcode Source Editor Extension\"><br><img src=\"http://upload-images.jianshu.io/upload_images/698554-b6a7d64355a372d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"激活 target\"></p>\n</li>\n</ol>\n<p>这样就创建好了一个可运行的 Source Editor Extension，相当的简单。🧐</p>\n<h2 id=\"关键概念\"><a href=\"#关键概念\" class=\"headerlink\" title=\"关键概念\"></a>关键概念</h2><p><img src=\"http://upload-images.jianshu.io/upload_images/698554-0e6f169643d8a20f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"文件结构\"></p>\n<ul>\n<li>SourceEditorExtension 类：遵循 XCSourceEditorExtension 协议的类，XCSourceEditorExtension 协议的头文件如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">@protocol XCSourceEditorExtension &lt;NSObject&gt;</div><div class=\"line\"></div><div class=\"line\">@optional</div><div class=\"line\"></div><div class=\"line\">- (void)extensionDidFinishLaunching;</div><div class=\"line\"></div><div class=\"line\">@property (readonly, copy) NSArray &lt;NSDictionary &lt;XCSourceEditorCommandDefinitionKey, id&gt; *&gt; *commandDefinitions;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>XCSourceEditorExtension 协议只有一个方法和一个属性，extensionDidFinishLaunching 方法是用来在插件加载好后是对插件进行一些准备工作的，根据 <a href=\"https://developer.apple.com/videos/play/wwdc2016/414/\">WWDC</a> 的说法，各个插件与 Xcode 本身的初始化过程是在不同进程上进行的，同样地，插件的崩溃并不会引起 Xcode 的崩溃。commandDefinitions 属性则可以动态返回插件的菜单项。</p>\n<p>SourceEditorCommand 类：遵循 XCSourceEditorCommand 协议的类，实现插件功能的核心类，对应到插件的菜单项，可以一个菜单项对应到一个 Command 类，也可以多个菜单项对应到一个 Command 类，XCSourceEditorCommand 协议头文件定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">@protocol XCSourceEditorCommand &lt;NSObject&gt;</div><div class=\"line\"></div><div class=\"line\">@required</div><div class=\"line\"></div><div class=\"line\">- (void)performCommandWithInvocation:(XCSourceEditorCommandInvocation *)invocation completionHandler:(void (^)(NSError * _Nullable nilOrError))completionHandler;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>XCSourceEditorCommandInvocation 类型的参数 invocation 主要是点击的菜单项的标识、当前文本信息（文本字符串数组、选中区间等）以及点击取消按钮的回调事件，completionHandler 参数则是用来通知 Xcode 本插件已经完成了自己的操作，需要保证一定要调用 completionHandler！否则会出现下图所示的提示，然后菜单项就会变灰不能再点击：<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-f57b5a31a603f5f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"插件 busy\"><br><img src=\"http://upload-images.jianshu.io/upload_images/698554-8e6d0b4a636883f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"菜单项变灰\"></p>\n<ul>\n<li>Info.plist：Info.plist 文件用于静态配置插件对应的菜单项，如下图所示，XCSourceEditorExtensionPrincipalClass 对应到上文说的 XCSourceEditorExtension 类，XCSourceEditorCommandDefinitions 指定菜单项，XCSourceEditorCommandClassName 对应到上文说的 SourceEditorCommand 类，XCSourceEditorCommandIdentifier 是每个具体菜单项的标识，XCSourceEditorCommandName 是菜单项的描述。</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-54682412d2c5b04a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Info.plist\"></p>\n<ul>\n<li>保证 TARGETS 组下的两个 Target 用的同一个签名。</li>\n</ul>\n<h2 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h2><p>本 Demo 要实现的功能就是按照字母顺序重新排列当前文件的所有 Import，强迫症们一定知道我在说什么🤣，先来看一下效果：<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-58e34917de432fbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"效果图\"><br><img src=\"http://upload-images.jianshu.io/upload_images/698554-9638491f62073029.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"演示效果\"><br>可以点击 Editor -&gt; ImportArranger -&gt; Arrange Imports 重新排列所有的 Imports，甚至还可以为其设置快键键。</p>\n<p>实现步骤反而没有什么可说的，主要是操作 invocation.buffer.lines 和 invocation.buffer.selections，分别对应的是当前文件的所有行和当前文件的选择区域，都是可变类型的数组，做完自定义的操作后操作数组即可更新当前文件。注意：<strong>不管是哪条执行路径，一定要保证调用到 completionHandler</strong>。其他需要留意的地方都在代码中的注释中给出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)performCommandWithInvocation:(XCSourceEditorCommandInvocation *)invocation completionHandler:(void (^)(NSError *_Nullable nilOrError))completionHandler</div><div class=\"line\">&#123;</div><div class=\"line\">    NSMutableArray&lt;NSString *&gt; *lines = invocation.buffer.lines;</div><div class=\"line\">    if (!lines || !lines.count) &#123;</div><div class=\"line\">        completionHandler(nil);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    NSMutableArray&lt;NSString *&gt; *importLines = [[NSMutableArray alloc] init];</div><div class=\"line\">    NSInteger firstLine = -1;</div><div class=\"line\">    for (NSUInteger index = 0, max = lines.count; index &lt; max; index++) &#123;</div><div class=\"line\">        NSString *line = lines[index];</div><div class=\"line\">        NSString *pureLine = [line stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;];       // 去掉多余的空格，以防被空格干扰没检测到 #import</div><div class=\"line\">        // 支持 Objective-C、Swift、C 语言的导入方式</div><div class=\"line\">        if ([pureLine hasPrefix:@&quot;#import&quot;] || [pureLine hasPrefix:@&quot;import&quot;] || [pureLine hasPrefix:@&quot;@class&quot;]</div><div class=\"line\">            || [pureLine hasPrefix:@&quot;@import&quot;] || [pureLine hasPrefix:@&quot;#include&quot;]) &#123;     </div><div class=\"line\">            [importLines addObject:line];</div><div class=\"line\">            if (firstLine == -1) &#123;</div><div class=\"line\">                firstLine = index;      // 记住第一行 #import 所在的行数，用来等下重新插入的位置</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (!importLines.count) &#123;</div><div class=\"line\">        completionHandler(nil);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    [invocation.buffer.lines removeObjectsInArray:importLines];</div><div class=\"line\"></div><div class=\"line\">    NSArray *noRepeatArray = [[NSSet setWithArray:importLines] allObjects];         // 去掉重复的 #import</div><div class=\"line\">    NSMutableArray&lt;NSString *&gt; *sortedImports = [[NSMutableArray alloc] initWithArray:[noRepeatArray sortedArrayUsingSelector:@selector(caseInsensitiveCompare:)]];</div><div class=\"line\"></div><div class=\"line\">    // 引用系统文件在前，用户自定义的文件在后</div><div class=\"line\">    NSMutableArray *systemImports = [[NSMutableArray alloc] init];</div><div class=\"line\">    for (NSString *line in sortedImports) &#123;</div><div class=\"line\">        if ([line containsString:@&quot;&lt;&quot;]) &#123;</div><div class=\"line\">            [systemImports addObject:line];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (systemImports.count) &#123;</div><div class=\"line\">        [sortedImports removeObjectsInArray:systemImports];</div><div class=\"line\">        [sortedImports insertObjects:systemImports atIndexes:[NSIndexSet indexSetWithIndexesInRange:NSMakeRange(0, systemImports.count)]];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (firstLine &gt;= 0 &amp;&amp; firstLine &lt; invocation.buffer.lines.count) &#123;</div><div class=\"line\">        // 重新插入排好序的 #import 行</div><div class=\"line\">        [invocation.buffer.lines insertObjects:sortedImports atIndexes:[NSIndexSet indexSetWithIndexesInRange:NSMakeRange(firstLine, sortedImports.count)]];</div><div class=\"line\">        // 选中所有 #import 行</div><div class=\"line\">        [invocation.buffer.selections addObject:[[XCSourceTextRange alloc] initWithStart:XCSourceTextPositionMake(firstLine, 0) end:XCSourceTextPositionMake(firstLine + sortedImports.count, sortedImports.lastObject.length)]];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    completionHandler(nil);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>选择这个插件作为当前 Scheme，选择 Xcode 运行，然后就会弹出一个黑色的 Xcode 供你调试了。<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-8fb83256d9e38800.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><img src=\"http://upload-images.jianshu.io/upload_images/698554-7410ea37b33422fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"调试插件\"></p>\n<h2 id=\"分发\"><a href=\"#分发\" class=\"headerlink\" title=\"分发\"></a>分发</h2><p>插件开发测试完成之后，最重要的当然是将插件分发出去，供他人使用。Apple 在  <a href=\"https://developer.apple.com/videos/play/wwdc2016/414/\">WWDC</a> 说到 Xcode Source Editor Extension 是可以上架 Mac App Store 的，不过受限于 Source Editor Extension 功能实在太少，目前也没有在 Mac App Store 上看到很火的插件。更多是直接把 .app 文件上传到 Github 上供人下载（这里有人整理了一些不错的插件：<a href=\"https://github.com/theswiftdev/awesome-xcode-extensions），具体步骤如下：\">https://github.com/theswiftdev/awesome-xcode-extensions），具体步骤如下：</a></p>\n<h4 id=\"打包\"><a href=\"#打包\" class=\"headerlink\" title=\"打包\"></a>打包</h4><p>测试完成后，找到 Products 下面的 .app 文件，注意需要保证上文中说的两个签名是一致的。然后就可以把这个 .app 上传到个人网站或者 Github 上供人下载使用了。<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-5202f8ddea721d38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\".app 文件\"></p>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p>当我们下载好了一个 .app 格式的插件之后，直接双击这个 .app 文件，然后在 系统偏好设置-&gt; 扩展 -&gt; Xcode Source Editor Extension 勾选该插件，最后重启 Xcode 就可以在 Editor 菜单中找到该插件了。<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-b35bafce22cccf86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"勾选插件\"></p>\n<p>还可以在 Xcode 中为插件的菜单项设置快捷键。<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-d5f2a3622205f490.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"设置快键键\"></p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>至少现有的 Xcode Source Editor Extension 还是比较受限的，接口少的可怜，可想象的空间不是很多，大部分之前第三方插件能做的事情都没办法完成了🤷‍♀️。还是默默希望 Apple 能以更加开放的姿态，提供更多的接口给开发者，Xcode 没办法满足所有人的喜好，起码，能让喜欢折腾的人把它变得更好 :-D</p>\n"},{"title":"响应式编程与MVVM架构—理论篇","date":"2017-10-12T02:26:38.000Z","_content":"\n\n\n前段时间，在使用了一段时间的MVVM架构之后，我从实际的项目中抽离出来，对使用MVVM架构的整个过程进行了总结，对于架构、对于编程思维又有了不一样的体会。于是提笔写下自己探索MVVM架构的经验和心得，以飨读者。\n\n\n\n本文会先对MVC架构做一个回顾，明确MVC中各层的职责；然后会提出MVVM架构的概念，本来接下来应该顺势举几个MVVM的例子进行说明的，但是考虑到响应式编程之于MVVM的重要性，所以在举例之前会先讲解一下响应式编程的概念(出于篇幅考虑，将MVVM架构实践独立成一篇文章，想直接看实例的请移驾[这里]())；最后会对MVC和MVVM的取舍谈谈自己的看法。话不多说，现在进入正题。\n\n\n\n## MVC架构\n\nMVC(Model-View-Controller)，是一种常见的客户端软件开发框架，具体到iOS上，绝大部分人从开始接触iOS编程的时候都被告知MVC就是事实上的默认框架。系统也为我们实现好了公共的视图类：UIView 和控制器类：UIViewController。大多数时候，我们都需要继承这些类来实现我们的程序逻辑，因此，我们几乎逃避不开MVC这种设计模式。下面就对MVC各层的职责进行明确：\n\n\n\n### Model\n\nModel层 是服务端数据在客户端的映射，是薄薄的一层，完全可以用struct表征。下面看一个实例：\n\n![Model](http://upload-images.jianshu.io/upload_images/698554-39fbabcc27672a79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n可以看到，Model 层通常是服务端传回的 JSON数据的映射，对应为一个一个的属性。不过现在也有很多人将网络层(Service层)归到Model中，也就是MVC(S)架构。同时，大部分时候数据的持久化操作也会放在Model层中。\n\n总结一下，Model层的职责主要有以下几项：**HTTP请求、进行字段验证、持久化**等。\n\n\n\n### View层\n\nView层是展示在屏幕上的视图的封装，在 iOS 中也就是UIView以及UIView的子类。下面是UIView的继承层级图：\n\n![View](http://upload-images.jianshu.io/upload_images/698554-075df5d6895547a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nView层的职责是**展示内容**和**接受用户的操作与事件**。\n\n\n\n### Controller层\n\n看了Model层和View层如此简单清晰的定义，如果你以为接下来要讲的Controller层的定义也跟这两层一样，那你就要失望了。\n\n粗略总结了一下，Controller层的职责包括但不限于：**管理根视图以及其子视图的生命周期**、**展示内容和布局**、**处理用户行为**(如按钮的点击和手势的触发等)、**储存当前界面的状态**(例如分页加载的页数、是否正在进行网络请求的布尔值等)、**处理界面的跳转**、**作为UITableView以及其它容器视图的代理以及数据源**、**业务逻辑**和**各种动画效果**等。\n\n画风似乎不对啊，为什么Controller层的职责比其他两层加起来还多？\n\n\n\n### MVC的困境\n\n因为MVC架构中Controller层往往代码很多，动辄2、3千行的这一特点，MVC也常常被调侃成是 Massive View Controller。造成这个问题的原因就是MVC的定义太过简单朴素，要知道支撑一个尚不算大的企业级应用都动辄几十万行代码，还不包括各种依赖的第三方库。这么多的代码如何安置？按照传统的MVC定义，分割了小部分到Model层和View层，剩下的代码都没有其他地方可以去了，于是被统统的丢到了Controll层中。\n\n庞大的Controller层带来的问题就是难以维护、难以测试。而且其中充斥着大量的状态值，一个任务的完成依赖于好几个状态值，而一个状态值又同时参与到多个任务中，这样复杂的多对多关系带来的问题就是开发效率低下，需要花费大量的时间周旋在各个状态值之间，对以后的功能拓展、业务添加也造成了障碍。\n\n这样的前提下，架构的改进就显得非常有必要了。\n\n\n\n## MVVM架构初探\n\nMVVM(Model-View-ViewModel)，2005年由微软的WPF和Silverlight的架构师 John Gossman 提出，是MVP模式与WPF结合发展演变过来的一种架构框架。MVVM实质上还是MVC架构范围，是一个精心优化的MVC架构，所以与MVC架构是兼容的。\n\n\n\nMVVM首先将View层和Controller层进行了合并，统称为View层，因为View层和Controller层往往是一起出现的。然后引入了一个新的模块 — **ViewModel层**，ViewModel层承载的内容就是之前在Controller层中**视图展现逻辑**。MVVM的图示如下：\n\n![MVVM图示](http://upload-images.jianshu.io/upload_images/698554-5f804627e25202e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n什么是视图展现逻辑呢？在一款应用中，数据的来源可能是服务端返回、数据库获取和用户输入，然后存储在Model中，但是这样的数据是一种“未经格式化的”原始数据，还不能直接显示到屏幕上。比如Model中可能有姓、名、昵称等属性，在某些界面中需要显示成\"姓名\"的样式，某些界面中显示成\"名姓\"的样式，某些界面中显示\"昵称\"的样式。视图展现逻辑就是把这些原始数据经过业务需求处理成展现到屏幕上的数据。可以把一个应用看成是播出一个新闻节目，Model层就是一大堆繁杂的稿件，View层就是主持人实际播报的新闻，而ViewModel层就是幕后的编辑处理团队，负责从凌乱的稿件中抽出需要的信息，整理成播报时用的稿件。这样主持人拿着整理好的稿件，就能轻松的播报新闻了。\n\n\n\n但是呢，平白无故多了一个ViewModel层。多一个层带来的直接问题就是信息的传递问题，层与层之间需要互通信息，进行交流。在MVVM架构的实现中，开发人员想出了一个与传统消息传递所不一样的方式，这就引出了响应式编程的概念。\n\n\n\n## 响应式编程\n\n响应式编程(Reactive Programming)，是一种面向数据流和变化传播的范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。举个维基百科中的例子：c:=a+b表示将表达式的结果赋给c，而之后改变a或b的值不会影响c。但在响应式编程中，c的值会随着a或b的更新而更新。\n\n![响应式编程](http://upload-images.jianshu.io/upload_images/698554-0a3c4d4e90a11372.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n也就是说，**上图中c的值最后会是5**。\n\n同样的例子还有Excel中的单元格，单元格可以包含字面值或类似\"=B1+C1\"的公式，而包含公式的单元格的值会依据其他单元格的值的变化而变化 。\n\n\n\n如何实现所谓的响应式编程？在WPF中官方提供了Data Binding技术，macOS中也有类似的Cocoa Binding框架，但是在iOS中官方没有提供这样的框架。于是GitHub上出现了ReactiveCococa(以下简称为RAC)和RxSwift等优秀的第三方框架。\n\n在RAC的思维中，iOS上的一切都是在变化的数据流，比如输入框上用户正在不断输入的文字、被点击的按钮、旋转缩放的视图、不断改变的NSString等等，这些就像是一个\"水龙头\"，当有变化产生的时候，水龙头就会出水，把变化传递下去，对这个变化感兴趣的人就可以在这个水龙头上套一个\"水管\"，这个人就成为了一个接收者(subscriber)，当有变化产生的时候，接收者就能从水管中拿到这个变化的具体信息。\n\nRAC就提供了这样的\"水管\"，但是和现实中的水管有所不同，RAC有自己的一些限制：水管中传递的不是水，而是一个个的\"玻璃球\"，这些玻璃球的直径和水管的内径一样大，保证了玻璃球在水管中都是依次排列通过的，这就保证了不会出现多个玻璃球并列通过的情况。更加重要的是，在拿到玻璃球之前，可以对其进行一些个性化的定制。例如，可以在水龙头上加一个过滤嘴(filter)，不符合的不让通过；也可以加一个改动装置，把球改变成符合自己的需求(map)；还可以把多个水龙头合并成一个新的水龙头(combineLatest:reduce:)，经过了这些定制之后，出来的符合要求的玻璃球就能拿来直接用了。\n\n\n\n在这么强大的框架帮助下，MVVM所引入的ViewModel层和其他层之间的通讯问题得到了解决。\n\n\n\n## MVC还是MVVM？\n\n在考虑是否要选择MVVM架构之前，先来总结一下MVVM的优势和不足。\n\nMVVM主要有以下几个优势：\n\n- Controller层瘦身：将视图展现逻辑抽出到ViewModel层带来的直接变化就是Controller层变得更加轻量级，更加容易维护。\n- 更加容易测试：Controller层代码减少了，也意味着对Controller层的测试更加容易。\n- 兼容MVC：选择MVVM并不意味着完全摒弃MVC，MVVM相当于是MVC的超集，所以和MVC是兼容的，也就是说，可以只在某一个模块中使用MVVM，不用担心迁移架构时会造成需要全局重构的问题。\n- 解决状态以及状态之间依赖过多的问题：这个优势是由RAC所带来的，响应式编程关注的数据的变化和流向，免除了一部分的状态，而是直接将变化传到显示的控件上，[实例]()在这里。\n- 提供统一的消息传递机制：这也是由RAC所带来的，RAC对iOS编程中大部分的实物进行了抽象，提供了统一的接口，所以可以将iOS上KVO、通知(NSNotification)、委托(delegate)、Target-Action、块(Block)等消息传递方式统一，[实例]()在这里。\n\nMVVM存在的问题主要有：\n\n- 学习曲线比较陡，通常需要引入第三方库(ReactiveCocoa/RxSwift)：使用MVVM通常需要引入第三方库，而且需要转换成响应式编程的思维方式，这是需要花费相当的学习适应时间的。\n- 创建更多的类：基本上每个Controller类会对应有一个ViewModel类\n- 性能上有一定影响，调用栈变深：RAC的实现底层依赖于KVO，带来的问题是性能的损耗，比如光是subscribNext就慢了1个数量级，目前的回调堆栈也比较深，最简单的[signal subscribeNext^(id x){}]就会有近40次的调用。\n\n\n\nMVVM好处不少，缺点也一堆。那到底要不要用MVVM呢？我觉得，在项目还不算臃肿的时候，可以简单的对现有的MVC进行解耦优化，比如将网络层(Service层)、持久层(Storage层)等部分抽象出来即可。另一方面，MVVM对MVC也是兼容的，可以考虑在项目中的某个模块试水MVVM，觉得好再逐步替换其他模块；而且很重要的一点是，响应式编程这样一种范式相当的锻炼我们的编程思维，让我们可以站在数据的变化和流向的角度去思考我们的整一个项目，掌握这种思维方式也可以反哺到我们项目中别的地方。\n\n\n\n架构没有绝对的优劣，适合自己的架构就是最好的架构，那就让我们理性分析，拥抱变化。","source":"_posts/响应式编程与MVVM架构--理论篇.md","raw":"---\ntitle: 响应式编程与MVVM架构—理论篇\ndate: 2017-10-12 10:26:38\ntags: \n- iOS\n- 架构\ncategories:\n- ruanpapa--技术贴\n---\n\n\n\n前段时间，在使用了一段时间的MVVM架构之后，我从实际的项目中抽离出来，对使用MVVM架构的整个过程进行了总结，对于架构、对于编程思维又有了不一样的体会。于是提笔写下自己探索MVVM架构的经验和心得，以飨读者。\n\n\n\n本文会先对MVC架构做一个回顾，明确MVC中各层的职责；然后会提出MVVM架构的概念，本来接下来应该顺势举几个MVVM的例子进行说明的，但是考虑到响应式编程之于MVVM的重要性，所以在举例之前会先讲解一下响应式编程的概念(出于篇幅考虑，将MVVM架构实践独立成一篇文章，想直接看实例的请移驾[这里]())；最后会对MVC和MVVM的取舍谈谈自己的看法。话不多说，现在进入正题。\n\n\n\n## MVC架构\n\nMVC(Model-View-Controller)，是一种常见的客户端软件开发框架，具体到iOS上，绝大部分人从开始接触iOS编程的时候都被告知MVC就是事实上的默认框架。系统也为我们实现好了公共的视图类：UIView 和控制器类：UIViewController。大多数时候，我们都需要继承这些类来实现我们的程序逻辑，因此，我们几乎逃避不开MVC这种设计模式。下面就对MVC各层的职责进行明确：\n\n\n\n### Model\n\nModel层 是服务端数据在客户端的映射，是薄薄的一层，完全可以用struct表征。下面看一个实例：\n\n![Model](http://upload-images.jianshu.io/upload_images/698554-39fbabcc27672a79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n可以看到，Model 层通常是服务端传回的 JSON数据的映射，对应为一个一个的属性。不过现在也有很多人将网络层(Service层)归到Model中，也就是MVC(S)架构。同时，大部分时候数据的持久化操作也会放在Model层中。\n\n总结一下，Model层的职责主要有以下几项：**HTTP请求、进行字段验证、持久化**等。\n\n\n\n### View层\n\nView层是展示在屏幕上的视图的封装，在 iOS 中也就是UIView以及UIView的子类。下面是UIView的继承层级图：\n\n![View](http://upload-images.jianshu.io/upload_images/698554-075df5d6895547a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nView层的职责是**展示内容**和**接受用户的操作与事件**。\n\n\n\n### Controller层\n\n看了Model层和View层如此简单清晰的定义，如果你以为接下来要讲的Controller层的定义也跟这两层一样，那你就要失望了。\n\n粗略总结了一下，Controller层的职责包括但不限于：**管理根视图以及其子视图的生命周期**、**展示内容和布局**、**处理用户行为**(如按钮的点击和手势的触发等)、**储存当前界面的状态**(例如分页加载的页数、是否正在进行网络请求的布尔值等)、**处理界面的跳转**、**作为UITableView以及其它容器视图的代理以及数据源**、**业务逻辑**和**各种动画效果**等。\n\n画风似乎不对啊，为什么Controller层的职责比其他两层加起来还多？\n\n\n\n### MVC的困境\n\n因为MVC架构中Controller层往往代码很多，动辄2、3千行的这一特点，MVC也常常被调侃成是 Massive View Controller。造成这个问题的原因就是MVC的定义太过简单朴素，要知道支撑一个尚不算大的企业级应用都动辄几十万行代码，还不包括各种依赖的第三方库。这么多的代码如何安置？按照传统的MVC定义，分割了小部分到Model层和View层，剩下的代码都没有其他地方可以去了，于是被统统的丢到了Controll层中。\n\n庞大的Controller层带来的问题就是难以维护、难以测试。而且其中充斥着大量的状态值，一个任务的完成依赖于好几个状态值，而一个状态值又同时参与到多个任务中，这样复杂的多对多关系带来的问题就是开发效率低下，需要花费大量的时间周旋在各个状态值之间，对以后的功能拓展、业务添加也造成了障碍。\n\n这样的前提下，架构的改进就显得非常有必要了。\n\n\n\n## MVVM架构初探\n\nMVVM(Model-View-ViewModel)，2005年由微软的WPF和Silverlight的架构师 John Gossman 提出，是MVP模式与WPF结合发展演变过来的一种架构框架。MVVM实质上还是MVC架构范围，是一个精心优化的MVC架构，所以与MVC架构是兼容的。\n\n\n\nMVVM首先将View层和Controller层进行了合并，统称为View层，因为View层和Controller层往往是一起出现的。然后引入了一个新的模块 — **ViewModel层**，ViewModel层承载的内容就是之前在Controller层中**视图展现逻辑**。MVVM的图示如下：\n\n![MVVM图示](http://upload-images.jianshu.io/upload_images/698554-5f804627e25202e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n什么是视图展现逻辑呢？在一款应用中，数据的来源可能是服务端返回、数据库获取和用户输入，然后存储在Model中，但是这样的数据是一种“未经格式化的”原始数据，还不能直接显示到屏幕上。比如Model中可能有姓、名、昵称等属性，在某些界面中需要显示成\"姓名\"的样式，某些界面中显示成\"名姓\"的样式，某些界面中显示\"昵称\"的样式。视图展现逻辑就是把这些原始数据经过业务需求处理成展现到屏幕上的数据。可以把一个应用看成是播出一个新闻节目，Model层就是一大堆繁杂的稿件，View层就是主持人实际播报的新闻，而ViewModel层就是幕后的编辑处理团队，负责从凌乱的稿件中抽出需要的信息，整理成播报时用的稿件。这样主持人拿着整理好的稿件，就能轻松的播报新闻了。\n\n\n\n但是呢，平白无故多了一个ViewModel层。多一个层带来的直接问题就是信息的传递问题，层与层之间需要互通信息，进行交流。在MVVM架构的实现中，开发人员想出了一个与传统消息传递所不一样的方式，这就引出了响应式编程的概念。\n\n\n\n## 响应式编程\n\n响应式编程(Reactive Programming)，是一种面向数据流和变化传播的范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。举个维基百科中的例子：c:=a+b表示将表达式的结果赋给c，而之后改变a或b的值不会影响c。但在响应式编程中，c的值会随着a或b的更新而更新。\n\n![响应式编程](http://upload-images.jianshu.io/upload_images/698554-0a3c4d4e90a11372.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n也就是说，**上图中c的值最后会是5**。\n\n同样的例子还有Excel中的单元格，单元格可以包含字面值或类似\"=B1+C1\"的公式，而包含公式的单元格的值会依据其他单元格的值的变化而变化 。\n\n\n\n如何实现所谓的响应式编程？在WPF中官方提供了Data Binding技术，macOS中也有类似的Cocoa Binding框架，但是在iOS中官方没有提供这样的框架。于是GitHub上出现了ReactiveCococa(以下简称为RAC)和RxSwift等优秀的第三方框架。\n\n在RAC的思维中，iOS上的一切都是在变化的数据流，比如输入框上用户正在不断输入的文字、被点击的按钮、旋转缩放的视图、不断改变的NSString等等，这些就像是一个\"水龙头\"，当有变化产生的时候，水龙头就会出水，把变化传递下去，对这个变化感兴趣的人就可以在这个水龙头上套一个\"水管\"，这个人就成为了一个接收者(subscriber)，当有变化产生的时候，接收者就能从水管中拿到这个变化的具体信息。\n\nRAC就提供了这样的\"水管\"，但是和现实中的水管有所不同，RAC有自己的一些限制：水管中传递的不是水，而是一个个的\"玻璃球\"，这些玻璃球的直径和水管的内径一样大，保证了玻璃球在水管中都是依次排列通过的，这就保证了不会出现多个玻璃球并列通过的情况。更加重要的是，在拿到玻璃球之前，可以对其进行一些个性化的定制。例如，可以在水龙头上加一个过滤嘴(filter)，不符合的不让通过；也可以加一个改动装置，把球改变成符合自己的需求(map)；还可以把多个水龙头合并成一个新的水龙头(combineLatest:reduce:)，经过了这些定制之后，出来的符合要求的玻璃球就能拿来直接用了。\n\n\n\n在这么强大的框架帮助下，MVVM所引入的ViewModel层和其他层之间的通讯问题得到了解决。\n\n\n\n## MVC还是MVVM？\n\n在考虑是否要选择MVVM架构之前，先来总结一下MVVM的优势和不足。\n\nMVVM主要有以下几个优势：\n\n- Controller层瘦身：将视图展现逻辑抽出到ViewModel层带来的直接变化就是Controller层变得更加轻量级，更加容易维护。\n- 更加容易测试：Controller层代码减少了，也意味着对Controller层的测试更加容易。\n- 兼容MVC：选择MVVM并不意味着完全摒弃MVC，MVVM相当于是MVC的超集，所以和MVC是兼容的，也就是说，可以只在某一个模块中使用MVVM，不用担心迁移架构时会造成需要全局重构的问题。\n- 解决状态以及状态之间依赖过多的问题：这个优势是由RAC所带来的，响应式编程关注的数据的变化和流向，免除了一部分的状态，而是直接将变化传到显示的控件上，[实例]()在这里。\n- 提供统一的消息传递机制：这也是由RAC所带来的，RAC对iOS编程中大部分的实物进行了抽象，提供了统一的接口，所以可以将iOS上KVO、通知(NSNotification)、委托(delegate)、Target-Action、块(Block)等消息传递方式统一，[实例]()在这里。\n\nMVVM存在的问题主要有：\n\n- 学习曲线比较陡，通常需要引入第三方库(ReactiveCocoa/RxSwift)：使用MVVM通常需要引入第三方库，而且需要转换成响应式编程的思维方式，这是需要花费相当的学习适应时间的。\n- 创建更多的类：基本上每个Controller类会对应有一个ViewModel类\n- 性能上有一定影响，调用栈变深：RAC的实现底层依赖于KVO，带来的问题是性能的损耗，比如光是subscribNext就慢了1个数量级，目前的回调堆栈也比较深，最简单的[signal subscribeNext^(id x){}]就会有近40次的调用。\n\n\n\nMVVM好处不少，缺点也一堆。那到底要不要用MVVM呢？我觉得，在项目还不算臃肿的时候，可以简单的对现有的MVC进行解耦优化，比如将网络层(Service层)、持久层(Storage层)等部分抽象出来即可。另一方面，MVVM对MVC也是兼容的，可以考虑在项目中的某个模块试水MVVM，觉得好再逐步替换其他模块；而且很重要的一点是，响应式编程这样一种范式相当的锻炼我们的编程思维，让我们可以站在数据的变化和流向的角度去思考我们的整一个项目，掌握这种思维方式也可以反哺到我们项目中别的地方。\n\n\n\n架构没有绝对的优劣，适合自己的架构就是最好的架构，那就让我们理性分析，拥抱变化。","slug":"响应式编程与MVVM架构--理论篇","published":1,"updated":"2017-10-17T02:18:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg4j8w2p001yvfwx93mv8y2l","content":"<p>前段时间，在使用了一段时间的MVVM架构之后，我从实际的项目中抽离出来，对使用MVVM架构的整个过程进行了总结，对于架构、对于编程思维又有了不一样的体会。于是提笔写下自己探索MVVM架构的经验和心得，以飨读者。</p>\n<p>本文会先对MVC架构做一个回顾，明确MVC中各层的职责；然后会提出MVVM架构的概念，本来接下来应该顺势举几个MVVM的例子进行说明的，但是考虑到响应式编程之于MVVM的重要性，所以在举例之前会先讲解一下响应式编程的概念(出于篇幅考虑，将MVVM架构实践独立成一篇文章，想直接看实例的请移驾<a href=\"\">这里</a>)；最后会对MVC和MVVM的取舍谈谈自己的看法。话不多说，现在进入正题。</p>\n<h2 id=\"MVC架构\"><a href=\"#MVC架构\" class=\"headerlink\" title=\"MVC架构\"></a>MVC架构</h2><p>MVC(Model-View-Controller)，是一种常见的客户端软件开发框架，具体到iOS上，绝大部分人从开始接触iOS编程的时候都被告知MVC就是事实上的默认框架。系统也为我们实现好了公共的视图类：UIView 和控制器类：UIViewController。大多数时候，我们都需要继承这些类来实现我们的程序逻辑，因此，我们几乎逃避不开MVC这种设计模式。下面就对MVC各层的职责进行明确：</p>\n<h3 id=\"Model\"><a href=\"#Model\" class=\"headerlink\" title=\"Model\"></a>Model</h3><p>Model层 是服务端数据在客户端的映射，是薄薄的一层，完全可以用struct表征。下面看一个实例：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-39fbabcc27672a79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Model\"></p>\n<p>可以看到，Model 层通常是服务端传回的 JSON数据的映射，对应为一个一个的属性。不过现在也有很多人将网络层(Service层)归到Model中，也就是MVC(S)架构。同时，大部分时候数据的持久化操作也会放在Model层中。</p>\n<p>总结一下，Model层的职责主要有以下几项：<strong>HTTP请求、进行字段验证、持久化</strong>等。</p>\n<h3 id=\"View层\"><a href=\"#View层\" class=\"headerlink\" title=\"View层\"></a>View层</h3><p>View层是展示在屏幕上的视图的封装，在 iOS 中也就是UIView以及UIView的子类。下面是UIView的继承层级图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-075df5d6895547a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"View\"></p>\n<p>View层的职责是<strong>展示内容</strong>和<strong>接受用户的操作与事件</strong>。</p>\n<h3 id=\"Controller层\"><a href=\"#Controller层\" class=\"headerlink\" title=\"Controller层\"></a>Controller层</h3><p>看了Model层和View层如此简单清晰的定义，如果你以为接下来要讲的Controller层的定义也跟这两层一样，那你就要失望了。</p>\n<p>粗略总结了一下，Controller层的职责包括但不限于：<strong>管理根视图以及其子视图的生命周期</strong>、<strong>展示内容和布局</strong>、<strong>处理用户行为</strong>(如按钮的点击和手势的触发等)、<strong>储存当前界面的状态</strong>(例如分页加载的页数、是否正在进行网络请求的布尔值等)、<strong>处理界面的跳转</strong>、<strong>作为UITableView以及其它容器视图的代理以及数据源</strong>、<strong>业务逻辑</strong>和<strong>各种动画效果</strong>等。</p>\n<p>画风似乎不对啊，为什么Controller层的职责比其他两层加起来还多？</p>\n<h3 id=\"MVC的困境\"><a href=\"#MVC的困境\" class=\"headerlink\" title=\"MVC的困境\"></a>MVC的困境</h3><p>因为MVC架构中Controller层往往代码很多，动辄2、3千行的这一特点，MVC也常常被调侃成是 Massive View Controller。造成这个问题的原因就是MVC的定义太过简单朴素，要知道支撑一个尚不算大的企业级应用都动辄几十万行代码，还不包括各种依赖的第三方库。这么多的代码如何安置？按照传统的MVC定义，分割了小部分到Model层和View层，剩下的代码都没有其他地方可以去了，于是被统统的丢到了Controll层中。</p>\n<p>庞大的Controller层带来的问题就是难以维护、难以测试。而且其中充斥着大量的状态值，一个任务的完成依赖于好几个状态值，而一个状态值又同时参与到多个任务中，这样复杂的多对多关系带来的问题就是开发效率低下，需要花费大量的时间周旋在各个状态值之间，对以后的功能拓展、业务添加也造成了障碍。</p>\n<p>这样的前提下，架构的改进就显得非常有必要了。</p>\n<h2 id=\"MVVM架构初探\"><a href=\"#MVVM架构初探\" class=\"headerlink\" title=\"MVVM架构初探\"></a>MVVM架构初探</h2><p>MVVM(Model-View-ViewModel)，2005年由微软的WPF和Silverlight的架构师 John Gossman 提出，是MVP模式与WPF结合发展演变过来的一种架构框架。MVVM实质上还是MVC架构范围，是一个精心优化的MVC架构，所以与MVC架构是兼容的。</p>\n<p>MVVM首先将View层和Controller层进行了合并，统称为View层，因为View层和Controller层往往是一起出现的。然后引入了一个新的模块 — <strong>ViewModel层</strong>，ViewModel层承载的内容就是之前在Controller层中<strong>视图展现逻辑</strong>。MVVM的图示如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-5f804627e25202e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"MVVM图示\"></p>\n<p>什么是视图展现逻辑呢？在一款应用中，数据的来源可能是服务端返回、数据库获取和用户输入，然后存储在Model中，但是这样的数据是一种“未经格式化的”原始数据，还不能直接显示到屏幕上。比如Model中可能有姓、名、昵称等属性，在某些界面中需要显示成”姓名”的样式，某些界面中显示成”名姓”的样式，某些界面中显示”昵称”的样式。视图展现逻辑就是把这些原始数据经过业务需求处理成展现到屏幕上的数据。可以把一个应用看成是播出一个新闻节目，Model层就是一大堆繁杂的稿件，View层就是主持人实际播报的新闻，而ViewModel层就是幕后的编辑处理团队，负责从凌乱的稿件中抽出需要的信息，整理成播报时用的稿件。这样主持人拿着整理好的稿件，就能轻松的播报新闻了。</p>\n<p>但是呢，平白无故多了一个ViewModel层。多一个层带来的直接问题就是信息的传递问题，层与层之间需要互通信息，进行交流。在MVVM架构的实现中，开发人员想出了一个与传统消息传递所不一样的方式，这就引出了响应式编程的概念。</p>\n<h2 id=\"响应式编程\"><a href=\"#响应式编程\" class=\"headerlink\" title=\"响应式编程\"></a>响应式编程</h2><p>响应式编程(Reactive Programming)，是一种面向数据流和变化传播的范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。举个维基百科中的例子：c:=a+b表示将表达式的结果赋给c，而之后改变a或b的值不会影响c。但在响应式编程中，c的值会随着a或b的更新而更新。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-0a3c4d4e90a11372.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"响应式编程\"></p>\n<p>也就是说，<strong>上图中c的值最后会是5</strong>。</p>\n<p>同样的例子还有Excel中的单元格，单元格可以包含字面值或类似”=B1+C1”的公式，而包含公式的单元格的值会依据其他单元格的值的变化而变化 。</p>\n<p>如何实现所谓的响应式编程？在WPF中官方提供了Data Binding技术，macOS中也有类似的Cocoa Binding框架，但是在iOS中官方没有提供这样的框架。于是GitHub上出现了ReactiveCococa(以下简称为RAC)和RxSwift等优秀的第三方框架。</p>\n<p>在RAC的思维中，iOS上的一切都是在变化的数据流，比如输入框上用户正在不断输入的文字、被点击的按钮、旋转缩放的视图、不断改变的NSString等等，这些就像是一个”水龙头”，当有变化产生的时候，水龙头就会出水，把变化传递下去，对这个变化感兴趣的人就可以在这个水龙头上套一个”水管”，这个人就成为了一个接收者(subscriber)，当有变化产生的时候，接收者就能从水管中拿到这个变化的具体信息。</p>\n<p>RAC就提供了这样的”水管”，但是和现实中的水管有所不同，RAC有自己的一些限制：水管中传递的不是水，而是一个个的”玻璃球”，这些玻璃球的直径和水管的内径一样大，保证了玻璃球在水管中都是依次排列通过的，这就保证了不会出现多个玻璃球并列通过的情况。更加重要的是，在拿到玻璃球之前，可以对其进行一些个性化的定制。例如，可以在水龙头上加一个过滤嘴(filter)，不符合的不让通过；也可以加一个改动装置，把球改变成符合自己的需求(map)；还可以把多个水龙头合并成一个新的水龙头(combineLatest:reduce:)，经过了这些定制之后，出来的符合要求的玻璃球就能拿来直接用了。</p>\n<p>在这么强大的框架帮助下，MVVM所引入的ViewModel层和其他层之间的通讯问题得到了解决。</p>\n<h2 id=\"MVC还是MVVM？\"><a href=\"#MVC还是MVVM？\" class=\"headerlink\" title=\"MVC还是MVVM？\"></a>MVC还是MVVM？</h2><p>在考虑是否要选择MVVM架构之前，先来总结一下MVVM的优势和不足。</p>\n<p>MVVM主要有以下几个优势：</p>\n<ul>\n<li>Controller层瘦身：将视图展现逻辑抽出到ViewModel层带来的直接变化就是Controller层变得更加轻量级，更加容易维护。</li>\n<li>更加容易测试：Controller层代码减少了，也意味着对Controller层的测试更加容易。</li>\n<li>兼容MVC：选择MVVM并不意味着完全摒弃MVC，MVVM相当于是MVC的超集，所以和MVC是兼容的，也就是说，可以只在某一个模块中使用MVVM，不用担心迁移架构时会造成需要全局重构的问题。</li>\n<li>解决状态以及状态之间依赖过多的问题：这个优势是由RAC所带来的，响应式编程关注的数据的变化和流向，免除了一部分的状态，而是直接将变化传到显示的控件上，<a href=\"\">实例</a>在这里。</li>\n<li>提供统一的消息传递机制：这也是由RAC所带来的，RAC对iOS编程中大部分的实物进行了抽象，提供了统一的接口，所以可以将iOS上KVO、通知(NSNotification)、委托(delegate)、Target-Action、块(Block)等消息传递方式统一，<a href=\"\">实例</a>在这里。</li>\n</ul>\n<p>MVVM存在的问题主要有：</p>\n<ul>\n<li>学习曲线比较陡，通常需要引入第三方库(ReactiveCocoa/RxSwift)：使用MVVM通常需要引入第三方库，而且需要转换成响应式编程的思维方式，这是需要花费相当的学习适应时间的。</li>\n<li>创建更多的类：基本上每个Controller类会对应有一个ViewModel类</li>\n<li>性能上有一定影响，调用栈变深：RAC的实现底层依赖于KVO，带来的问题是性能的损耗，比如光是subscribNext就慢了1个数量级，目前的回调堆栈也比较深，最简单的[signal subscribeNext^(id x){}]就会有近40次的调用。</li>\n</ul>\n<p>MVVM好处不少，缺点也一堆。那到底要不要用MVVM呢？我觉得，在项目还不算臃肿的时候，可以简单的对现有的MVC进行解耦优化，比如将网络层(Service层)、持久层(Storage层)等部分抽象出来即可。另一方面，MVVM对MVC也是兼容的，可以考虑在项目中的某个模块试水MVVM，觉得好再逐步替换其他模块；而且很重要的一点是，响应式编程这样一种范式相当的锻炼我们的编程思维，让我们可以站在数据的变化和流向的角度去思考我们的整一个项目，掌握这种思维方式也可以反哺到我们项目中别的地方。</p>\n<p>架构没有绝对的优劣，适合自己的架构就是最好的架构，那就让我们理性分析，拥抱变化。</p>\n","excerpt":"","more":"<p>前段时间，在使用了一段时间的MVVM架构之后，我从实际的项目中抽离出来，对使用MVVM架构的整个过程进行了总结，对于架构、对于编程思维又有了不一样的体会。于是提笔写下自己探索MVVM架构的经验和心得，以飨读者。</p>\n<p>本文会先对MVC架构做一个回顾，明确MVC中各层的职责；然后会提出MVVM架构的概念，本来接下来应该顺势举几个MVVM的例子进行说明的，但是考虑到响应式编程之于MVVM的重要性，所以在举例之前会先讲解一下响应式编程的概念(出于篇幅考虑，将MVVM架构实践独立成一篇文章，想直接看实例的请移驾<a href=\"\">这里</a>)；最后会对MVC和MVVM的取舍谈谈自己的看法。话不多说，现在进入正题。</p>\n<h2 id=\"MVC架构\"><a href=\"#MVC架构\" class=\"headerlink\" title=\"MVC架构\"></a>MVC架构</h2><p>MVC(Model-View-Controller)，是一种常见的客户端软件开发框架，具体到iOS上，绝大部分人从开始接触iOS编程的时候都被告知MVC就是事实上的默认框架。系统也为我们实现好了公共的视图类：UIView 和控制器类：UIViewController。大多数时候，我们都需要继承这些类来实现我们的程序逻辑，因此，我们几乎逃避不开MVC这种设计模式。下面就对MVC各层的职责进行明确：</p>\n<h3 id=\"Model\"><a href=\"#Model\" class=\"headerlink\" title=\"Model\"></a>Model</h3><p>Model层 是服务端数据在客户端的映射，是薄薄的一层，完全可以用struct表征。下面看一个实例：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-39fbabcc27672a79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Model\"></p>\n<p>可以看到，Model 层通常是服务端传回的 JSON数据的映射，对应为一个一个的属性。不过现在也有很多人将网络层(Service层)归到Model中，也就是MVC(S)架构。同时，大部分时候数据的持久化操作也会放在Model层中。</p>\n<p>总结一下，Model层的职责主要有以下几项：<strong>HTTP请求、进行字段验证、持久化</strong>等。</p>\n<h3 id=\"View层\"><a href=\"#View层\" class=\"headerlink\" title=\"View层\"></a>View层</h3><p>View层是展示在屏幕上的视图的封装，在 iOS 中也就是UIView以及UIView的子类。下面是UIView的继承层级图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-075df5d6895547a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"View\"></p>\n<p>View层的职责是<strong>展示内容</strong>和<strong>接受用户的操作与事件</strong>。</p>\n<h3 id=\"Controller层\"><a href=\"#Controller层\" class=\"headerlink\" title=\"Controller层\"></a>Controller层</h3><p>看了Model层和View层如此简单清晰的定义，如果你以为接下来要讲的Controller层的定义也跟这两层一样，那你就要失望了。</p>\n<p>粗略总结了一下，Controller层的职责包括但不限于：<strong>管理根视图以及其子视图的生命周期</strong>、<strong>展示内容和布局</strong>、<strong>处理用户行为</strong>(如按钮的点击和手势的触发等)、<strong>储存当前界面的状态</strong>(例如分页加载的页数、是否正在进行网络请求的布尔值等)、<strong>处理界面的跳转</strong>、<strong>作为UITableView以及其它容器视图的代理以及数据源</strong>、<strong>业务逻辑</strong>和<strong>各种动画效果</strong>等。</p>\n<p>画风似乎不对啊，为什么Controller层的职责比其他两层加起来还多？</p>\n<h3 id=\"MVC的困境\"><a href=\"#MVC的困境\" class=\"headerlink\" title=\"MVC的困境\"></a>MVC的困境</h3><p>因为MVC架构中Controller层往往代码很多，动辄2、3千行的这一特点，MVC也常常被调侃成是 Massive View Controller。造成这个问题的原因就是MVC的定义太过简单朴素，要知道支撑一个尚不算大的企业级应用都动辄几十万行代码，还不包括各种依赖的第三方库。这么多的代码如何安置？按照传统的MVC定义，分割了小部分到Model层和View层，剩下的代码都没有其他地方可以去了，于是被统统的丢到了Controll层中。</p>\n<p>庞大的Controller层带来的问题就是难以维护、难以测试。而且其中充斥着大量的状态值，一个任务的完成依赖于好几个状态值，而一个状态值又同时参与到多个任务中，这样复杂的多对多关系带来的问题就是开发效率低下，需要花费大量的时间周旋在各个状态值之间，对以后的功能拓展、业务添加也造成了障碍。</p>\n<p>这样的前提下，架构的改进就显得非常有必要了。</p>\n<h2 id=\"MVVM架构初探\"><a href=\"#MVVM架构初探\" class=\"headerlink\" title=\"MVVM架构初探\"></a>MVVM架构初探</h2><p>MVVM(Model-View-ViewModel)，2005年由微软的WPF和Silverlight的架构师 John Gossman 提出，是MVP模式与WPF结合发展演变过来的一种架构框架。MVVM实质上还是MVC架构范围，是一个精心优化的MVC架构，所以与MVC架构是兼容的。</p>\n<p>MVVM首先将View层和Controller层进行了合并，统称为View层，因为View层和Controller层往往是一起出现的。然后引入了一个新的模块 — <strong>ViewModel层</strong>，ViewModel层承载的内容就是之前在Controller层中<strong>视图展现逻辑</strong>。MVVM的图示如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-5f804627e25202e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"MVVM图示\"></p>\n<p>什么是视图展现逻辑呢？在一款应用中，数据的来源可能是服务端返回、数据库获取和用户输入，然后存储在Model中，但是这样的数据是一种“未经格式化的”原始数据，还不能直接显示到屏幕上。比如Model中可能有姓、名、昵称等属性，在某些界面中需要显示成”姓名”的样式，某些界面中显示成”名姓”的样式，某些界面中显示”昵称”的样式。视图展现逻辑就是把这些原始数据经过业务需求处理成展现到屏幕上的数据。可以把一个应用看成是播出一个新闻节目，Model层就是一大堆繁杂的稿件，View层就是主持人实际播报的新闻，而ViewModel层就是幕后的编辑处理团队，负责从凌乱的稿件中抽出需要的信息，整理成播报时用的稿件。这样主持人拿着整理好的稿件，就能轻松的播报新闻了。</p>\n<p>但是呢，平白无故多了一个ViewModel层。多一个层带来的直接问题就是信息的传递问题，层与层之间需要互通信息，进行交流。在MVVM架构的实现中，开发人员想出了一个与传统消息传递所不一样的方式，这就引出了响应式编程的概念。</p>\n<h2 id=\"响应式编程\"><a href=\"#响应式编程\" class=\"headerlink\" title=\"响应式编程\"></a>响应式编程</h2><p>响应式编程(Reactive Programming)，是一种面向数据流和变化传播的范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。举个维基百科中的例子：c:=a+b表示将表达式的结果赋给c，而之后改变a或b的值不会影响c。但在响应式编程中，c的值会随着a或b的更新而更新。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-0a3c4d4e90a11372.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"响应式编程\"></p>\n<p>也就是说，<strong>上图中c的值最后会是5</strong>。</p>\n<p>同样的例子还有Excel中的单元格，单元格可以包含字面值或类似”=B1+C1”的公式，而包含公式的单元格的值会依据其他单元格的值的变化而变化 。</p>\n<p>如何实现所谓的响应式编程？在WPF中官方提供了Data Binding技术，macOS中也有类似的Cocoa Binding框架，但是在iOS中官方没有提供这样的框架。于是GitHub上出现了ReactiveCococa(以下简称为RAC)和RxSwift等优秀的第三方框架。</p>\n<p>在RAC的思维中，iOS上的一切都是在变化的数据流，比如输入框上用户正在不断输入的文字、被点击的按钮、旋转缩放的视图、不断改变的NSString等等，这些就像是一个”水龙头”，当有变化产生的时候，水龙头就会出水，把变化传递下去，对这个变化感兴趣的人就可以在这个水龙头上套一个”水管”，这个人就成为了一个接收者(subscriber)，当有变化产生的时候，接收者就能从水管中拿到这个变化的具体信息。</p>\n<p>RAC就提供了这样的”水管”，但是和现实中的水管有所不同，RAC有自己的一些限制：水管中传递的不是水，而是一个个的”玻璃球”，这些玻璃球的直径和水管的内径一样大，保证了玻璃球在水管中都是依次排列通过的，这就保证了不会出现多个玻璃球并列通过的情况。更加重要的是，在拿到玻璃球之前，可以对其进行一些个性化的定制。例如，可以在水龙头上加一个过滤嘴(filter)，不符合的不让通过；也可以加一个改动装置，把球改变成符合自己的需求(map)；还可以把多个水龙头合并成一个新的水龙头(combineLatest:reduce:)，经过了这些定制之后，出来的符合要求的玻璃球就能拿来直接用了。</p>\n<p>在这么强大的框架帮助下，MVVM所引入的ViewModel层和其他层之间的通讯问题得到了解决。</p>\n<h2 id=\"MVC还是MVVM？\"><a href=\"#MVC还是MVVM？\" class=\"headerlink\" title=\"MVC还是MVVM？\"></a>MVC还是MVVM？</h2><p>在考虑是否要选择MVVM架构之前，先来总结一下MVVM的优势和不足。</p>\n<p>MVVM主要有以下几个优势：</p>\n<ul>\n<li>Controller层瘦身：将视图展现逻辑抽出到ViewModel层带来的直接变化就是Controller层变得更加轻量级，更加容易维护。</li>\n<li>更加容易测试：Controller层代码减少了，也意味着对Controller层的测试更加容易。</li>\n<li>兼容MVC：选择MVVM并不意味着完全摒弃MVC，MVVM相当于是MVC的超集，所以和MVC是兼容的，也就是说，可以只在某一个模块中使用MVVM，不用担心迁移架构时会造成需要全局重构的问题。</li>\n<li>解决状态以及状态之间依赖过多的问题：这个优势是由RAC所带来的，响应式编程关注的数据的变化和流向，免除了一部分的状态，而是直接将变化传到显示的控件上，<a href=\"\">实例</a>在这里。</li>\n<li>提供统一的消息传递机制：这也是由RAC所带来的，RAC对iOS编程中大部分的实物进行了抽象，提供了统一的接口，所以可以将iOS上KVO、通知(NSNotification)、委托(delegate)、Target-Action、块(Block)等消息传递方式统一，<a href=\"\">实例</a>在这里。</li>\n</ul>\n<p>MVVM存在的问题主要有：</p>\n<ul>\n<li>学习曲线比较陡，通常需要引入第三方库(ReactiveCocoa/RxSwift)：使用MVVM通常需要引入第三方库，而且需要转换成响应式编程的思维方式，这是需要花费相当的学习适应时间的。</li>\n<li>创建更多的类：基本上每个Controller类会对应有一个ViewModel类</li>\n<li>性能上有一定影响，调用栈变深：RAC的实现底层依赖于KVO，带来的问题是性能的损耗，比如光是subscribNext就慢了1个数量级，目前的回调堆栈也比较深，最简单的[signal subscribeNext^(id x){}]就会有近40次的调用。</li>\n</ul>\n<p>MVVM好处不少，缺点也一堆。那到底要不要用MVVM呢？我觉得，在项目还不算臃肿的时候，可以简单的对现有的MVC进行解耦优化，比如将网络层(Service层)、持久层(Storage层)等部分抽象出来即可。另一方面，MVVM对MVC也是兼容的，可以考虑在项目中的某个模块试水MVVM，觉得好再逐步替换其他模块；而且很重要的一点是，响应式编程这样一种范式相当的锻炼我们的编程思维，让我们可以站在数据的变化和流向的角度去思考我们的整一个项目，掌握这种思维方式也可以反哺到我们项目中别的地方。</p>\n<p>架构没有绝对的优劣，适合自己的架构就是最好的架构，那就让我们理性分析，拥抱变化。</p>\n"},{"title":"(翻译)关于Swift的编译时间优化","date":"2017-10-22T13:39:50.000Z","_content":"\n\n\n原文链接：[Regarding Swift build time optimizations](https://medium.com/@RobertGummesson/regarding-swift-build-time-optimizations-fc92cdd91e31)\n\n\n\n上周，在我读完 [@nickoneill](https://medium.com/@nickoneill) 写的一篇优秀的博文[《为缓慢的Swift编译时间提速》](https://medium.com/swift-programming/speeding-up-slow-swift-build-times-922feeba5780#.k0pngnkns)后，我发现用一个不同的角度去审视 Swift 代码并不是很难的一件事。\n\n可以被认为是简洁的一行代码现在引发了一个新的问题 -- 是否应该把这行代码重构成对应的9行代码以让编译器更容易工作（看看接下来要讲的关于空合运算符(nil coalescing operator)的示例）？到底哪个才是更重要的，简洁的代码还是对编译器友好的代码？这取决于项目的大小和开发者的想法。\n\n\n\n#### 慢着。。。这里有一个 Xcode 插件\n\n在展示具体的例子之前，我先想到就是手动查看日志是一件非常耗时的事情。有人提出了用终端命令可以让这件事情变得比较容易，但是我更进一步，把这个用 [Xcode 插件](https://github.com/RobertGummesson/BuildTimeAnalyzer-for-Xcode) 给实现出来了。\n\n![Xcode插件.png](http://upload-images.jianshu.io/upload_images/698554-be809654f87b2336.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n对我来说，最初的目的就是找到并修复最耗时的地方，但我现在的想法是让它经历更多的迭代过程。这样的话我就不仅可以让代码编译更有效率，还可以防止第一次进入项目的耗时。\n\n\n\n#### 更加惊喜的是\n\n我经常在多个 Git 分支间跳来跳去，等待一个缓慢的项目编译完成往往浪费了大量的时间。我想了好长一段时间为什么我的一个宠物项目会编译地这么缓慢（大概2万行 Swift 代码）。\n\n在我学习了究竟是原因导致的这件事之后，我不得不承认我的确很吃惊，一行代码就需要几秒钟来编译。\n\n让我们看看几个例子。\n\n\n\n#### 空合操作符\n\n编译器是很不喜欢这里的第一种方式的。在展开下面两处简写的代码之后，编译时间减少了99.4%。\n\n```swift\n// 编译时间: 5238.3ms\nreturn CGSize(width: size.width + (rightView?.bounds.width ?? 0) + (leftView?.bounds.width ?? 0) + 22, height: bounds.height)\n\n// 编译时间: 32.4ms\nvar padding: CGFloat = 22\nif let rightView = rightView {\n    padding += rightView.bounds.width\n}\n\nif let leftView = leftView {\n    padding += leftView.bounds.width\n}\nreturn CGSizeMake(size.width + padding, bounds.height)\n```\n\n\n\n#### ArrayOfStuff + [Stuff]\n\n这个看起来像下面这样：\n\n```swift\nreturn ArrayOfStuff + [Stuff]\n// 而不是\nArrayOfStuff.append(stuff)\nreturn ArrayOfStuff\n```\n\n\n\n我经常这样做，每次都会对所需的编译时间产生影响。下面是最差的一个，这里的编译时间减少了97.9％。\n\n```swift\n// 编译时间: 1250.3ms\nlet systemOptions = [ 7, 14, 30, -1 ]\nlet systemNames = (0...2).map{ String(format: localizedFormat, systemOptions[$0]) } + [NSLocalizedString(\"everything\", comment: \"\")]\n// 一些中间的代码\nlabelNames = Array(systemNames[0..<count]) + [systemNames.last!]\n\n// 编译时间: 25.5ms\nlet systemOptions = [ 7, 14, 30, -1 ]\nvar systemNames = systemOptions.dropLast().map{ String(format: localizedFormat, $0) }\nsystemNames.append(NSLocalizedString(\"everything\", comment: \"\"))\n// 一些中间的代码\nlabelNames = Array(systemNames[0..<count])\nlabelNames.append(systemNames.last!)\n```\n\n\n\n#### 三元运算符\n\n仅仅只是把三元运算符替换成 if-else 语句，就让编译时间减少了92.9%。如果将 map 换成 for 循环，就又能减少75%（但是那样的话我的眼睛可就受不了了）。😉\n\n```swift\n// 编译时间: 239.0ms\nlet labelNames = type == 0 ? (1...5).map{type0ToString($0)} : (0...2).map{type1ToString($0)}\n\n// 编译时间: 16.9ms\nvar labelNames: [String]\nif type == 0 {\n    labelNames = (1...5).map{type0ToString($0)}\n} else {\n    labelNames = (0...2).map{type1ToString($0)}\n}\n```\n\n\n\n#### 转换 CGFloat 到 CGFloat\n\n没听懂我在说什么？其实下面例子中值已经是 CGFloat 了，并且有些括号是多余的。在清理完这些冗余之后，编译时间减少了99.9%。\n\n```swift\n// 编译时间: 3431.7 ms\nreturn CGFloat(M_PI) * (CGFloat((hour + hourDelta + CGFloat(minute + minuteDelta) / 60) * 5) - 15) * unit / 180\n\n// 编译时间: 3.0ms\nreturn CGFloat(M_PI) * ((hour + hourDelta + (minute + minuteDelta) / 60) * 5 - 15) * unit / 180\n```\n\n\n\n#### Round()\n\n下面是一个很奇怪的例子，下面的例子中变量是一个局部变量与实例变量的混合。这个问题似乎不是出在四舍五入本身，而是在于结合代码的方法。去掉四舍五入的方法大概能减少 **97.6%** 的构建时间。\n\n```swift\n// 编译时间: 1433.7ms\nlet expansion = a — b — c + round(d * 0.66) + e\n// 编译时间: 34.7ms\nlet expansion = a — b — c + d * 0.66 + e\n```\n\n\n\n注意：以上所有测试都在MacBool Air(13英寸，2013年中)上进行。\n\n\n\n#### 尝试一下吧\n\n不管你是否面临过编译时间太长的问题，编写对编译器友好的代码都是非常有用的。我确信你会在其中找到一些惊喜。作为参考，这里有完整的代码，我的工程中可以5秒内完成编译…\n\n```swift\nimport UIKit\n\nclass CMExpandingTextField: UITextField {\n\n    func textFieldEditingChanged() {\n        invalidateIntrinsicContentSize()\n    }\n    \n    override func intrinsicContentSize() -> CGSize {\n        if isFirstResponder(), let text = text {\n            let size = text.sizeWithAttributes(typingAttributes)\n            return CGSize(width: size.width + (rightView?.bounds.width ?? 0) + (leftView?.bounds.width ?? 0) + 22, height: bounds.height)\n        }\n        return super.intrinsicContentSize()\n    }\n}\n```\n\n","source":"_posts/翻译关于Swift的编译时间优化.md","raw":"---\ntitle: (翻译)关于Swift的编译时间优化\ndate: 2017-10-22 21:39:50\ntags:\n- iOS\n- 翻译\ncategories:\n- ruanpapa--技术贴\n---\n\n\n\n原文链接：[Regarding Swift build time optimizations](https://medium.com/@RobertGummesson/regarding-swift-build-time-optimizations-fc92cdd91e31)\n\n\n\n上周，在我读完 [@nickoneill](https://medium.com/@nickoneill) 写的一篇优秀的博文[《为缓慢的Swift编译时间提速》](https://medium.com/swift-programming/speeding-up-slow-swift-build-times-922feeba5780#.k0pngnkns)后，我发现用一个不同的角度去审视 Swift 代码并不是很难的一件事。\n\n可以被认为是简洁的一行代码现在引发了一个新的问题 -- 是否应该把这行代码重构成对应的9行代码以让编译器更容易工作（看看接下来要讲的关于空合运算符(nil coalescing operator)的示例）？到底哪个才是更重要的，简洁的代码还是对编译器友好的代码？这取决于项目的大小和开发者的想法。\n\n\n\n#### 慢着。。。这里有一个 Xcode 插件\n\n在展示具体的例子之前，我先想到就是手动查看日志是一件非常耗时的事情。有人提出了用终端命令可以让这件事情变得比较容易，但是我更进一步，把这个用 [Xcode 插件](https://github.com/RobertGummesson/BuildTimeAnalyzer-for-Xcode) 给实现出来了。\n\n![Xcode插件.png](http://upload-images.jianshu.io/upload_images/698554-be809654f87b2336.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n对我来说，最初的目的就是找到并修复最耗时的地方，但我现在的想法是让它经历更多的迭代过程。这样的话我就不仅可以让代码编译更有效率，还可以防止第一次进入项目的耗时。\n\n\n\n#### 更加惊喜的是\n\n我经常在多个 Git 分支间跳来跳去，等待一个缓慢的项目编译完成往往浪费了大量的时间。我想了好长一段时间为什么我的一个宠物项目会编译地这么缓慢（大概2万行 Swift 代码）。\n\n在我学习了究竟是原因导致的这件事之后，我不得不承认我的确很吃惊，一行代码就需要几秒钟来编译。\n\n让我们看看几个例子。\n\n\n\n#### 空合操作符\n\n编译器是很不喜欢这里的第一种方式的。在展开下面两处简写的代码之后，编译时间减少了99.4%。\n\n```swift\n// 编译时间: 5238.3ms\nreturn CGSize(width: size.width + (rightView?.bounds.width ?? 0) + (leftView?.bounds.width ?? 0) + 22, height: bounds.height)\n\n// 编译时间: 32.4ms\nvar padding: CGFloat = 22\nif let rightView = rightView {\n    padding += rightView.bounds.width\n}\n\nif let leftView = leftView {\n    padding += leftView.bounds.width\n}\nreturn CGSizeMake(size.width + padding, bounds.height)\n```\n\n\n\n#### ArrayOfStuff + [Stuff]\n\n这个看起来像下面这样：\n\n```swift\nreturn ArrayOfStuff + [Stuff]\n// 而不是\nArrayOfStuff.append(stuff)\nreturn ArrayOfStuff\n```\n\n\n\n我经常这样做，每次都会对所需的编译时间产生影响。下面是最差的一个，这里的编译时间减少了97.9％。\n\n```swift\n// 编译时间: 1250.3ms\nlet systemOptions = [ 7, 14, 30, -1 ]\nlet systemNames = (0...2).map{ String(format: localizedFormat, systemOptions[$0]) } + [NSLocalizedString(\"everything\", comment: \"\")]\n// 一些中间的代码\nlabelNames = Array(systemNames[0..<count]) + [systemNames.last!]\n\n// 编译时间: 25.5ms\nlet systemOptions = [ 7, 14, 30, -1 ]\nvar systemNames = systemOptions.dropLast().map{ String(format: localizedFormat, $0) }\nsystemNames.append(NSLocalizedString(\"everything\", comment: \"\"))\n// 一些中间的代码\nlabelNames = Array(systemNames[0..<count])\nlabelNames.append(systemNames.last!)\n```\n\n\n\n#### 三元运算符\n\n仅仅只是把三元运算符替换成 if-else 语句，就让编译时间减少了92.9%。如果将 map 换成 for 循环，就又能减少75%（但是那样的话我的眼睛可就受不了了）。😉\n\n```swift\n// 编译时间: 239.0ms\nlet labelNames = type == 0 ? (1...5).map{type0ToString($0)} : (0...2).map{type1ToString($0)}\n\n// 编译时间: 16.9ms\nvar labelNames: [String]\nif type == 0 {\n    labelNames = (1...5).map{type0ToString($0)}\n} else {\n    labelNames = (0...2).map{type1ToString($0)}\n}\n```\n\n\n\n#### 转换 CGFloat 到 CGFloat\n\n没听懂我在说什么？其实下面例子中值已经是 CGFloat 了，并且有些括号是多余的。在清理完这些冗余之后，编译时间减少了99.9%。\n\n```swift\n// 编译时间: 3431.7 ms\nreturn CGFloat(M_PI) * (CGFloat((hour + hourDelta + CGFloat(minute + minuteDelta) / 60) * 5) - 15) * unit / 180\n\n// 编译时间: 3.0ms\nreturn CGFloat(M_PI) * ((hour + hourDelta + (minute + minuteDelta) / 60) * 5 - 15) * unit / 180\n```\n\n\n\n#### Round()\n\n下面是一个很奇怪的例子，下面的例子中变量是一个局部变量与实例变量的混合。这个问题似乎不是出在四舍五入本身，而是在于结合代码的方法。去掉四舍五入的方法大概能减少 **97.6%** 的构建时间。\n\n```swift\n// 编译时间: 1433.7ms\nlet expansion = a — b — c + round(d * 0.66) + e\n// 编译时间: 34.7ms\nlet expansion = a — b — c + d * 0.66 + e\n```\n\n\n\n注意：以上所有测试都在MacBool Air(13英寸，2013年中)上进行。\n\n\n\n#### 尝试一下吧\n\n不管你是否面临过编译时间太长的问题，编写对编译器友好的代码都是非常有用的。我确信你会在其中找到一些惊喜。作为参考，这里有完整的代码，我的工程中可以5秒内完成编译…\n\n```swift\nimport UIKit\n\nclass CMExpandingTextField: UITextField {\n\n    func textFieldEditingChanged() {\n        invalidateIntrinsicContentSize()\n    }\n    \n    override func intrinsicContentSize() -> CGSize {\n        if isFirstResponder(), let text = text {\n            let size = text.sizeWithAttributes(typingAttributes)\n            return CGSize(width: size.width + (rightView?.bounds.width ?? 0) + (leftView?.bounds.width ?? 0) + 22, height: bounds.height)\n        }\n        return super.intrinsicContentSize()\n    }\n}\n```\n\n","slug":"翻译关于Swift的编译时间优化","published":1,"updated":"2017-10-24T08:30:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg4j8w2q0020vfwxqtmbtpxd","content":"<p>原文链接：<a href=\"https://medium.com/@RobertGummesson/regarding-swift-build-time-optimizations-fc92cdd91e31\" target=\"_blank\" rel=\"external\">Regarding Swift build time optimizations</a></p>\n<p>上周，在我读完 <a href=\"https://medium.com/@nickoneill\" target=\"_blank\" rel=\"external\">@nickoneill</a> 写的一篇优秀的博文<a href=\"https://medium.com/swift-programming/speeding-up-slow-swift-build-times-922feeba5780#.k0pngnkns\" target=\"_blank\" rel=\"external\">《为缓慢的Swift编译时间提速》</a>后，我发现用一个不同的角度去审视 Swift 代码并不是很难的一件事。</p>\n<p>可以被认为是简洁的一行代码现在引发了一个新的问题 – 是否应该把这行代码重构成对应的9行代码以让编译器更容易工作（看看接下来要讲的关于空合运算符(nil coalescing operator)的示例）？到底哪个才是更重要的，简洁的代码还是对编译器友好的代码？这取决于项目的大小和开发者的想法。</p>\n<h4 id=\"慢着。。。这里有一个-Xcode-插件\"><a href=\"#慢着。。。这里有一个-Xcode-插件\" class=\"headerlink\" title=\"慢着。。。这里有一个 Xcode 插件\"></a>慢着。。。这里有一个 Xcode 插件</h4><p>在展示具体的例子之前，我先想到就是手动查看日志是一件非常耗时的事情。有人提出了用终端命令可以让这件事情变得比较容易，但是我更进一步，把这个用 <a href=\"https://github.com/RobertGummesson/BuildTimeAnalyzer-for-Xcode\" target=\"_blank\" rel=\"external\">Xcode 插件</a> 给实现出来了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-be809654f87b2336.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Xcode插件.png\"></p>\n<p>对我来说，最初的目的就是找到并修复最耗时的地方，但我现在的想法是让它经历更多的迭代过程。这样的话我就不仅可以让代码编译更有效率，还可以防止第一次进入项目的耗时。</p>\n<h4 id=\"更加惊喜的是\"><a href=\"#更加惊喜的是\" class=\"headerlink\" title=\"更加惊喜的是\"></a>更加惊喜的是</h4><p>我经常在多个 Git 分支间跳来跳去，等待一个缓慢的项目编译完成往往浪费了大量的时间。我想了好长一段时间为什么我的一个宠物项目会编译地这么缓慢（大概2万行 Swift 代码）。</p>\n<p>在我学习了究竟是原因导致的这件事之后，我不得不承认我的确很吃惊，一行代码就需要几秒钟来编译。</p>\n<p>让我们看看几个例子。</p>\n<h4 id=\"空合操作符\"><a href=\"#空合操作符\" class=\"headerlink\" title=\"空合操作符\"></a>空合操作符</h4><p>编译器是很不喜欢这里的第一种方式的。在展开下面两处简写的代码之后，编译时间减少了99.4%。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 编译时间: 5238.3ms</span></div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"type\">CGSize</span>(width: size.width + (rightView?.bounds.width ?? <span class=\"number\">0</span>) + (leftView?.bounds.width ?? <span class=\"number\">0</span>) + <span class=\"number\">22</span>, height: bounds.height)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 编译时间: 32.4ms</span></div><div class=\"line\"><span class=\"keyword\">var</span> padding: <span class=\"type\">CGFloat</span> = <span class=\"number\">22</span></div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> rightView = rightView &#123;</div><div class=\"line\">    padding += rightView.bounds.width</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> leftView = leftView &#123;</div><div class=\"line\">    padding += leftView.bounds.width</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"type\">CGSizeMake</span>(size.width + padding, bounds.height)</div></pre></td></tr></table></figure>\n<h4 id=\"ArrayOfStuff-Stuff\"><a href=\"#ArrayOfStuff-Stuff\" class=\"headerlink\" title=\"ArrayOfStuff + [Stuff]\"></a>ArrayOfStuff + [Stuff]</h4><p>这个看起来像下面这样：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"type\">ArrayOfStuff</span> + [<span class=\"type\">Stuff</span>]</div><div class=\"line\"><span class=\"comment\">// 而不是</span></div><div class=\"line\"><span class=\"type\">ArrayOfStuff</span>.append(stuff)</div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"type\">ArrayOfStuff</span></div></pre></td></tr></table></figure>\n<p>我经常这样做，每次都会对所需的编译时间产生影响。下面是最差的一个，这里的编译时间减少了97.9％。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 编译时间: 1250.3ms</span></div><div class=\"line\"><span class=\"keyword\">let</span> systemOptions = [ <span class=\"number\">7</span>, <span class=\"number\">14</span>, <span class=\"number\">30</span>, -<span class=\"number\">1</span> ]</div><div class=\"line\"><span class=\"keyword\">let</span> systemNames = (<span class=\"number\">0</span>...<span class=\"number\">2</span>).<span class=\"built_in\">map</span>&#123; <span class=\"type\">String</span>(format: localizedFormat, systemOptions[$<span class=\"number\">0</span>]) &#125; + [<span class=\"type\">NSLocalizedString</span>(<span class=\"string\">\"everything\"</span>, comment: <span class=\"string\">\"\"</span>)]</div><div class=\"line\"><span class=\"comment\">// 一些中间的代码</span></div><div class=\"line\">labelNames = <span class=\"type\">Array</span>(systemNames[<span class=\"number\">0</span>..&lt;<span class=\"built_in\">count</span>]) + [systemNames.last!]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 编译时间: 25.5ms</span></div><div class=\"line\"><span class=\"keyword\">let</span> systemOptions = [ <span class=\"number\">7</span>, <span class=\"number\">14</span>, <span class=\"number\">30</span>, -<span class=\"number\">1</span> ]</div><div class=\"line\"><span class=\"keyword\">var</span> systemNames = systemOptions.<span class=\"built_in\">dropLast</span>().<span class=\"built_in\">map</span>&#123; <span class=\"type\">String</span>(format: localizedFormat, $<span class=\"number\">0</span>) &#125;</div><div class=\"line\">systemNames.append(<span class=\"type\">NSLocalizedString</span>(<span class=\"string\">\"everything\"</span>, comment: <span class=\"string\">\"\"</span>))</div><div class=\"line\"><span class=\"comment\">// 一些中间的代码</span></div><div class=\"line\">labelNames = <span class=\"type\">Array</span>(systemNames[<span class=\"number\">0</span>..&lt;<span class=\"built_in\">count</span>])</div><div class=\"line\">labelNames.append(systemNames.last!)</div></pre></td></tr></table></figure>\n<h4 id=\"三元运算符\"><a href=\"#三元运算符\" class=\"headerlink\" title=\"三元运算符\"></a>三元运算符</h4><p>仅仅只是把三元运算符替换成 if-else 语句，就让编译时间减少了92.9%。如果将 map 换成 for 循环，就又能减少75%（但是那样的话我的眼睛可就受不了了）。😉</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 编译时间: 239.0ms</span></div><div class=\"line\"><span class=\"keyword\">let</span> labelNames = type == <span class=\"number\">0</span> ? (<span class=\"number\">1</span>...<span class=\"number\">5</span>).<span class=\"built_in\">map</span>&#123;type0ToString($<span class=\"number\">0</span>)&#125; : (<span class=\"number\">0</span>...<span class=\"number\">2</span>).<span class=\"built_in\">map</span>&#123;type1ToString($<span class=\"number\">0</span>)&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 编译时间: 16.9ms</span></div><div class=\"line\"><span class=\"keyword\">var</span> labelNames: [<span class=\"type\">String</span>]</div><div class=\"line\"><span class=\"keyword\">if</span> type == <span class=\"number\">0</span> &#123;</div><div class=\"line\">    labelNames = (<span class=\"number\">1</span>...<span class=\"number\">5</span>).<span class=\"built_in\">map</span>&#123;type0ToString($<span class=\"number\">0</span>)&#125;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    labelNames = (<span class=\"number\">0</span>...<span class=\"number\">2</span>).<span class=\"built_in\">map</span>&#123;type1ToString($<span class=\"number\">0</span>)&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"转换-CGFloat-到-CGFloat\"><a href=\"#转换-CGFloat-到-CGFloat\" class=\"headerlink\" title=\"转换 CGFloat 到 CGFloat\"></a>转换 CGFloat 到 CGFloat</h4><p>没听懂我在说什么？其实下面例子中值已经是 CGFloat 了，并且有些括号是多余的。在清理完这些冗余之后，编译时间减少了99.9%。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 编译时间: 3431.7 ms</span></div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"type\">CGFloat</span>(<span class=\"type\">M_PI</span>) * (<span class=\"type\">CGFloat</span>((hour + hourDelta + <span class=\"type\">CGFloat</span>(minute + minuteDelta) / <span class=\"number\">60</span>) * <span class=\"number\">5</span>) - <span class=\"number\">15</span>) * unit / <span class=\"number\">180</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 编译时间: 3.0ms</span></div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"type\">CGFloat</span>(<span class=\"type\">M_PI</span>) * ((hour + hourDelta + (minute + minuteDelta) / <span class=\"number\">60</span>) * <span class=\"number\">5</span> - <span class=\"number\">15</span>) * unit / <span class=\"number\">180</span></div></pre></td></tr></table></figure>\n<h4 id=\"Round\"><a href=\"#Round\" class=\"headerlink\" title=\"Round()\"></a>Round()</h4><p>下面是一个很奇怪的例子，下面的例子中变量是一个局部变量与实例变量的混合。这个问题似乎不是出在四舍五入本身，而是在于结合代码的方法。去掉四舍五入的方法大概能减少 <strong>97.6%</strong> 的构建时间。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 编译时间: 1433.7ms</span></div><div class=\"line\"><span class=\"keyword\">let</span> expansion = a — b — <span class=\"built_in\">c</span> + round(d * <span class=\"number\">0.66</span>) + e</div><div class=\"line\"><span class=\"comment\">// 编译时间: 34.7ms</span></div><div class=\"line\"><span class=\"keyword\">let</span> expansion = a — b — <span class=\"built_in\">c</span> + d * <span class=\"number\">0.66</span> + e</div></pre></td></tr></table></figure>\n<p>注意：以上所有测试都在MacBool Air(13英寸，2013年中)上进行。</p>\n<h4 id=\"尝试一下吧\"><a href=\"#尝试一下吧\" class=\"headerlink\" title=\"尝试一下吧\"></a>尝试一下吧</h4><p>不管你是否面临过编译时间太长的问题，编写对编译器友好的代码都是非常有用的。我确信你会在其中找到一些惊喜。作为参考，这里有完整的代码，我的工程中可以5秒内完成编译…</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> UIKit</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CMExpandingTextField</span>: <span class=\"title\">UITextField</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">textFieldEditingChanged</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        invalidateIntrinsicContentSize()</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">intrinsicContentSize</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">CGSize</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> isFirstResponder(), <span class=\"keyword\">let</span> text = text &#123;</div><div class=\"line\">            <span class=\"keyword\">let</span> size = text.sizeWithAttributes(typingAttributes)</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"type\">CGSize</span>(width: size.width + (rightView?.bounds.width ?? <span class=\"number\">0</span>) + (leftView?.bounds.width ?? <span class=\"number\">0</span>) + <span class=\"number\">22</span>, height: bounds.height)</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.intrinsicContentSize()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>原文链接：<a href=\"https://medium.com/@RobertGummesson/regarding-swift-build-time-optimizations-fc92cdd91e31\">Regarding Swift build time optimizations</a></p>\n<p>上周，在我读完 <a href=\"https://medium.com/@nickoneill\">@nickoneill</a> 写的一篇优秀的博文<a href=\"https://medium.com/swift-programming/speeding-up-slow-swift-build-times-922feeba5780#.k0pngnkns\">《为缓慢的Swift编译时间提速》</a>后，我发现用一个不同的角度去审视 Swift 代码并不是很难的一件事。</p>\n<p>可以被认为是简洁的一行代码现在引发了一个新的问题 – 是否应该把这行代码重构成对应的9行代码以让编译器更容易工作（看看接下来要讲的关于空合运算符(nil coalescing operator)的示例）？到底哪个才是更重要的，简洁的代码还是对编译器友好的代码？这取决于项目的大小和开发者的想法。</p>\n<h4 id=\"慢着。。。这里有一个-Xcode-插件\"><a href=\"#慢着。。。这里有一个-Xcode-插件\" class=\"headerlink\" title=\"慢着。。。这里有一个 Xcode 插件\"></a>慢着。。。这里有一个 Xcode 插件</h4><p>在展示具体的例子之前，我先想到就是手动查看日志是一件非常耗时的事情。有人提出了用终端命令可以让这件事情变得比较容易，但是我更进一步，把这个用 <a href=\"https://github.com/RobertGummesson/BuildTimeAnalyzer-for-Xcode\">Xcode 插件</a> 给实现出来了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-be809654f87b2336.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Xcode插件.png\"></p>\n<p>对我来说，最初的目的就是找到并修复最耗时的地方，但我现在的想法是让它经历更多的迭代过程。这样的话我就不仅可以让代码编译更有效率，还可以防止第一次进入项目的耗时。</p>\n<h4 id=\"更加惊喜的是\"><a href=\"#更加惊喜的是\" class=\"headerlink\" title=\"更加惊喜的是\"></a>更加惊喜的是</h4><p>我经常在多个 Git 分支间跳来跳去，等待一个缓慢的项目编译完成往往浪费了大量的时间。我想了好长一段时间为什么我的一个宠物项目会编译地这么缓慢（大概2万行 Swift 代码）。</p>\n<p>在我学习了究竟是原因导致的这件事之后，我不得不承认我的确很吃惊，一行代码就需要几秒钟来编译。</p>\n<p>让我们看看几个例子。</p>\n<h4 id=\"空合操作符\"><a href=\"#空合操作符\" class=\"headerlink\" title=\"空合操作符\"></a>空合操作符</h4><p>编译器是很不喜欢这里的第一种方式的。在展开下面两处简写的代码之后，编译时间减少了99.4%。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 编译时间: 5238.3ms</span></div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"type\">CGSize</span>(width: size.width + (rightView?.bounds.width ?? <span class=\"number\">0</span>) + (leftView?.bounds.width ?? <span class=\"number\">0</span>) + <span class=\"number\">22</span>, height: bounds.height)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 编译时间: 32.4ms</span></div><div class=\"line\"><span class=\"keyword\">var</span> padding: <span class=\"type\">CGFloat</span> = <span class=\"number\">22</span></div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> rightView = rightView &#123;</div><div class=\"line\">    padding += rightView.bounds.width</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> leftView = leftView &#123;</div><div class=\"line\">    padding += leftView.bounds.width</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"type\">CGSizeMake</span>(size.width + padding, bounds.height)</div></pre></td></tr></table></figure>\n<h4 id=\"ArrayOfStuff-Stuff\"><a href=\"#ArrayOfStuff-Stuff\" class=\"headerlink\" title=\"ArrayOfStuff + [Stuff]\"></a>ArrayOfStuff + [Stuff]</h4><p>这个看起来像下面这样：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"type\">ArrayOfStuff</span> + [<span class=\"type\">Stuff</span>]</div><div class=\"line\"><span class=\"comment\">// 而不是</span></div><div class=\"line\"><span class=\"type\">ArrayOfStuff</span>.append(stuff)</div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"type\">ArrayOfStuff</span></div></pre></td></tr></table></figure>\n<p>我经常这样做，每次都会对所需的编译时间产生影响。下面是最差的一个，这里的编译时间减少了97.9％。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 编译时间: 1250.3ms</span></div><div class=\"line\"><span class=\"keyword\">let</span> systemOptions = [ <span class=\"number\">7</span>, <span class=\"number\">14</span>, <span class=\"number\">30</span>, -<span class=\"number\">1</span> ]</div><div class=\"line\"><span class=\"keyword\">let</span> systemNames = (<span class=\"number\">0</span>...<span class=\"number\">2</span>).<span class=\"built_in\">map</span>&#123; <span class=\"type\">String</span>(format: localizedFormat, systemOptions[$<span class=\"number\">0</span>]) &#125; + [<span class=\"type\">NSLocalizedString</span>(<span class=\"string\">\"everything\"</span>, comment: <span class=\"string\">\"\"</span>)]</div><div class=\"line\"><span class=\"comment\">// 一些中间的代码</span></div><div class=\"line\">labelNames = <span class=\"type\">Array</span>(systemNames[<span class=\"number\">0</span>..&lt;<span class=\"built_in\">count</span>]) + [systemNames.last!]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 编译时间: 25.5ms</span></div><div class=\"line\"><span class=\"keyword\">let</span> systemOptions = [ <span class=\"number\">7</span>, <span class=\"number\">14</span>, <span class=\"number\">30</span>, -<span class=\"number\">1</span> ]</div><div class=\"line\"><span class=\"keyword\">var</span> systemNames = systemOptions.<span class=\"built_in\">dropLast</span>().<span class=\"built_in\">map</span>&#123; <span class=\"type\">String</span>(format: localizedFormat, $<span class=\"number\">0</span>) &#125;</div><div class=\"line\">systemNames.append(<span class=\"type\">NSLocalizedString</span>(<span class=\"string\">\"everything\"</span>, comment: <span class=\"string\">\"\"</span>))</div><div class=\"line\"><span class=\"comment\">// 一些中间的代码</span></div><div class=\"line\">labelNames = <span class=\"type\">Array</span>(systemNames[<span class=\"number\">0</span>..&lt;<span class=\"built_in\">count</span>])</div><div class=\"line\">labelNames.append(systemNames.last!)</div></pre></td></tr></table></figure>\n<h4 id=\"三元运算符\"><a href=\"#三元运算符\" class=\"headerlink\" title=\"三元运算符\"></a>三元运算符</h4><p>仅仅只是把三元运算符替换成 if-else 语句，就让编译时间减少了92.9%。如果将 map 换成 for 循环，就又能减少75%（但是那样的话我的眼睛可就受不了了）。😉</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 编译时间: 239.0ms</span></div><div class=\"line\"><span class=\"keyword\">let</span> labelNames = type == <span class=\"number\">0</span> ? (<span class=\"number\">1</span>...<span class=\"number\">5</span>).<span class=\"built_in\">map</span>&#123;type0ToString($<span class=\"number\">0</span>)&#125; : (<span class=\"number\">0</span>...<span class=\"number\">2</span>).<span class=\"built_in\">map</span>&#123;type1ToString($<span class=\"number\">0</span>)&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 编译时间: 16.9ms</span></div><div class=\"line\"><span class=\"keyword\">var</span> labelNames: [<span class=\"type\">String</span>]</div><div class=\"line\"><span class=\"keyword\">if</span> type == <span class=\"number\">0</span> &#123;</div><div class=\"line\">    labelNames = (<span class=\"number\">1</span>...<span class=\"number\">5</span>).<span class=\"built_in\">map</span>&#123;type0ToString($<span class=\"number\">0</span>)&#125;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    labelNames = (<span class=\"number\">0</span>...<span class=\"number\">2</span>).<span class=\"built_in\">map</span>&#123;type1ToString($<span class=\"number\">0</span>)&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"转换-CGFloat-到-CGFloat\"><a href=\"#转换-CGFloat-到-CGFloat\" class=\"headerlink\" title=\"转换 CGFloat 到 CGFloat\"></a>转换 CGFloat 到 CGFloat</h4><p>没听懂我在说什么？其实下面例子中值已经是 CGFloat 了，并且有些括号是多余的。在清理完这些冗余之后，编译时间减少了99.9%。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 编译时间: 3431.7 ms</span></div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"type\">CGFloat</span>(<span class=\"type\">M_PI</span>) * (<span class=\"type\">CGFloat</span>((hour + hourDelta + <span class=\"type\">CGFloat</span>(minute + minuteDelta) / <span class=\"number\">60</span>) * <span class=\"number\">5</span>) - <span class=\"number\">15</span>) * unit / <span class=\"number\">180</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 编译时间: 3.0ms</span></div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"type\">CGFloat</span>(<span class=\"type\">M_PI</span>) * ((hour + hourDelta + (minute + minuteDelta) / <span class=\"number\">60</span>) * <span class=\"number\">5</span> - <span class=\"number\">15</span>) * unit / <span class=\"number\">180</span></div></pre></td></tr></table></figure>\n<h4 id=\"Round\"><a href=\"#Round\" class=\"headerlink\" title=\"Round()\"></a>Round()</h4><p>下面是一个很奇怪的例子，下面的例子中变量是一个局部变量与实例变量的混合。这个问题似乎不是出在四舍五入本身，而是在于结合代码的方法。去掉四舍五入的方法大概能减少 <strong>97.6%</strong> 的构建时间。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 编译时间: 1433.7ms</span></div><div class=\"line\"><span class=\"keyword\">let</span> expansion = a — b — <span class=\"built_in\">c</span> + round(d * <span class=\"number\">0.66</span>) + e</div><div class=\"line\"><span class=\"comment\">// 编译时间: 34.7ms</span></div><div class=\"line\"><span class=\"keyword\">let</span> expansion = a — b — <span class=\"built_in\">c</span> + d * <span class=\"number\">0.66</span> + e</div></pre></td></tr></table></figure>\n<p>注意：以上所有测试都在MacBool Air(13英寸，2013年中)上进行。</p>\n<h4 id=\"尝试一下吧\"><a href=\"#尝试一下吧\" class=\"headerlink\" title=\"尝试一下吧\"></a>尝试一下吧</h4><p>不管你是否面临过编译时间太长的问题，编写对编译器友好的代码都是非常有用的。我确信你会在其中找到一些惊喜。作为参考，这里有完整的代码，我的工程中可以5秒内完成编译…</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> UIKit</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CMExpandingTextField</span>: <span class=\"title\">UITextField</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">textFieldEditingChanged</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        invalidateIntrinsicContentSize()</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">intrinsicContentSize</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">CGSize</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> isFirstResponder(), <span class=\"keyword\">let</span> text = text &#123;</div><div class=\"line\">            <span class=\"keyword\">let</span> size = text.sizeWithAttributes(typingAttributes)</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"type\">CGSize</span>(width: size.width + (rightView?.bounds.width ?? <span class=\"number\">0</span>) + (leftView?.bounds.width ?? <span class=\"number\">0</span>) + <span class=\"number\">22</span>, height: bounds.height)</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.intrinsicContentSize()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"(翻译)用 LLDB 调试 Swift 代码","date":"2018-02-06T06:41:38.000Z","_content":"\n> * 原文地址：[Debugging Swift code with LLDB](https://medium.com/flawless-app-stories/debugging-swift-code-with-lldb-b30c5cf2fd49)\n> * 原文作者：[Ahmed Sulaiman](https://medium.com/@ahmedsulaiman?source=post_header_lockup)\n\n# 用 LLDB 调试 Swift 代码\n\n![](http://upload-images.jianshu.io/upload_images/698554-035b0df85ea54d32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n作为工程师，我们花了差不多 70% 的时间在调试上，剩下的 20% 用来思考架构以及和组员沟通，仅仅只有 10% 的时间是真的在写代码的。\n\n> 调试就像是在犯罪电影中做侦探一样，同时你也是凶手。\n>\n> — [Filipe Fortes](https://twitter.com/fortes) 来自 Twitter\n\n所以让我们在这70%的时间尽可能愉悦是相当重要的。LLDB 就是来打救我们的。奇妙的 Xcode Debugger UI 展示了所有你可用的信息，而不用敲入任何一个 LLDB 命令。然而，控制台在我们的工作中同样也是很重要的一部分。现在让我们来分析一些最有用的 LLDB 技巧。我自己每天都在用它们进行调试。\n\n\n\n### 从哪里开始呢？\n\nLLDB 是一个庞大的工具，内置了很多有用的命令。我不会全部讲解，而是带你浏览最有用的命令。这是我们的计划：\n\n1. 获取变量值： `expression`, `e`, `print`, `po`, `p`\n2. 获取整个应用程序的状态以及特定语言的命令：`bugreport`, `frame`, `language`\n3. 控制应用的执行流程：`process`, `breakpoint`, `thread`, `watchpoint`\n4. 荣誉奖：`command`, `platform`, `gui`\n\n我还准备好了有用的 LLDB 命令说明和实例的表格，有需要的可以把它贴在 Mac 上面记住这些命令 🙂\n\n![](http://upload-images.jianshu.io/upload_images/698554-4425e8ad483d1e91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n通过这条链接下载全尺寸的版本 —  [https://www.dropbox.com/s/9sv67e7f2repbpb/lldb-commands-map.png?dl=0](https://www.dropbox.com/s/9sv67e7f2repbpb/lldb-commands-map.png?dl=0)\n\n\n\n### 1. 获取变量值和状态\n\n命令：`expression`, `e`, `print`, `po`, `p`\n\n![](http://upload-images.jianshu.io/upload_images/698554-28e3583bcef761ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n调试器的一个基础功能就是获取和修改变量的值。这就是 `expression` 或者 `e` 被创造的原因（当然他们还有更高级的功能）。您可以简单的在运行时执行任何表达式或命令。\n\n假设你现在正在调试方法 `valueOfLifeWithoutSumOf()` ：对两个数求和，再用42去减得到结果。\n\n![](http://upload-images.jianshu.io/upload_images/698554-f788753308492216.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n继续假设你一直得到错误的结果并且你并不知道是什么原因。所以你可以做以下的事来找到问题：\n\n![](http://upload-images.jianshu.io/upload_images/698554-ca27db839bd80a19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n或者。。。使用 LLDB 表达式在运行时修改值才是更好的方法，同时可以找出问题是在哪里出现的。首先，在你感兴趣的地方设置一个断点，然后运行你的应用。\n\n为了用 LLDB 格式打印指定的变量你应该调用：\n\n```\n(lldb) e <variable>\n```\n\n使用相同的命令来执行一些表达式：\n\n```\n(lldb) e <expression>\n```\n\n![](http://upload-images.jianshu.io/upload_images/698554-42790260c5498fe3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n```\n(lldb) e sum \n(Int) $R0 = 6 // 下面你也可以用 $R0 来引用这个变量（在本次调试过程中）\n\n(lldb) e sum = 4 // 修改变量 sum 的值\n\n(lldb) e sum \n(Int) $R2 = 4 // 直到本次调试结束变量 sum 都会是 \"4\" \n```\n\n`expression` 命令也有一些标志。在 `expression` 后面用双破折号 `--` 将标志和实际的表达式分隔开，就像这样：\n\n```\n(lldb) expression <some flags> -- <variable>\n```\n\n`expression` 命令差不多有30种不同的标志。我鼓励你多去探索它们。在终端中键入以下命令可以看到完整的文档：\n\n```\n> lldb\n> (lldb) help # 获取所有变量的命令\n> (lldb) help expression # 获取所有表达式的子命令\n```\n\n我会在下列 `expression` 的标志上多停留一会儿：\n\n- `-D <count>` (`--depth <count>`)  — 设置在转储聚合类型时的最大递归深度（默认为无穷大）。\n- `-O` (`--object-description`)  — 如果可能的话，使用指定语言的描述API来显示。\n- `-T` (`--show-types`)  — 在转储值的时候显示变量类型。\n- `-f <format>` (`--format <format>`) — 指定一种用于显示的格式。\n- `-i <boolean>` (`--ignore-breakpoints <boolean>`) — 在运行表达式时忽略断点。\n\n假设我们有一个叫 `logger` 的对象，这个对象有一些字符串和结构体类型的属性。比如说，你可能只是想知道第一层的属性，那只需要用 `-D` 标志以及恰当的层级深度值，就像这样：\n\n```\n(lldb) e -D 1 -- logger\n\n(LLDB_Debugger_Exploration.Logger) $R5 = 0x0000608000087e90 {\n  currentClassName = \"ViewController\"\n  debuggerStruct ={...}\n}\n```\n\n默认情况下，LLDB 会无限地遍历该对象并且给你展示每个嵌套的对象的完整描述：\n\n```\n(lldb) e -- logger\n\n(LLDB_Debugger_Exploration.Logger) $R6 = 0x0000608000087e90 {\n  currentClassName = \"ViewController\"\n  debuggerStruct = (methodName = \"name\", lineNumber = 2, commandCounter = 23)\n}\n```\n\n你也可以用 `e -O --` 获取对象的描述或者更简单地用别名 `po`，就像下面的示例一样：\n\n```\n(lldb) po logger\n\n<Logger: 0x608000087e90>\n```\n\n并不是很有描述性，不是吗？为了获取更加可阅读的描述，你自定义的类必须遵循 `CustomStringConvertible` 协议，同时实现 `var description: String { return ...}` 属性。接下来只需要用 `po` 就能返回可读的描述。\n\n![](http://upload-images.jianshu.io/upload_images/698554-67b11fbfba92f9c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n在本节的开始，我也提到了 `print` 命令。基本上 `print <expression/variable>` 就等同于 `expression -- <expression/variable>`。但是 `print` 命令不能带任何标志或者额外的参数。\n\n\n\n### 2. 获取整个 APP 的状态和指定语言的命令\n\n`bugreport`, `frame`, `language`\n\n![](http://upload-images.jianshu.io/upload_images/698554-b6780919d5f067a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n你是否经常复制粘贴崩溃日志到任务管理器中方便稍后能考虑这个问题吗？LLDB 提供了一个很好用的命令叫 `bugreport`，这个命令能生成当前应用状态的完整报告。在你偶然触发某些问题但是想在稍后再解决它时这个命令就会很有帮助了。为了能恢复应用的状态，你可以使用 `bugreport` 生成报告。 \n\n```\n(lldb) bugreport unwind --outfile <path to output file>\n```\n\n最终的报告看起来就像下面截图中的例子一样：\n\n![](http://upload-images.jianshu.io/upload_images/698554-f8a7604c35151d5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n`bugreport` 命令输出的示例。\n\n\n![](http://upload-images.jianshu.io/upload_images/698554-2179c17fefec7742.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n假设你想要获取当前线程的当前栈帧的概述，`frame` 命令可以帮你完成：\n\n![](http://upload-images.jianshu.io/upload_images/698554-5207a680ff245ddf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n使用下面的代码片段来快速获取当前地址以及当前的环境条件：\n\n```\n(lldb) frame info\n\nframe #0: 0x000000010bbe4b4d LLDB-Debugger-Exploration`ViewController.valueOfLifeWithoutSumOf(a=2, b=2, self=0x00007fa0c1406900) -> Int at ViewController.swift:96\n```\n\n这些信息在本文后面将要说到的断点管理中非常有用。\n\n![](http://upload-images.jianshu.io/upload_images/698554-2b16ad60aed4e6af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\nLLDB 有几个指定语言的命令，包括C++，Objective-C，Swift 和 RenderScript。在这篇文章中，我们重点关注 Swift。这是两个命令：`demangle` 和 `refcount`。\n\n`demangle` 正如其名字而言，就是用来重组 Swift 类型名的（因为 Swift 在编译的时候会生成类型名来避免命名空间的问题）。如果你想了解多一点的话，我建议你看 WWDC14 的这个分享会 —  [“Advanced Swift Debugging in LLDB”](https://developer.apple.com/videos/play/wwdc2014/410/)。\n\n`refcount` 同样也是一个相当直观的命令，能获得指定对象的引用数量。一起来看一下对象输出的示例，我们用了上一节讲到的对象 — `logger`：\n\n```\n(lldb) language swift refcount logger\n\nrefcount data: (strong = 4, weak = 0)\n```\n\n当然了，在你调试某些内存泄露问题时，这个命令就会很有帮助。\n\n\n\n### 3. 控制应用的执行流程\n\n`process`, `breakpoint`, `thread`\n\n这节是我最喜欢的一节，因为在 LLDB 使用这几个命令（尤其是 `breakpoint` 命令），你可以在调试的时候使很多常规任务变得自动化，这样就能大大加快你的调试工作。\n\n![](http://upload-images.jianshu.io/upload_images/698554-190d8c7f7600ae0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n通过 `process` 基本上你就可以控制调试的过程了，还能链接到特定的 target 或者停止调试器。 但是因为 Xcode 已经自动地帮我们做好了这个工作了（Xcode 在任何时候运行一个 target 时都会连接 LLDB）。我不会在这儿讲太多，你可以在这篇 Apple 的指南中阅读一下如何用终端连接到一个 target — [“Using LLDB as a Standalone Debugger”](https://developer.apple.com/library/content/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-terminal-workflow-tutorial.html)。\n\n使用 `process status` 的话，你可以知道当前调试器停住的地址：\n\n```\n(lldb) process status\n\nProcess 27408 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = step over\nframe #0: 0x000000010bbe4889 LLDB-Debugger-Exploration`ViewController.viewDidLoad(self=0x00007fa0c1406900) -> () at ViewController.swift:69\n66\n67           let a = 2, b = 2\n68           let result = valueOfLifeWithoutSumOf(a, and: b)\n-> 69           print(result)\n70\n71\n72\n```\n\n想要继续 target 的执行过程直到遇到下次断点的话，运行这个命令：\n\n```\n(lldb) process continue\n\n(lldb) c // 或者只键入 \"c\"，这跟上一条命令是一样的\n```\n\n这个命令等同于 Xcode 调试器工具栏上的”continue“按钮：\n\n![](http://upload-images.jianshu.io/upload_images/698554-8d3a7affc384f574.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![](http://upload-images.jianshu.io/upload_images/698554-779f316d847a475c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n`breakpoint` 命令允许你用任何可能的方式操作断点。我们跳过最显而易见的命令：`breakpoint enable`, `breakpoint disable` 和 `breakpoint delete`。\n\n首先，查看你所有断点的话可以用如下示例中的 `list` 子命令：\n\n```\n(lldb) breakpoint list\n\nCurrent breakpoints:\n1: file = '/Users/Ahmed/Desktop/Recent/LLDB-Debugger-Exploration/LLDB-Debugger-Exploration/ViewController.swift', line = 95, exact_match = 0, locations = 1, resolved = 1, hit count = 1\n\n1.1: where = LLDB-Debugger-Exploration`LLDB_Debugger_Exploration.ViewController.valueOfLifeWithoutSumOf (Swift.Int, and : Swift.Int) -> Swift.Int + 27 at ViewController.swift:95, address = 0x0000000107f3eb3b, resolved, hit count = 1\n\n2: file = '/Users/Ahmed/Desktop/Recent/LLDB-Debugger-Exploration/LLDB-Debugger-Exploration/ViewController.swift', line = 60, exact_match = 0, locations = 1, resolved = 1, hit count = 1\n\n2.1: where = LLDB-Debugger-Exploration`LLDB_Debugger_Exploration.ViewController.viewDidLoad () -> () + 521 at ViewController.swift:60, address = 0x0000000107f3e609, resolved, hit count = 1\n```\n\n列表中的第一个数字是是断点的 ID，你可以通过这个 ID 引用到指定的断点。现在让我们在控制台中设置一些新的断点：\n\n```\n(lldb) breakpoint set -f ViewController.swift -l 96\n\nBreakpoint 3: where = LLDB-Debugger-Exploration`LLDB_Debugger_Exploration.ViewController.valueOfLifeWithoutSumOf (Swift.Int, and : Swift.Int) -> Swift.Int + 45 at ViewController.swift:96, address = 0x0000000107f3eb4d\n```\n\n这个例子中的 `-f` 是你想要放置断点处的文件名，`-l` 是新断点的行数。还有一种更简洁的方式设置同样的断点，就是用快捷方式 `b`：\n\n```\n(lldb) b ViewController.swift:96\n```\n\n同样地，你也可以用指定的正则（比如函数名）来设置断点，使用下面的命令：\n\n```\n(lldb) breakpoint set --func-regex valueOfLifeWithoutSumOf\n\n(lldb) b -r valueOfLifeWithoutSumOf // 上一条命令的简化版本\n```\n\n有些时候设置断点只命中一次也是有用的，然后指示这个断点立即删除自己，当然啦，有一个命令来处理这件事：\n\n```\n(lldb) breakpoint set --one-shot -f ViewController.swift -l 90\n\n(lldb) br s -o -f ViewController.swift -l 91 // 上一条命令的简化版本\n```\n\n现在我们来到了最有趣的部分 — 自动化断点。你知道你可以设置一个特定的动作使它在断点停住的时候执行吗？是的，你可以！你是否会在代码中用 `print()` 来在调试的时候得到你感兴趣的值？请不要再这样做了，这里有一种更好的方法。🙂\n\n通过 `breakpoint` 命令，你可以设置好命令，使其在断点命中时可以正确执行。你甚至可以设置”不可见“的断点，这种断点并不会打断运行过程。从技术上讲，这些“不可见的”断点其实是会中断执行的，但如果在命令链的末尾添上“continue”命令的话，你就不会注意到它。\n\n```\n(lldb) b ViewController.swift:96 // Let's add a breakpoint first\n\nBreakpoint 2: where = LLDB-Debugger-Exploration`LLDB_Debugger_Exploration.ViewController.valueOfLifeWithoutSumOf (Swift.Int, and : Swift.Int) -> Swift.Int + 45 at ViewController.swift:96, address = 0x000000010c555b4d\n\n(lldb) breakpoint command add 2 // 准备某些命令\n\nEnter your debugger command(s).  Type 'DONE' to end.\n> p sum // 打印变量 \"sum\" 的值\n> p a + b // 运行 a + b\n> DONE\n```\n\n为了确保你添加的命令是正确的，可以使用  `breakpoint command list <breakpoint id>` 子命令：\n\n```\n(lldb) breakpoint command list 2\n\nBreakpoint 2:\nBreakpoint commands:\np sum\np a + b\n```\n\n当下次断点命中时我们就会在控制台看到下面的输出：\n\n```\nProcess 36612 resuming\np sum\n(Int) $R0 = 6\n\np a + b\n(Int) $R1 = 4\n```\n\n太棒了！这正是我们想要的。你可以通过在命令链的末尾添加 `continue` 命令让执行过程更加顺畅，这样你就不会停在这个断点。\n\n```\n(lldb) breakpoint command add 2 // 准备某些命令\n\nEnter your debugger command(s).  Type 'DONE' to end.\n> p sum // 打印变量 \"sum\" 的值\n> p a + b // 运行 a + b\n> continue // 第一次命中断点后直接恢复\n> DONE\n```\n\n结果会是这样：\n\n```\np sum\n(Int) $R0 = 6\n\np a + b\n(Int) $R1 = 4\n\ncontinue\nProcess 36863 resuming\nCommand #3 'continue' continued the target.\n```\n\n![](http://upload-images.jianshu.io/upload_images/698554-a1c3ec912e68ba8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n通过 `thread` 命令和它的子命令，你可以完全操控执行流程：`step-over`, `step-in`, `step-out` 和 `continue`。这些命令等同于 Xcode 调试器工具栏上的流程控制按钮。\n\n![](http://upload-images.jianshu.io/upload_images/698554-0dfdf39bff20db4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nLLDB 同样也对这些特殊的命令预先定义好了快捷方式：\n\n```\n(lldb) thread step-over\n(lldb) next // 和 \"thread step-over\" 命令效果一样\n(lldb) n // 和 \"next\" 命令效果一样\n\n(lldb) thread step-in\n(lldb) step // 和 \"thread step-in\" 命令效果一样\n(lldb) s // 和 \"step\" 命令效果一样\n```\n\n为了获取当前线程的更多信息，我们只需要调用 `info` 子命令：\n\n```\n(lldb) thread info \n\nthread #1: tid = 0x17de17, 0x0000000109429a90 LLDB-Debugger-Exploration`ViewController.sumOf(a=2, b=2, self=0x00007fe775507390) -> Int at ViewController.swift:90, queue = 'com.apple.main-thread', stop reason = step in\n```\n\n想要看到当前所有的活动线程的话使用 `list` 子命令：\n\n```\n(lldb) thread list\n\nProcess 50693 stopped\n\n* thread #1: tid = 0x17de17, 0x0000000109429a90 LLDB-Debugger-Exploration`ViewController.sumOf(a=2, b=2, self=0x00007fe775507390) -> Int at ViewController.swift:90, queue = 'com.apple.main-thread', stop reason = step in\n\n  thread #2: tid = 0x17df4a, 0x000000010daa4dc6  libsystem_kernel.dylib`kevent_qos + 10, queue = 'com.apple.libdispatch-manager'\n  \n  thread #3: tid = 0x17df4b, 0x000000010daa444e libsystem_kernel.dylib`__workq_kernreturn + 10\n\n  thread #5: tid = 0x17df4e, 0x000000010da9c34a libsystem_kernel.dylib`mach_msg_trap + 10, name = 'com.apple.uikit.eventfetch-thread'\n```\n\n\n\n### 荣誉奖\n\n`command`, `platform`, `gui`\n\n![](http://upload-images.jianshu.io/upload_images/698554-93fdf48e5daca771.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n在 LLDB 中你可以找到一个命令管理其他的命令，听起来很奇怪，但实际上它是非常有用的小工具。首先，它允许你从文件中执行一些 LLDB 命令，这样你就可以创建一个储存着一些实用命令的文件，然后就能立刻允许这些命令，就像是单个命令那样。这是所说的文件的简单例子：\n\n```\nthread info // 显示当前线程的信息\nbr list // 显示所有的断点\n```\n\n下面是实际命令的样子：\n\n```\n(lldb) command source /Users/Ahmed/Desktop/lldb-test-script\n\nExecuting commands in '/Users/Ahmed/Desktop/lldb-test-script'.\n\nthread info\nthread #1: tid = 0x17de17, 0x0000000109429a90 LLDB-Debugger-Exploration`ViewController.sumOf(a=2, b=2, self=0x00007fe775507390) -> Int at ViewController.swift:90, queue = 'com.apple.main-thread', stop reason = step in\n\nbr list\nCurrent breakpoints:\n1: file = '/Users/Ahmed/Desktop/Recent/LLDB-Debugger-Exploration/LLDB-Debugger-Exploration/ViewController.swift', line = 60, exact_match = 0, locations = 1, resolved = 1, hit count = 0\n1.1: where = LLDB-Debugger-Exploration`LLDB_Debugger_Exploration.ViewController.viewDidLoad () -> () + 521 at ViewController.swift:60, address = 0x0000000109429609, resolved, hit count = 0\n```\n\n遗憾的是还有一个缺点，你不能传递任何参数给这个源文件（除非你在脚本文件本身中创建一个有效的变量）。\n\n如果你需要更高级的功能，你也可以使用 `script` 子命令，这个命令允许你用自定义的 Python 脚本 管理(`add`, `delete`, `import` 和 `list`)，通过 `script` 命令能实现真正的自动化。请阅读这个优秀的教程 [Python scripting for LLDB](http://www.fabianguerra.com/ios/introduction-to-lldb-python-scripting/)。为了演示的目的，让我们创建一个脚本文件 script.py，然后写一个简单的命令 **print_hello()**，这个命令会在控制台中打印出“Hello Debugger!“：\n\n```\nimport lldb\n\ndef print_hello(debugger, command, result, internal_dict):\n\tprint \"Hello Debugger!\"\n    \ndef __lldb_init_module(debugger, internal_dict):\n\tdebugger.HandleCommand('command script add -f script.print_hello print_hello') // 控制脚本的初始化同时从这个模块中添加命令\n\tprint 'The \"print_hello\" python command has been installed and is ready for use.' // 打印确认一切正常\n```\n\n接下来我们需要导入一个 Python 模块，就能开始正常地使用我们的脚本命令了：\n\n```\n(lldb) command import ~/Desktop/script.py\n\nThe \"print_hello\" python command has been installed and is ready for use.\n\n(lldb) print_hello\n\nHello Debugger!\n```\n\n![](http://upload-images.jianshu.io/upload_images/698554-463b54c539c5eb64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n你可以使用 `status` 子命令来快速检查当前的环境信息，`status` 会告诉你：SDK 路径、处理器的架构、操作系统版本甚至是该 SDK 可支持的设备的列表。\n\n```\n(lldb) platform status\n\nPlatform: ios-simulator\nTriple: x86_64-apple-macosx\nOS Version: 10.12.5 (16F73)\nKernel: Darwin Kernel Version 16.6.0: Fri Apr 14 16:21:16 PDT 2017; root:xnu-3789.60.24~6/RELEASE_X86_64\nHostname: 127.0.0.1\nWorkingDir: /\nSDK Path: \"/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk\"\n\nAvailable devices:\n614F8701-3D93-4B43-AE86-46A42FEB905A: iPhone 4s\nCD516CF7-2AE7-4127-92DF-F536FE56BA22: iPhone 5\n0D76F30F-2332-4E0C-9F00-B86F009D59A3: iPhone 5s\n3084003F-7626-462A-825B-193E6E5B9AA7: iPhone 6\n...\n```\n\n![](http://upload-images.jianshu.io/upload_images/698554-7ac0c7f2bf73cecd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n你不能在 Xcode 中使用 LLDB GUI 模式，但你总是可以从终端使用（LLDB GUI 模式）。\n\n```\n(lldb) gui\n\n// 如果你试着在 Xcode 中执行这个 gui 命令的话，你将会看到这个错误：the gui command requires an interactive terminal。\n```\n\n![](http://upload-images.jianshu.io/upload_images/698554-5d99e8dfc0af41df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这就是 LLDB GUI 模式看起来的样子。\n\n### 结论：\n\n在这篇文章中，我只是浅析了 LLDB 的皮毛知识而已，即使 LLDB 已经有好些年头了，但是仍然有许多人并没有完全发挥出它的潜能。我只是对基本的方法做了一个概述，以及谈了 LLDB 如何自动化调试步骤。我希望这会是有帮助的。\n\n还有很多 LLDB 的方法并没有写到，然后还有一些视图调试技术我没有提及。如果你对这些话题感兴趣的话，请在下面留下你的评论，我会更加乐于写这些话题。\n\n我强烈建议你打开终端，启动 LLDB，只需要敲入 `help`，就会向你展示完整的文档。你可以花费数小时去阅读，但是我保证这将是一个合理的时间投资。因为了解你的工具是工程师真正产出的唯一途径。\n\n------\n\n- [LLDB 官方网站](http://lldb.llvm.org) —  你会在这里找到所有与 LLDB 相关的材料。文档、指南、教程、源文件以及更多。\n- [LLDB Quick Start Guide by Apple](https://developer.apple.com/library/content/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/Introduction.html#//apple_ref/doc/uid/TP40012917-CH1-SW1) — 同样地，Apple 提供了很好的文档。这篇指南能帮你快速上手 LLDB，当然，他们也叙述了怎样不通过 Xcode 地用 LLDB 调试。\n- [How debuggers work: Part 1 — Basics](http://eli.thegreenplace.net/2011/01/23/how-debuggers-work-part-1 \"Permalink to How debuggers work: Part 1 - Basics\") — 我非常喜欢这个系列的文章，这是对调试器实际工作方式很好的概述。文章介绍了用 C 语言手工编写的调试器代码要遵循的所有基本原理。我强烈建议你去阅读这个优秀系列的所有部分（[第2部分](http://eli.thegreenplace.net/2011/01/27/how-debuggers-work-part-2-breakpoints), [第3部分](http://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information)）。\n- [WWDC14 Advanced Swift Debugging in LLDB](https://developer.apple.com/videos/play/wwdc2014/410/) — 关于在 LLDB 中用 Swift 调试的一篇不错的概述，也讲了 LLDB 如何通过内建的方法和特性实现完整的调试操作，来帮你变得更加高效。\n- [Introduction To LLDB Python Scripting](http://www.fabianguerra.com/ios/introduction-to-lldb-python-scripting/) — 这篇介绍 LLDB Python 脚本的指南能让你快速上手。\n- [Dancing in the Debugger. A Waltz with LLDB](https://www.objc.io/issues/19-debugging/lldb-debugging)  — 对 LLDB 一些基础知识的介绍，有些知识有点过时了（比如说 `(lldb) thread return` 命令）。遗憾的是，它不能直接用于 Swift，因为它会对引用计数带了一些潜在的隐患。但是，这仍然是你开始 LLDB 之旅不错的文章。\n","source":"_posts/翻译用LLDB调试Swift代码.md","raw":"---\ntitle: (翻译)用 LLDB 调试 Swift 代码\ndate: 2018-02-06 14:41:38\ntags:\n- iOS\n- 翻译\ncategories:\n- ruanpapa--技术贴\n---\n\n> * 原文地址：[Debugging Swift code with LLDB](https://medium.com/flawless-app-stories/debugging-swift-code-with-lldb-b30c5cf2fd49)\n> * 原文作者：[Ahmed Sulaiman](https://medium.com/@ahmedsulaiman?source=post_header_lockup)\n\n# 用 LLDB 调试 Swift 代码\n\n![](http://upload-images.jianshu.io/upload_images/698554-035b0df85ea54d32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n作为工程师，我们花了差不多 70% 的时间在调试上，剩下的 20% 用来思考架构以及和组员沟通，仅仅只有 10% 的时间是真的在写代码的。\n\n> 调试就像是在犯罪电影中做侦探一样，同时你也是凶手。\n>\n> — [Filipe Fortes](https://twitter.com/fortes) 来自 Twitter\n\n所以让我们在这70%的时间尽可能愉悦是相当重要的。LLDB 就是来打救我们的。奇妙的 Xcode Debugger UI 展示了所有你可用的信息，而不用敲入任何一个 LLDB 命令。然而，控制台在我们的工作中同样也是很重要的一部分。现在让我们来分析一些最有用的 LLDB 技巧。我自己每天都在用它们进行调试。\n\n\n\n### 从哪里开始呢？\n\nLLDB 是一个庞大的工具，内置了很多有用的命令。我不会全部讲解，而是带你浏览最有用的命令。这是我们的计划：\n\n1. 获取变量值： `expression`, `e`, `print`, `po`, `p`\n2. 获取整个应用程序的状态以及特定语言的命令：`bugreport`, `frame`, `language`\n3. 控制应用的执行流程：`process`, `breakpoint`, `thread`, `watchpoint`\n4. 荣誉奖：`command`, `platform`, `gui`\n\n我还准备好了有用的 LLDB 命令说明和实例的表格，有需要的可以把它贴在 Mac 上面记住这些命令 🙂\n\n![](http://upload-images.jianshu.io/upload_images/698554-4425e8ad483d1e91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n通过这条链接下载全尺寸的版本 —  [https://www.dropbox.com/s/9sv67e7f2repbpb/lldb-commands-map.png?dl=0](https://www.dropbox.com/s/9sv67e7f2repbpb/lldb-commands-map.png?dl=0)\n\n\n\n### 1. 获取变量值和状态\n\n命令：`expression`, `e`, `print`, `po`, `p`\n\n![](http://upload-images.jianshu.io/upload_images/698554-28e3583bcef761ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n调试器的一个基础功能就是获取和修改变量的值。这就是 `expression` 或者 `e` 被创造的原因（当然他们还有更高级的功能）。您可以简单的在运行时执行任何表达式或命令。\n\n假设你现在正在调试方法 `valueOfLifeWithoutSumOf()` ：对两个数求和，再用42去减得到结果。\n\n![](http://upload-images.jianshu.io/upload_images/698554-f788753308492216.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n继续假设你一直得到错误的结果并且你并不知道是什么原因。所以你可以做以下的事来找到问题：\n\n![](http://upload-images.jianshu.io/upload_images/698554-ca27db839bd80a19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n或者。。。使用 LLDB 表达式在运行时修改值才是更好的方法，同时可以找出问题是在哪里出现的。首先，在你感兴趣的地方设置一个断点，然后运行你的应用。\n\n为了用 LLDB 格式打印指定的变量你应该调用：\n\n```\n(lldb) e <variable>\n```\n\n使用相同的命令来执行一些表达式：\n\n```\n(lldb) e <expression>\n```\n\n![](http://upload-images.jianshu.io/upload_images/698554-42790260c5498fe3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n```\n(lldb) e sum \n(Int) $R0 = 6 // 下面你也可以用 $R0 来引用这个变量（在本次调试过程中）\n\n(lldb) e sum = 4 // 修改变量 sum 的值\n\n(lldb) e sum \n(Int) $R2 = 4 // 直到本次调试结束变量 sum 都会是 \"4\" \n```\n\n`expression` 命令也有一些标志。在 `expression` 后面用双破折号 `--` 将标志和实际的表达式分隔开，就像这样：\n\n```\n(lldb) expression <some flags> -- <variable>\n```\n\n`expression` 命令差不多有30种不同的标志。我鼓励你多去探索它们。在终端中键入以下命令可以看到完整的文档：\n\n```\n> lldb\n> (lldb) help # 获取所有变量的命令\n> (lldb) help expression # 获取所有表达式的子命令\n```\n\n我会在下列 `expression` 的标志上多停留一会儿：\n\n- `-D <count>` (`--depth <count>`)  — 设置在转储聚合类型时的最大递归深度（默认为无穷大）。\n- `-O` (`--object-description`)  — 如果可能的话，使用指定语言的描述API来显示。\n- `-T` (`--show-types`)  — 在转储值的时候显示变量类型。\n- `-f <format>` (`--format <format>`) — 指定一种用于显示的格式。\n- `-i <boolean>` (`--ignore-breakpoints <boolean>`) — 在运行表达式时忽略断点。\n\n假设我们有一个叫 `logger` 的对象，这个对象有一些字符串和结构体类型的属性。比如说，你可能只是想知道第一层的属性，那只需要用 `-D` 标志以及恰当的层级深度值，就像这样：\n\n```\n(lldb) e -D 1 -- logger\n\n(LLDB_Debugger_Exploration.Logger) $R5 = 0x0000608000087e90 {\n  currentClassName = \"ViewController\"\n  debuggerStruct ={...}\n}\n```\n\n默认情况下，LLDB 会无限地遍历该对象并且给你展示每个嵌套的对象的完整描述：\n\n```\n(lldb) e -- logger\n\n(LLDB_Debugger_Exploration.Logger) $R6 = 0x0000608000087e90 {\n  currentClassName = \"ViewController\"\n  debuggerStruct = (methodName = \"name\", lineNumber = 2, commandCounter = 23)\n}\n```\n\n你也可以用 `e -O --` 获取对象的描述或者更简单地用别名 `po`，就像下面的示例一样：\n\n```\n(lldb) po logger\n\n<Logger: 0x608000087e90>\n```\n\n并不是很有描述性，不是吗？为了获取更加可阅读的描述，你自定义的类必须遵循 `CustomStringConvertible` 协议，同时实现 `var description: String { return ...}` 属性。接下来只需要用 `po` 就能返回可读的描述。\n\n![](http://upload-images.jianshu.io/upload_images/698554-67b11fbfba92f9c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n在本节的开始，我也提到了 `print` 命令。基本上 `print <expression/variable>` 就等同于 `expression -- <expression/variable>`。但是 `print` 命令不能带任何标志或者额外的参数。\n\n\n\n### 2. 获取整个 APP 的状态和指定语言的命令\n\n`bugreport`, `frame`, `language`\n\n![](http://upload-images.jianshu.io/upload_images/698554-b6780919d5f067a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n你是否经常复制粘贴崩溃日志到任务管理器中方便稍后能考虑这个问题吗？LLDB 提供了一个很好用的命令叫 `bugreport`，这个命令能生成当前应用状态的完整报告。在你偶然触发某些问题但是想在稍后再解决它时这个命令就会很有帮助了。为了能恢复应用的状态，你可以使用 `bugreport` 生成报告。 \n\n```\n(lldb) bugreport unwind --outfile <path to output file>\n```\n\n最终的报告看起来就像下面截图中的例子一样：\n\n![](http://upload-images.jianshu.io/upload_images/698554-f8a7604c35151d5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n`bugreport` 命令输出的示例。\n\n\n![](http://upload-images.jianshu.io/upload_images/698554-2179c17fefec7742.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n假设你想要获取当前线程的当前栈帧的概述，`frame` 命令可以帮你完成：\n\n![](http://upload-images.jianshu.io/upload_images/698554-5207a680ff245ddf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n使用下面的代码片段来快速获取当前地址以及当前的环境条件：\n\n```\n(lldb) frame info\n\nframe #0: 0x000000010bbe4b4d LLDB-Debugger-Exploration`ViewController.valueOfLifeWithoutSumOf(a=2, b=2, self=0x00007fa0c1406900) -> Int at ViewController.swift:96\n```\n\n这些信息在本文后面将要说到的断点管理中非常有用。\n\n![](http://upload-images.jianshu.io/upload_images/698554-2b16ad60aed4e6af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\nLLDB 有几个指定语言的命令，包括C++，Objective-C，Swift 和 RenderScript。在这篇文章中，我们重点关注 Swift。这是两个命令：`demangle` 和 `refcount`。\n\n`demangle` 正如其名字而言，就是用来重组 Swift 类型名的（因为 Swift 在编译的时候会生成类型名来避免命名空间的问题）。如果你想了解多一点的话，我建议你看 WWDC14 的这个分享会 —  [“Advanced Swift Debugging in LLDB”](https://developer.apple.com/videos/play/wwdc2014/410/)。\n\n`refcount` 同样也是一个相当直观的命令，能获得指定对象的引用数量。一起来看一下对象输出的示例，我们用了上一节讲到的对象 — `logger`：\n\n```\n(lldb) language swift refcount logger\n\nrefcount data: (strong = 4, weak = 0)\n```\n\n当然了，在你调试某些内存泄露问题时，这个命令就会很有帮助。\n\n\n\n### 3. 控制应用的执行流程\n\n`process`, `breakpoint`, `thread`\n\n这节是我最喜欢的一节，因为在 LLDB 使用这几个命令（尤其是 `breakpoint` 命令），你可以在调试的时候使很多常规任务变得自动化，这样就能大大加快你的调试工作。\n\n![](http://upload-images.jianshu.io/upload_images/698554-190d8c7f7600ae0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n通过 `process` 基本上你就可以控制调试的过程了，还能链接到特定的 target 或者停止调试器。 但是因为 Xcode 已经自动地帮我们做好了这个工作了（Xcode 在任何时候运行一个 target 时都会连接 LLDB）。我不会在这儿讲太多，你可以在这篇 Apple 的指南中阅读一下如何用终端连接到一个 target — [“Using LLDB as a Standalone Debugger”](https://developer.apple.com/library/content/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-terminal-workflow-tutorial.html)。\n\n使用 `process status` 的话，你可以知道当前调试器停住的地址：\n\n```\n(lldb) process status\n\nProcess 27408 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = step over\nframe #0: 0x000000010bbe4889 LLDB-Debugger-Exploration`ViewController.viewDidLoad(self=0x00007fa0c1406900) -> () at ViewController.swift:69\n66\n67           let a = 2, b = 2\n68           let result = valueOfLifeWithoutSumOf(a, and: b)\n-> 69           print(result)\n70\n71\n72\n```\n\n想要继续 target 的执行过程直到遇到下次断点的话，运行这个命令：\n\n```\n(lldb) process continue\n\n(lldb) c // 或者只键入 \"c\"，这跟上一条命令是一样的\n```\n\n这个命令等同于 Xcode 调试器工具栏上的”continue“按钮：\n\n![](http://upload-images.jianshu.io/upload_images/698554-8d3a7affc384f574.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![](http://upload-images.jianshu.io/upload_images/698554-779f316d847a475c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n`breakpoint` 命令允许你用任何可能的方式操作断点。我们跳过最显而易见的命令：`breakpoint enable`, `breakpoint disable` 和 `breakpoint delete`。\n\n首先，查看你所有断点的话可以用如下示例中的 `list` 子命令：\n\n```\n(lldb) breakpoint list\n\nCurrent breakpoints:\n1: file = '/Users/Ahmed/Desktop/Recent/LLDB-Debugger-Exploration/LLDB-Debugger-Exploration/ViewController.swift', line = 95, exact_match = 0, locations = 1, resolved = 1, hit count = 1\n\n1.1: where = LLDB-Debugger-Exploration`LLDB_Debugger_Exploration.ViewController.valueOfLifeWithoutSumOf (Swift.Int, and : Swift.Int) -> Swift.Int + 27 at ViewController.swift:95, address = 0x0000000107f3eb3b, resolved, hit count = 1\n\n2: file = '/Users/Ahmed/Desktop/Recent/LLDB-Debugger-Exploration/LLDB-Debugger-Exploration/ViewController.swift', line = 60, exact_match = 0, locations = 1, resolved = 1, hit count = 1\n\n2.1: where = LLDB-Debugger-Exploration`LLDB_Debugger_Exploration.ViewController.viewDidLoad () -> () + 521 at ViewController.swift:60, address = 0x0000000107f3e609, resolved, hit count = 1\n```\n\n列表中的第一个数字是是断点的 ID，你可以通过这个 ID 引用到指定的断点。现在让我们在控制台中设置一些新的断点：\n\n```\n(lldb) breakpoint set -f ViewController.swift -l 96\n\nBreakpoint 3: where = LLDB-Debugger-Exploration`LLDB_Debugger_Exploration.ViewController.valueOfLifeWithoutSumOf (Swift.Int, and : Swift.Int) -> Swift.Int + 45 at ViewController.swift:96, address = 0x0000000107f3eb4d\n```\n\n这个例子中的 `-f` 是你想要放置断点处的文件名，`-l` 是新断点的行数。还有一种更简洁的方式设置同样的断点，就是用快捷方式 `b`：\n\n```\n(lldb) b ViewController.swift:96\n```\n\n同样地，你也可以用指定的正则（比如函数名）来设置断点，使用下面的命令：\n\n```\n(lldb) breakpoint set --func-regex valueOfLifeWithoutSumOf\n\n(lldb) b -r valueOfLifeWithoutSumOf // 上一条命令的简化版本\n```\n\n有些时候设置断点只命中一次也是有用的，然后指示这个断点立即删除自己，当然啦，有一个命令来处理这件事：\n\n```\n(lldb) breakpoint set --one-shot -f ViewController.swift -l 90\n\n(lldb) br s -o -f ViewController.swift -l 91 // 上一条命令的简化版本\n```\n\n现在我们来到了最有趣的部分 — 自动化断点。你知道你可以设置一个特定的动作使它在断点停住的时候执行吗？是的，你可以！你是否会在代码中用 `print()` 来在调试的时候得到你感兴趣的值？请不要再这样做了，这里有一种更好的方法。🙂\n\n通过 `breakpoint` 命令，你可以设置好命令，使其在断点命中时可以正确执行。你甚至可以设置”不可见“的断点，这种断点并不会打断运行过程。从技术上讲，这些“不可见的”断点其实是会中断执行的，但如果在命令链的末尾添上“continue”命令的话，你就不会注意到它。\n\n```\n(lldb) b ViewController.swift:96 // Let's add a breakpoint first\n\nBreakpoint 2: where = LLDB-Debugger-Exploration`LLDB_Debugger_Exploration.ViewController.valueOfLifeWithoutSumOf (Swift.Int, and : Swift.Int) -> Swift.Int + 45 at ViewController.swift:96, address = 0x000000010c555b4d\n\n(lldb) breakpoint command add 2 // 准备某些命令\n\nEnter your debugger command(s).  Type 'DONE' to end.\n> p sum // 打印变量 \"sum\" 的值\n> p a + b // 运行 a + b\n> DONE\n```\n\n为了确保你添加的命令是正确的，可以使用  `breakpoint command list <breakpoint id>` 子命令：\n\n```\n(lldb) breakpoint command list 2\n\nBreakpoint 2:\nBreakpoint commands:\np sum\np a + b\n```\n\n当下次断点命中时我们就会在控制台看到下面的输出：\n\n```\nProcess 36612 resuming\np sum\n(Int) $R0 = 6\n\np a + b\n(Int) $R1 = 4\n```\n\n太棒了！这正是我们想要的。你可以通过在命令链的末尾添加 `continue` 命令让执行过程更加顺畅，这样你就不会停在这个断点。\n\n```\n(lldb) breakpoint command add 2 // 准备某些命令\n\nEnter your debugger command(s).  Type 'DONE' to end.\n> p sum // 打印变量 \"sum\" 的值\n> p a + b // 运行 a + b\n> continue // 第一次命中断点后直接恢复\n> DONE\n```\n\n结果会是这样：\n\n```\np sum\n(Int) $R0 = 6\n\np a + b\n(Int) $R1 = 4\n\ncontinue\nProcess 36863 resuming\nCommand #3 'continue' continued the target.\n```\n\n![](http://upload-images.jianshu.io/upload_images/698554-a1c3ec912e68ba8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n通过 `thread` 命令和它的子命令，你可以完全操控执行流程：`step-over`, `step-in`, `step-out` 和 `continue`。这些命令等同于 Xcode 调试器工具栏上的流程控制按钮。\n\n![](http://upload-images.jianshu.io/upload_images/698554-0dfdf39bff20db4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nLLDB 同样也对这些特殊的命令预先定义好了快捷方式：\n\n```\n(lldb) thread step-over\n(lldb) next // 和 \"thread step-over\" 命令效果一样\n(lldb) n // 和 \"next\" 命令效果一样\n\n(lldb) thread step-in\n(lldb) step // 和 \"thread step-in\" 命令效果一样\n(lldb) s // 和 \"step\" 命令效果一样\n```\n\n为了获取当前线程的更多信息，我们只需要调用 `info` 子命令：\n\n```\n(lldb) thread info \n\nthread #1: tid = 0x17de17, 0x0000000109429a90 LLDB-Debugger-Exploration`ViewController.sumOf(a=2, b=2, self=0x00007fe775507390) -> Int at ViewController.swift:90, queue = 'com.apple.main-thread', stop reason = step in\n```\n\n想要看到当前所有的活动线程的话使用 `list` 子命令：\n\n```\n(lldb) thread list\n\nProcess 50693 stopped\n\n* thread #1: tid = 0x17de17, 0x0000000109429a90 LLDB-Debugger-Exploration`ViewController.sumOf(a=2, b=2, self=0x00007fe775507390) -> Int at ViewController.swift:90, queue = 'com.apple.main-thread', stop reason = step in\n\n  thread #2: tid = 0x17df4a, 0x000000010daa4dc6  libsystem_kernel.dylib`kevent_qos + 10, queue = 'com.apple.libdispatch-manager'\n  \n  thread #3: tid = 0x17df4b, 0x000000010daa444e libsystem_kernel.dylib`__workq_kernreturn + 10\n\n  thread #5: tid = 0x17df4e, 0x000000010da9c34a libsystem_kernel.dylib`mach_msg_trap + 10, name = 'com.apple.uikit.eventfetch-thread'\n```\n\n\n\n### 荣誉奖\n\n`command`, `platform`, `gui`\n\n![](http://upload-images.jianshu.io/upload_images/698554-93fdf48e5daca771.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n在 LLDB 中你可以找到一个命令管理其他的命令，听起来很奇怪，但实际上它是非常有用的小工具。首先，它允许你从文件中执行一些 LLDB 命令，这样你就可以创建一个储存着一些实用命令的文件，然后就能立刻允许这些命令，就像是单个命令那样。这是所说的文件的简单例子：\n\n```\nthread info // 显示当前线程的信息\nbr list // 显示所有的断点\n```\n\n下面是实际命令的样子：\n\n```\n(lldb) command source /Users/Ahmed/Desktop/lldb-test-script\n\nExecuting commands in '/Users/Ahmed/Desktop/lldb-test-script'.\n\nthread info\nthread #1: tid = 0x17de17, 0x0000000109429a90 LLDB-Debugger-Exploration`ViewController.sumOf(a=2, b=2, self=0x00007fe775507390) -> Int at ViewController.swift:90, queue = 'com.apple.main-thread', stop reason = step in\n\nbr list\nCurrent breakpoints:\n1: file = '/Users/Ahmed/Desktop/Recent/LLDB-Debugger-Exploration/LLDB-Debugger-Exploration/ViewController.swift', line = 60, exact_match = 0, locations = 1, resolved = 1, hit count = 0\n1.1: where = LLDB-Debugger-Exploration`LLDB_Debugger_Exploration.ViewController.viewDidLoad () -> () + 521 at ViewController.swift:60, address = 0x0000000109429609, resolved, hit count = 0\n```\n\n遗憾的是还有一个缺点，你不能传递任何参数给这个源文件（除非你在脚本文件本身中创建一个有效的变量）。\n\n如果你需要更高级的功能，你也可以使用 `script` 子命令，这个命令允许你用自定义的 Python 脚本 管理(`add`, `delete`, `import` 和 `list`)，通过 `script` 命令能实现真正的自动化。请阅读这个优秀的教程 [Python scripting for LLDB](http://www.fabianguerra.com/ios/introduction-to-lldb-python-scripting/)。为了演示的目的，让我们创建一个脚本文件 script.py，然后写一个简单的命令 **print_hello()**，这个命令会在控制台中打印出“Hello Debugger!“：\n\n```\nimport lldb\n\ndef print_hello(debugger, command, result, internal_dict):\n\tprint \"Hello Debugger!\"\n    \ndef __lldb_init_module(debugger, internal_dict):\n\tdebugger.HandleCommand('command script add -f script.print_hello print_hello') // 控制脚本的初始化同时从这个模块中添加命令\n\tprint 'The \"print_hello\" python command has been installed and is ready for use.' // 打印确认一切正常\n```\n\n接下来我们需要导入一个 Python 模块，就能开始正常地使用我们的脚本命令了：\n\n```\n(lldb) command import ~/Desktop/script.py\n\nThe \"print_hello\" python command has been installed and is ready for use.\n\n(lldb) print_hello\n\nHello Debugger!\n```\n\n![](http://upload-images.jianshu.io/upload_images/698554-463b54c539c5eb64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n你可以使用 `status` 子命令来快速检查当前的环境信息，`status` 会告诉你：SDK 路径、处理器的架构、操作系统版本甚至是该 SDK 可支持的设备的列表。\n\n```\n(lldb) platform status\n\nPlatform: ios-simulator\nTriple: x86_64-apple-macosx\nOS Version: 10.12.5 (16F73)\nKernel: Darwin Kernel Version 16.6.0: Fri Apr 14 16:21:16 PDT 2017; root:xnu-3789.60.24~6/RELEASE_X86_64\nHostname: 127.0.0.1\nWorkingDir: /\nSDK Path: \"/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk\"\n\nAvailable devices:\n614F8701-3D93-4B43-AE86-46A42FEB905A: iPhone 4s\nCD516CF7-2AE7-4127-92DF-F536FE56BA22: iPhone 5\n0D76F30F-2332-4E0C-9F00-B86F009D59A3: iPhone 5s\n3084003F-7626-462A-825B-193E6E5B9AA7: iPhone 6\n...\n```\n\n![](http://upload-images.jianshu.io/upload_images/698554-7ac0c7f2bf73cecd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n你不能在 Xcode 中使用 LLDB GUI 模式，但你总是可以从终端使用（LLDB GUI 模式）。\n\n```\n(lldb) gui\n\n// 如果你试着在 Xcode 中执行这个 gui 命令的话，你将会看到这个错误：the gui command requires an interactive terminal。\n```\n\n![](http://upload-images.jianshu.io/upload_images/698554-5d99e8dfc0af41df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这就是 LLDB GUI 模式看起来的样子。\n\n### 结论：\n\n在这篇文章中，我只是浅析了 LLDB 的皮毛知识而已，即使 LLDB 已经有好些年头了，但是仍然有许多人并没有完全发挥出它的潜能。我只是对基本的方法做了一个概述，以及谈了 LLDB 如何自动化调试步骤。我希望这会是有帮助的。\n\n还有很多 LLDB 的方法并没有写到，然后还有一些视图调试技术我没有提及。如果你对这些话题感兴趣的话，请在下面留下你的评论，我会更加乐于写这些话题。\n\n我强烈建议你打开终端，启动 LLDB，只需要敲入 `help`，就会向你展示完整的文档。你可以花费数小时去阅读，但是我保证这将是一个合理的时间投资。因为了解你的工具是工程师真正产出的唯一途径。\n\n------\n\n- [LLDB 官方网站](http://lldb.llvm.org) —  你会在这里找到所有与 LLDB 相关的材料。文档、指南、教程、源文件以及更多。\n- [LLDB Quick Start Guide by Apple](https://developer.apple.com/library/content/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/Introduction.html#//apple_ref/doc/uid/TP40012917-CH1-SW1) — 同样地，Apple 提供了很好的文档。这篇指南能帮你快速上手 LLDB，当然，他们也叙述了怎样不通过 Xcode 地用 LLDB 调试。\n- [How debuggers work: Part 1 — Basics](http://eli.thegreenplace.net/2011/01/23/how-debuggers-work-part-1 \"Permalink to How debuggers work: Part 1 - Basics\") — 我非常喜欢这个系列的文章，这是对调试器实际工作方式很好的概述。文章介绍了用 C 语言手工编写的调试器代码要遵循的所有基本原理。我强烈建议你去阅读这个优秀系列的所有部分（[第2部分](http://eli.thegreenplace.net/2011/01/27/how-debuggers-work-part-2-breakpoints), [第3部分](http://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information)）。\n- [WWDC14 Advanced Swift Debugging in LLDB](https://developer.apple.com/videos/play/wwdc2014/410/) — 关于在 LLDB 中用 Swift 调试的一篇不错的概述，也讲了 LLDB 如何通过内建的方法和特性实现完整的调试操作，来帮你变得更加高效。\n- [Introduction To LLDB Python Scripting](http://www.fabianguerra.com/ios/introduction-to-lldb-python-scripting/) — 这篇介绍 LLDB Python 脚本的指南能让你快速上手。\n- [Dancing in the Debugger. A Waltz with LLDB](https://www.objc.io/issues/19-debugging/lldb-debugging)  — 对 LLDB 一些基础知识的介绍，有些知识有点过时了（比如说 `(lldb) thread return` 命令）。遗憾的是，它不能直接用于 Swift，因为它会对引用计数带了一些潜在的隐患。但是，这仍然是你开始 LLDB 之旅不错的文章。\n","slug":"翻译用LLDB调试Swift代码","published":1,"updated":"2018-02-06T07:13:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg4j8w2r0023vfwxnmhc1sdx","content":"<blockquote>\n<ul>\n<li>原文地址：<a href=\"https://medium.com/flawless-app-stories/debugging-swift-code-with-lldb-b30c5cf2fd49\" target=\"_blank\" rel=\"external\">Debugging Swift code with LLDB</a></li>\n<li>原文作者：<a href=\"https://medium.com/@ahmedsulaiman?source=post_header_lockup\" target=\"_blank\" rel=\"external\">Ahmed Sulaiman</a></li>\n</ul>\n</blockquote>\n<h1 id=\"用-LLDB-调试-Swift-代码\"><a href=\"#用-LLDB-调试-Swift-代码\" class=\"headerlink\" title=\"用 LLDB 调试 Swift 代码\"></a>用 LLDB 调试 Swift 代码</h1><p><img src=\"http://upload-images.jianshu.io/upload_images/698554-035b0df85ea54d32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>作为工程师，我们花了差不多 70% 的时间在调试上，剩下的 20% 用来思考架构以及和组员沟通，仅仅只有 10% 的时间是真的在写代码的。</p>\n<blockquote>\n<p>调试就像是在犯罪电影中做侦探一样，同时你也是凶手。</p>\n<p>— <a href=\"https://twitter.com/fortes\" target=\"_blank\" rel=\"external\">Filipe Fortes</a> 来自 Twitter</p>\n</blockquote>\n<p>所以让我们在这70%的时间尽可能愉悦是相当重要的。LLDB 就是来打救我们的。奇妙的 Xcode Debugger UI 展示了所有你可用的信息，而不用敲入任何一个 LLDB 命令。然而，控制台在我们的工作中同样也是很重要的一部分。现在让我们来分析一些最有用的 LLDB 技巧。我自己每天都在用它们进行调试。</p>\n<h3 id=\"从哪里开始呢？\"><a href=\"#从哪里开始呢？\" class=\"headerlink\" title=\"从哪里开始呢？\"></a>从哪里开始呢？</h3><p>LLDB 是一个庞大的工具，内置了很多有用的命令。我不会全部讲解，而是带你浏览最有用的命令。这是我们的计划：</p>\n<ol>\n<li>获取变量值： <code>expression</code>, <code>e</code>, <code>print</code>, <code>po</code>, <code>p</code></li>\n<li>获取整个应用程序的状态以及特定语言的命令：<code>bugreport</code>, <code>frame</code>, <code>language</code></li>\n<li>控制应用的执行流程：<code>process</code>, <code>breakpoint</code>, <code>thread</code>, <code>watchpoint</code></li>\n<li>荣誉奖：<code>command</code>, <code>platform</code>, <code>gui</code></li>\n</ol>\n<p>我还准备好了有用的 LLDB 命令说明和实例的表格，有需要的可以把它贴在 Mac 上面记住这些命令 🙂</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-4425e8ad483d1e91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>通过这条链接下载全尺寸的版本 —  <a href=\"https://www.dropbox.com/s/9sv67e7f2repbpb/lldb-commands-map.png?dl=0\" target=\"_blank\" rel=\"external\">https://www.dropbox.com/s/9sv67e7f2repbpb/lldb-commands-map.png?dl=0</a></p>\n<h3 id=\"1-获取变量值和状态\"><a href=\"#1-获取变量值和状态\" class=\"headerlink\" title=\"1. 获取变量值和状态\"></a>1. 获取变量值和状态</h3><p>命令：<code>expression</code>, <code>e</code>, <code>print</code>, <code>po</code>, <code>p</code></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-28e3583bcef761ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>调试器的一个基础功能就是获取和修改变量的值。这就是 <code>expression</code> 或者 <code>e</code> 被创造的原因（当然他们还有更高级的功能）。您可以简单的在运行时执行任何表达式或命令。</p>\n<p>假设你现在正在调试方法 <code>valueOfLifeWithoutSumOf()</code> ：对两个数求和，再用42去减得到结果。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-f788753308492216.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>继续假设你一直得到错误的结果并且你并不知道是什么原因。所以你可以做以下的事来找到问题：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-ca27db839bd80a19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>或者。。。使用 LLDB 表达式在运行时修改值才是更好的方法，同时可以找出问题是在哪里出现的。首先，在你感兴趣的地方设置一个断点，然后运行你的应用。</p>\n<p>为了用 LLDB 格式打印指定的变量你应该调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) e &lt;variable&gt;</div></pre></td></tr></table></figure>\n<p>使用相同的命令来执行一些表达式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) e &lt;expression&gt;</div></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-42790260c5498fe3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) e sum </div><div class=\"line\">(Int) $R0 = 6 // 下面你也可以用 $R0 来引用这个变量（在本次调试过程中）</div><div class=\"line\"></div><div class=\"line\">(lldb) e sum = 4 // 修改变量 sum 的值</div><div class=\"line\"></div><div class=\"line\">(lldb) e sum </div><div class=\"line\">(Int) $R2 = 4 // 直到本次调试结束变量 sum 都会是 &quot;4&quot;</div></pre></td></tr></table></figure>\n<p><code>expression</code> 命令也有一些标志。在 <code>expression</code> 后面用双破折号 <code>--</code> 将标志和实际的表达式分隔开，就像这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) expression &lt;some flags&gt; -- &lt;variable&gt;</div></pre></td></tr></table></figure>\n<p><code>expression</code> 命令差不多有30种不同的标志。我鼓励你多去探索它们。在终端中键入以下命令可以看到完整的文档：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; lldb</div><div class=\"line\">&gt; (lldb) help # 获取所有变量的命令</div><div class=\"line\">&gt; (lldb) help expression # 获取所有表达式的子命令</div></pre></td></tr></table></figure>\n<p>我会在下列 <code>expression</code> 的标志上多停留一会儿：</p>\n<ul>\n<li><code>-D &lt;count&gt;</code> (<code>--depth &lt;count&gt;</code>)  — 设置在转储聚合类型时的最大递归深度（默认为无穷大）。</li>\n<li><code>-O</code> (<code>--object-description</code>)  — 如果可能的话，使用指定语言的描述API来显示。</li>\n<li><code>-T</code> (<code>--show-types</code>)  — 在转储值的时候显示变量类型。</li>\n<li><code>-f &lt;format&gt;</code> (<code>--format &lt;format&gt;</code>) — 指定一种用于显示的格式。</li>\n<li><code>-i &lt;boolean&gt;</code> (<code>--ignore-breakpoints &lt;boolean&gt;</code>) — 在运行表达式时忽略断点。</li>\n</ul>\n<p>假设我们有一个叫 <code>logger</code> 的对象，这个对象有一些字符串和结构体类型的属性。比如说，你可能只是想知道第一层的属性，那只需要用 <code>-D</code> 标志以及恰当的层级深度值，就像这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) e -D 1 -- logger</div><div class=\"line\"></div><div class=\"line\">(LLDB_Debugger_Exploration.Logger) $R5 = 0x0000608000087e90 &#123;</div><div class=\"line\">  currentClassName = &quot;ViewController&quot;</div><div class=\"line\">  debuggerStruct =&#123;...&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>默认情况下，LLDB 会无限地遍历该对象并且给你展示每个嵌套的对象的完整描述：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) e -- logger</div><div class=\"line\"></div><div class=\"line\">(LLDB_Debugger_Exploration.Logger) $R6 = 0x0000608000087e90 &#123;</div><div class=\"line\">  currentClassName = &quot;ViewController&quot;</div><div class=\"line\">  debuggerStruct = (methodName = &quot;name&quot;, lineNumber = 2, commandCounter = 23)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你也可以用 <code>e -O --</code> 获取对象的描述或者更简单地用别名 <code>po</code>，就像下面的示例一样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po logger</div><div class=\"line\"></div><div class=\"line\">&lt;Logger: 0x608000087e90&gt;</div></pre></td></tr></table></figure>\n<p>并不是很有描述性，不是吗？为了获取更加可阅读的描述，你自定义的类必须遵循 <code>CustomStringConvertible</code> 协议，同时实现 <code>var description: String { return ...}</code> 属性。接下来只需要用 <code>po</code> 就能返回可读的描述。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-67b11fbfba92f9c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>在本节的开始，我也提到了 <code>print</code> 命令。基本上 <code>print &lt;expression/variable&gt;</code> 就等同于 <code>expression -- &lt;expression/variable&gt;</code>。但是 <code>print</code> 命令不能带任何标志或者额外的参数。</p>\n<h3 id=\"2-获取整个-APP-的状态和指定语言的命令\"><a href=\"#2-获取整个-APP-的状态和指定语言的命令\" class=\"headerlink\" title=\"2. 获取整个 APP 的状态和指定语言的命令\"></a>2. 获取整个 APP 的状态和指定语言的命令</h3><p><code>bugreport</code>, <code>frame</code>, <code>language</code></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-b6780919d5f067a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>你是否经常复制粘贴崩溃日志到任务管理器中方便稍后能考虑这个问题吗？LLDB 提供了一个很好用的命令叫 <code>bugreport</code>，这个命令能生成当前应用状态的完整报告。在你偶然触发某些问题但是想在稍后再解决它时这个命令就会很有帮助了。为了能恢复应用的状态，你可以使用 <code>bugreport</code> 生成报告。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) bugreport unwind --outfile &lt;path to output file&gt;</div></pre></td></tr></table></figure>\n<p>最终的报告看起来就像下面截图中的例子一样：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-f8a7604c35151d5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br><code>bugreport</code> 命令输出的示例。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-2179c17fefec7742.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>假设你想要获取当前线程的当前栈帧的概述，<code>frame</code> 命令可以帮你完成：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-5207a680ff245ddf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>使用下面的代码片段来快速获取当前地址以及当前的环境条件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) frame info</div><div class=\"line\"></div><div class=\"line\">frame #0: 0x000000010bbe4b4d LLDB-Debugger-Exploration`ViewController.valueOfLifeWithoutSumOf(a=2, b=2, self=0x00007fa0c1406900) -&gt; Int at ViewController.swift:96</div></pre></td></tr></table></figure>\n<p>这些信息在本文后面将要说到的断点管理中非常有用。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-2b16ad60aed4e6af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>LLDB 有几个指定语言的命令，包括C++，Objective-C，Swift 和 RenderScript。在这篇文章中，我们重点关注 Swift。这是两个命令：<code>demangle</code> 和 <code>refcount</code>。</p>\n<p><code>demangle</code> 正如其名字而言，就是用来重组 Swift 类型名的（因为 Swift 在编译的时候会生成类型名来避免命名空间的问题）。如果你想了解多一点的话，我建议你看 WWDC14 的这个分享会 —  <a href=\"https://developer.apple.com/videos/play/wwdc2014/410/\" target=\"_blank\" rel=\"external\">“Advanced Swift Debugging in LLDB”</a>。</p>\n<p><code>refcount</code> 同样也是一个相当直观的命令，能获得指定对象的引用数量。一起来看一下对象输出的示例，我们用了上一节讲到的对象 — <code>logger</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) language swift refcount logger</div><div class=\"line\"></div><div class=\"line\">refcount data: (strong = 4, weak = 0)</div></pre></td></tr></table></figure>\n<p>当然了，在你调试某些内存泄露问题时，这个命令就会很有帮助。</p>\n<h3 id=\"3-控制应用的执行流程\"><a href=\"#3-控制应用的执行流程\" class=\"headerlink\" title=\"3. 控制应用的执行流程\"></a>3. 控制应用的执行流程</h3><p><code>process</code>, <code>breakpoint</code>, <code>thread</code></p>\n<p>这节是我最喜欢的一节，因为在 LLDB 使用这几个命令（尤其是 <code>breakpoint</code> 命令），你可以在调试的时候使很多常规任务变得自动化，这样就能大大加快你的调试工作。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-190d8c7f7600ae0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>通过 <code>process</code> 基本上你就可以控制调试的过程了，还能链接到特定的 target 或者停止调试器。 但是因为 Xcode 已经自动地帮我们做好了这个工作了（Xcode 在任何时候运行一个 target 时都会连接 LLDB）。我不会在这儿讲太多，你可以在这篇 Apple 的指南中阅读一下如何用终端连接到一个 target — <a href=\"https://developer.apple.com/library/content/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-terminal-workflow-tutorial.html\" target=\"_blank\" rel=\"external\">“Using LLDB as a Standalone Debugger”</a>。</p>\n<p>使用 <code>process status</code> 的话，你可以知道当前调试器停住的地址：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) process status</div><div class=\"line\"></div><div class=\"line\">Process 27408 stopped</div><div class=\"line\">* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = step over</div><div class=\"line\">frame #0: 0x000000010bbe4889 LLDB-Debugger-Exploration`ViewController.viewDidLoad(self=0x00007fa0c1406900) -&gt; () at ViewController.swift:69</div><div class=\"line\">66</div><div class=\"line\">67           let a = 2, b = 2</div><div class=\"line\">68           let result = valueOfLifeWithoutSumOf(a, and: b)</div><div class=\"line\">-&gt; 69           print(result)</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div></pre></td></tr></table></figure>\n<p>想要继续 target 的执行过程直到遇到下次断点的话，运行这个命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) process continue</div><div class=\"line\"></div><div class=\"line\">(lldb) c // 或者只键入 &quot;c&quot;，这跟上一条命令是一样的</div></pre></td></tr></table></figure>\n<p>这个命令等同于 Xcode 调试器工具栏上的”continue“按钮：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-8d3a7affc384f574.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-779f316d847a475c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><code>breakpoint</code> 命令允许你用任何可能的方式操作断点。我们跳过最显而易见的命令：<code>breakpoint enable</code>, <code>breakpoint disable</code> 和 <code>breakpoint delete</code>。</p>\n<p>首先，查看你所有断点的话可以用如下示例中的 <code>list</code> 子命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) breakpoint list</div><div class=\"line\"></div><div class=\"line\">Current breakpoints:</div><div class=\"line\">1: file = &apos;/Users/Ahmed/Desktop/Recent/LLDB-Debugger-Exploration/LLDB-Debugger-Exploration/ViewController.swift&apos;, line = 95, exact_match = 0, locations = 1, resolved = 1, hit count = 1</div><div class=\"line\"></div><div class=\"line\">1.1: where = LLDB-Debugger-Exploration`LLDB_Debugger_Exploration.ViewController.valueOfLifeWithoutSumOf (Swift.Int, and : Swift.Int) -&gt; Swift.Int + 27 at ViewController.swift:95, address = 0x0000000107f3eb3b, resolved, hit count = 1</div><div class=\"line\"></div><div class=\"line\">2: file = &apos;/Users/Ahmed/Desktop/Recent/LLDB-Debugger-Exploration/LLDB-Debugger-Exploration/ViewController.swift&apos;, line = 60, exact_match = 0, locations = 1, resolved = 1, hit count = 1</div><div class=\"line\"></div><div class=\"line\">2.1: where = LLDB-Debugger-Exploration`LLDB_Debugger_Exploration.ViewController.viewDidLoad () -&gt; () + 521 at ViewController.swift:60, address = 0x0000000107f3e609, resolved, hit count = 1</div></pre></td></tr></table></figure>\n<p>列表中的第一个数字是是断点的 ID，你可以通过这个 ID 引用到指定的断点。现在让我们在控制台中设置一些新的断点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) breakpoint set -f ViewController.swift -l 96</div><div class=\"line\"></div><div class=\"line\">Breakpoint 3: where = LLDB-Debugger-Exploration`LLDB_Debugger_Exploration.ViewController.valueOfLifeWithoutSumOf (Swift.Int, and : Swift.Int) -&gt; Swift.Int + 45 at ViewController.swift:96, address = 0x0000000107f3eb4d</div></pre></td></tr></table></figure>\n<p>这个例子中的 <code>-f</code> 是你想要放置断点处的文件名，<code>-l</code> 是新断点的行数。还有一种更简洁的方式设置同样的断点，就是用快捷方式 <code>b</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) b ViewController.swift:96</div></pre></td></tr></table></figure>\n<p>同样地，你也可以用指定的正则（比如函数名）来设置断点，使用下面的命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) breakpoint set --func-regex valueOfLifeWithoutSumOf</div><div class=\"line\"></div><div class=\"line\">(lldb) b -r valueOfLifeWithoutSumOf // 上一条命令的简化版本</div></pre></td></tr></table></figure>\n<p>有些时候设置断点只命中一次也是有用的，然后指示这个断点立即删除自己，当然啦，有一个命令来处理这件事：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) breakpoint set --one-shot -f ViewController.swift -l 90</div><div class=\"line\"></div><div class=\"line\">(lldb) br s -o -f ViewController.swift -l 91 // 上一条命令的简化版本</div></pre></td></tr></table></figure>\n<p>现在我们来到了最有趣的部分 — 自动化断点。你知道你可以设置一个特定的动作使它在断点停住的时候执行吗？是的，你可以！你是否会在代码中用 <code>print()</code> 来在调试的时候得到你感兴趣的值？请不要再这样做了，这里有一种更好的方法。🙂</p>\n<p>通过 <code>breakpoint</code> 命令，你可以设置好命令，使其在断点命中时可以正确执行。你甚至可以设置”不可见“的断点，这种断点并不会打断运行过程。从技术上讲，这些“不可见的”断点其实是会中断执行的，但如果在命令链的末尾添上“continue”命令的话，你就不会注意到它。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) b ViewController.swift:96 // Let&apos;s add a breakpoint first</div><div class=\"line\"></div><div class=\"line\">Breakpoint 2: where = LLDB-Debugger-Exploration`LLDB_Debugger_Exploration.ViewController.valueOfLifeWithoutSumOf (Swift.Int, and : Swift.Int) -&gt; Swift.Int + 45 at ViewController.swift:96, address = 0x000000010c555b4d</div><div class=\"line\"></div><div class=\"line\">(lldb) breakpoint command add 2 // 准备某些命令</div><div class=\"line\"></div><div class=\"line\">Enter your debugger command(s).  Type &apos;DONE&apos; to end.</div><div class=\"line\">&gt; p sum // 打印变量 &quot;sum&quot; 的值</div><div class=\"line\">&gt; p a + b // 运行 a + b</div><div class=\"line\">&gt; DONE</div></pre></td></tr></table></figure>\n<p>为了确保你添加的命令是正确的，可以使用  <code>breakpoint command list &lt;breakpoint id&gt;</code> 子命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) breakpoint command list 2</div><div class=\"line\"></div><div class=\"line\">Breakpoint 2:</div><div class=\"line\">Breakpoint commands:</div><div class=\"line\">p sum</div><div class=\"line\">p a + b</div></pre></td></tr></table></figure>\n<p>当下次断点命中时我们就会在控制台看到下面的输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Process 36612 resuming</div><div class=\"line\">p sum</div><div class=\"line\">(Int) $R0 = 6</div><div class=\"line\"></div><div class=\"line\">p a + b</div><div class=\"line\">(Int) $R1 = 4</div></pre></td></tr></table></figure>\n<p>太棒了！这正是我们想要的。你可以通过在命令链的末尾添加 <code>continue</code> 命令让执行过程更加顺畅，这样你就不会停在这个断点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) breakpoint command add 2 // 准备某些命令</div><div class=\"line\"></div><div class=\"line\">Enter your debugger command(s).  Type &apos;DONE&apos; to end.</div><div class=\"line\">&gt; p sum // 打印变量 &quot;sum&quot; 的值</div><div class=\"line\">&gt; p a + b // 运行 a + b</div><div class=\"line\">&gt; continue // 第一次命中断点后直接恢复</div><div class=\"line\">&gt; DONE</div></pre></td></tr></table></figure>\n<p>结果会是这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">p sum</div><div class=\"line\">(Int) $R0 = 6</div><div class=\"line\"></div><div class=\"line\">p a + b</div><div class=\"line\">(Int) $R1 = 4</div><div class=\"line\"></div><div class=\"line\">continue</div><div class=\"line\">Process 36863 resuming</div><div class=\"line\">Command #3 &apos;continue&apos; continued the target.</div></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-a1c3ec912e68ba8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>通过 <code>thread</code> 命令和它的子命令，你可以完全操控执行流程：<code>step-over</code>, <code>step-in</code>, <code>step-out</code> 和 <code>continue</code>。这些命令等同于 Xcode 调试器工具栏上的流程控制按钮。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-0dfdf39bff20db4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>LLDB 同样也对这些特殊的命令预先定义好了快捷方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) thread step-over</div><div class=\"line\">(lldb) next // 和 &quot;thread step-over&quot; 命令效果一样</div><div class=\"line\">(lldb) n // 和 &quot;next&quot; 命令效果一样</div><div class=\"line\"></div><div class=\"line\">(lldb) thread step-in</div><div class=\"line\">(lldb) step // 和 &quot;thread step-in&quot; 命令效果一样</div><div class=\"line\">(lldb) s // 和 &quot;step&quot; 命令效果一样</div></pre></td></tr></table></figure>\n<p>为了获取当前线程的更多信息，我们只需要调用 <code>info</code> 子命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) thread info </div><div class=\"line\"></div><div class=\"line\">thread #1: tid = 0x17de17, 0x0000000109429a90 LLDB-Debugger-Exploration`ViewController.sumOf(a=2, b=2, self=0x00007fe775507390) -&gt; Int at ViewController.swift:90, queue = &apos;com.apple.main-thread&apos;, stop reason = step in</div></pre></td></tr></table></figure>\n<p>想要看到当前所有的活动线程的话使用 <code>list</code> 子命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) thread list</div><div class=\"line\"></div><div class=\"line\">Process 50693 stopped</div><div class=\"line\"></div><div class=\"line\">* thread #1: tid = 0x17de17, 0x0000000109429a90 LLDB-Debugger-Exploration`ViewController.sumOf(a=2, b=2, self=0x00007fe775507390) -&gt; Int at ViewController.swift:90, queue = &apos;com.apple.main-thread&apos;, stop reason = step in</div><div class=\"line\"></div><div class=\"line\">  thread #2: tid = 0x17df4a, 0x000000010daa4dc6  libsystem_kernel.dylib`kevent_qos + 10, queue = &apos;com.apple.libdispatch-manager&apos;</div><div class=\"line\">  </div><div class=\"line\">  thread #3: tid = 0x17df4b, 0x000000010daa444e libsystem_kernel.dylib`__workq_kernreturn + 10</div><div class=\"line\"></div><div class=\"line\">  thread #5: tid = 0x17df4e, 0x000000010da9c34a libsystem_kernel.dylib`mach_msg_trap + 10, name = &apos;com.apple.uikit.eventfetch-thread&apos;</div></pre></td></tr></table></figure>\n<h3 id=\"荣誉奖\"><a href=\"#荣誉奖\" class=\"headerlink\" title=\"荣誉奖\"></a>荣誉奖</h3><p><code>command</code>, <code>platform</code>, <code>gui</code></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-93fdf48e5daca771.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>在 LLDB 中你可以找到一个命令管理其他的命令，听起来很奇怪，但实际上它是非常有用的小工具。首先，它允许你从文件中执行一些 LLDB 命令，这样你就可以创建一个储存着一些实用命令的文件，然后就能立刻允许这些命令，就像是单个命令那样。这是所说的文件的简单例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">thread info // 显示当前线程的信息</div><div class=\"line\">br list // 显示所有的断点</div></pre></td></tr></table></figure>\n<p>下面是实际命令的样子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) command source /Users/Ahmed/Desktop/lldb-test-script</div><div class=\"line\"></div><div class=\"line\">Executing commands in &apos;/Users/Ahmed/Desktop/lldb-test-script&apos;.</div><div class=\"line\"></div><div class=\"line\">thread info</div><div class=\"line\">thread #1: tid = 0x17de17, 0x0000000109429a90 LLDB-Debugger-Exploration`ViewController.sumOf(a=2, b=2, self=0x00007fe775507390) -&gt; Int at ViewController.swift:90, queue = &apos;com.apple.main-thread&apos;, stop reason = step in</div><div class=\"line\"></div><div class=\"line\">br list</div><div class=\"line\">Current breakpoints:</div><div class=\"line\">1: file = &apos;/Users/Ahmed/Desktop/Recent/LLDB-Debugger-Exploration/LLDB-Debugger-Exploration/ViewController.swift&apos;, line = 60, exact_match = 0, locations = 1, resolved = 1, hit count = 0</div><div class=\"line\">1.1: where = LLDB-Debugger-Exploration`LLDB_Debugger_Exploration.ViewController.viewDidLoad () -&gt; () + 521 at ViewController.swift:60, address = 0x0000000109429609, resolved, hit count = 0</div></pre></td></tr></table></figure>\n<p>遗憾的是还有一个缺点，你不能传递任何参数给这个源文件（除非你在脚本文件本身中创建一个有效的变量）。</p>\n<p>如果你需要更高级的功能，你也可以使用 <code>script</code> 子命令，这个命令允许你用自定义的 Python 脚本 管理(<code>add</code>, <code>delete</code>, <code>import</code> 和 <code>list</code>)，通过 <code>script</code> 命令能实现真正的自动化。请阅读这个优秀的教程 <a href=\"http://www.fabianguerra.com/ios/introduction-to-lldb-python-scripting/\" target=\"_blank\" rel=\"external\">Python scripting for LLDB</a>。为了演示的目的，让我们创建一个脚本文件 script.py，然后写一个简单的命令 <strong>print_hello()</strong>，这个命令会在控制台中打印出“Hello Debugger!“：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">import lldb</div><div class=\"line\"></div><div class=\"line\">def print_hello(debugger, command, result, internal_dict):</div><div class=\"line\">\tprint &quot;Hello Debugger!&quot;</div><div class=\"line\">    </div><div class=\"line\">def __lldb_init_module(debugger, internal_dict):</div><div class=\"line\">\tdebugger.HandleCommand(&apos;command script add -f script.print_hello print_hello&apos;) // 控制脚本的初始化同时从这个模块中添加命令</div><div class=\"line\">\tprint &apos;The &quot;print_hello&quot; python command has been installed and is ready for use.&apos; // 打印确认一切正常</div></pre></td></tr></table></figure>\n<p>接下来我们需要导入一个 Python 模块，就能开始正常地使用我们的脚本命令了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) command import ~/Desktop/script.py</div><div class=\"line\"></div><div class=\"line\">The &quot;print_hello&quot; python command has been installed and is ready for use.</div><div class=\"line\"></div><div class=\"line\">(lldb) print_hello</div><div class=\"line\"></div><div class=\"line\">Hello Debugger!</div></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-463b54c539c5eb64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>你可以使用 <code>status</code> 子命令来快速检查当前的环境信息，<code>status</code> 会告诉你：SDK 路径、处理器的架构、操作系统版本甚至是该 SDK 可支持的设备的列表。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) platform status</div><div class=\"line\"></div><div class=\"line\">Platform: ios-simulator</div><div class=\"line\">Triple: x86_64-apple-macosx</div><div class=\"line\">OS Version: 10.12.5 (16F73)</div><div class=\"line\">Kernel: Darwin Kernel Version 16.6.0: Fri Apr 14 16:21:16 PDT 2017; root:xnu-3789.60.24~6/RELEASE_X86_64</div><div class=\"line\">Hostname: 127.0.0.1</div><div class=\"line\">WorkingDir: /</div><div class=\"line\">SDK Path: &quot;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk&quot;</div><div class=\"line\"></div><div class=\"line\">Available devices:</div><div class=\"line\">614F8701-3D93-4B43-AE86-46A42FEB905A: iPhone 4s</div><div class=\"line\">CD516CF7-2AE7-4127-92DF-F536FE56BA22: iPhone 5</div><div class=\"line\">0D76F30F-2332-4E0C-9F00-B86F009D59A3: iPhone 5s</div><div class=\"line\">3084003F-7626-462A-825B-193E6E5B9AA7: iPhone 6</div><div class=\"line\">...</div></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-7ac0c7f2bf73cecd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>你不能在 Xcode 中使用 LLDB GUI 模式，但你总是可以从终端使用（LLDB GUI 模式）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) gui</div><div class=\"line\"></div><div class=\"line\">// 如果你试着在 Xcode 中执行这个 gui 命令的话，你将会看到这个错误：the gui command requires an interactive terminal。</div></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-5d99e8dfc0af41df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>这就是 LLDB GUI 模式看起来的样子。</p>\n<h3 id=\"结论：\"><a href=\"#结论：\" class=\"headerlink\" title=\"结论：\"></a>结论：</h3><p>在这篇文章中，我只是浅析了 LLDB 的皮毛知识而已，即使 LLDB 已经有好些年头了，但是仍然有许多人并没有完全发挥出它的潜能。我只是对基本的方法做了一个概述，以及谈了 LLDB 如何自动化调试步骤。我希望这会是有帮助的。</p>\n<p>还有很多 LLDB 的方法并没有写到，然后还有一些视图调试技术我没有提及。如果你对这些话题感兴趣的话，请在下面留下你的评论，我会更加乐于写这些话题。</p>\n<p>我强烈建议你打开终端，启动 LLDB，只需要敲入 <code>help</code>，就会向你展示完整的文档。你可以花费数小时去阅读，但是我保证这将是一个合理的时间投资。因为了解你的工具是工程师真正产出的唯一途径。</p>\n<hr>\n<ul>\n<li><a href=\"http://lldb.llvm.org\" target=\"_blank\" rel=\"external\">LLDB 官方网站</a> —  你会在这里找到所有与 LLDB 相关的材料。文档、指南、教程、源文件以及更多。</li>\n<li><a href=\"https://developer.apple.com/library/content/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/Introduction.html#//apple_ref/doc/uid/TP40012917-CH1-SW1\" target=\"_blank\" rel=\"external\">LLDB Quick Start Guide by Apple</a> — 同样地，Apple 提供了很好的文档。这篇指南能帮你快速上手 LLDB，当然，他们也叙述了怎样不通过 Xcode 地用 LLDB 调试。</li>\n<li><a href=\"http://eli.thegreenplace.net/2011/01/23/how-debuggers-work-part-1\" title=\"Permalink to How debuggers work: Part 1 - Basics\" target=\"_blank\" rel=\"external\">How debuggers work: Part 1 — Basics</a> — 我非常喜欢这个系列的文章，这是对调试器实际工作方式很好的概述。文章介绍了用 C 语言手工编写的调试器代码要遵循的所有基本原理。我强烈建议你去阅读这个优秀系列的所有部分（<a href=\"http://eli.thegreenplace.net/2011/01/27/how-debuggers-work-part-2-breakpoints\" target=\"_blank\" rel=\"external\">第2部分</a>, <a href=\"http://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information\" target=\"_blank\" rel=\"external\">第3部分</a>）。</li>\n<li><a href=\"https://developer.apple.com/videos/play/wwdc2014/410/\" target=\"_blank\" rel=\"external\">WWDC14 Advanced Swift Debugging in LLDB</a> — 关于在 LLDB 中用 Swift 调试的一篇不错的概述，也讲了 LLDB 如何通过内建的方法和特性实现完整的调试操作，来帮你变得更加高效。</li>\n<li><a href=\"http://www.fabianguerra.com/ios/introduction-to-lldb-python-scripting/\" target=\"_blank\" rel=\"external\">Introduction To LLDB Python Scripting</a> — 这篇介绍 LLDB Python 脚本的指南能让你快速上手。</li>\n<li><a href=\"https://www.objc.io/issues/19-debugging/lldb-debugging\" target=\"_blank\" rel=\"external\">Dancing in the Debugger. A Waltz with LLDB</a>  — 对 LLDB 一些基础知识的介绍，有些知识有点过时了（比如说 <code>(lldb) thread return</code> 命令）。遗憾的是，它不能直接用于 Swift，因为它会对引用计数带了一些潜在的隐患。但是，这仍然是你开始 LLDB 之旅不错的文章。</li>\n</ul>\n","excerpt":"","more":"<blockquote>\n<ul>\n<li>原文地址：<a href=\"https://medium.com/flawless-app-stories/debugging-swift-code-with-lldb-b30c5cf2fd49\">Debugging Swift code with LLDB</a></li>\n<li>原文作者：<a href=\"https://medium.com/@ahmedsulaiman?source=post_header_lockup\">Ahmed Sulaiman</a></li>\n</ul>\n</blockquote>\n<h1 id=\"用-LLDB-调试-Swift-代码\"><a href=\"#用-LLDB-调试-Swift-代码\" class=\"headerlink\" title=\"用 LLDB 调试 Swift 代码\"></a>用 LLDB 调试 Swift 代码</h1><p><img src=\"http://upload-images.jianshu.io/upload_images/698554-035b0df85ea54d32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>作为工程师，我们花了差不多 70% 的时间在调试上，剩下的 20% 用来思考架构以及和组员沟通，仅仅只有 10% 的时间是真的在写代码的。</p>\n<blockquote>\n<p>调试就像是在犯罪电影中做侦探一样，同时你也是凶手。</p>\n<p>— <a href=\"https://twitter.com/fortes\">Filipe Fortes</a> 来自 Twitter</p>\n</blockquote>\n<p>所以让我们在这70%的时间尽可能愉悦是相当重要的。LLDB 就是来打救我们的。奇妙的 Xcode Debugger UI 展示了所有你可用的信息，而不用敲入任何一个 LLDB 命令。然而，控制台在我们的工作中同样也是很重要的一部分。现在让我们来分析一些最有用的 LLDB 技巧。我自己每天都在用它们进行调试。</p>\n<h3 id=\"从哪里开始呢？\"><a href=\"#从哪里开始呢？\" class=\"headerlink\" title=\"从哪里开始呢？\"></a>从哪里开始呢？</h3><p>LLDB 是一个庞大的工具，内置了很多有用的命令。我不会全部讲解，而是带你浏览最有用的命令。这是我们的计划：</p>\n<ol>\n<li>获取变量值： <code>expression</code>, <code>e</code>, <code>print</code>, <code>po</code>, <code>p</code></li>\n<li>获取整个应用程序的状态以及特定语言的命令：<code>bugreport</code>, <code>frame</code>, <code>language</code></li>\n<li>控制应用的执行流程：<code>process</code>, <code>breakpoint</code>, <code>thread</code>, <code>watchpoint</code></li>\n<li>荣誉奖：<code>command</code>, <code>platform</code>, <code>gui</code></li>\n</ol>\n<p>我还准备好了有用的 LLDB 命令说明和实例的表格，有需要的可以把它贴在 Mac 上面记住这些命令 🙂</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-4425e8ad483d1e91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>通过这条链接下载全尺寸的版本 —  <a href=\"https://www.dropbox.com/s/9sv67e7f2repbpb/lldb-commands-map.png?dl=0\">https://www.dropbox.com/s/9sv67e7f2repbpb/lldb-commands-map.png?dl=0</a></p>\n<h3 id=\"1-获取变量值和状态\"><a href=\"#1-获取变量值和状态\" class=\"headerlink\" title=\"1. 获取变量值和状态\"></a>1. 获取变量值和状态</h3><p>命令：<code>expression</code>, <code>e</code>, <code>print</code>, <code>po</code>, <code>p</code></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-28e3583bcef761ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>调试器的一个基础功能就是获取和修改变量的值。这就是 <code>expression</code> 或者 <code>e</code> 被创造的原因（当然他们还有更高级的功能）。您可以简单的在运行时执行任何表达式或命令。</p>\n<p>假设你现在正在调试方法 <code>valueOfLifeWithoutSumOf()</code> ：对两个数求和，再用42去减得到结果。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-f788753308492216.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>继续假设你一直得到错误的结果并且你并不知道是什么原因。所以你可以做以下的事来找到问题：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-ca27db839bd80a19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>或者。。。使用 LLDB 表达式在运行时修改值才是更好的方法，同时可以找出问题是在哪里出现的。首先，在你感兴趣的地方设置一个断点，然后运行你的应用。</p>\n<p>为了用 LLDB 格式打印指定的变量你应该调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) e &lt;variable&gt;</div></pre></td></tr></table></figure>\n<p>使用相同的命令来执行一些表达式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) e &lt;expression&gt;</div></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-42790260c5498fe3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) e sum </div><div class=\"line\">(Int) $R0 = 6 // 下面你也可以用 $R0 来引用这个变量（在本次调试过程中）</div><div class=\"line\"></div><div class=\"line\">(lldb) e sum = 4 // 修改变量 sum 的值</div><div class=\"line\"></div><div class=\"line\">(lldb) e sum </div><div class=\"line\">(Int) $R2 = 4 // 直到本次调试结束变量 sum 都会是 &quot;4&quot;</div></pre></td></tr></table></figure>\n<p><code>expression</code> 命令也有一些标志。在 <code>expression</code> 后面用双破折号 <code>--</code> 将标志和实际的表达式分隔开，就像这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) expression &lt;some flags&gt; -- &lt;variable&gt;</div></pre></td></tr></table></figure>\n<p><code>expression</code> 命令差不多有30种不同的标志。我鼓励你多去探索它们。在终端中键入以下命令可以看到完整的文档：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; lldb</div><div class=\"line\">&gt; (lldb) help # 获取所有变量的命令</div><div class=\"line\">&gt; (lldb) help expression # 获取所有表达式的子命令</div></pre></td></tr></table></figure>\n<p>我会在下列 <code>expression</code> 的标志上多停留一会儿：</p>\n<ul>\n<li><code>-D &lt;count&gt;</code> (<code>--depth &lt;count&gt;</code>)  — 设置在转储聚合类型时的最大递归深度（默认为无穷大）。</li>\n<li><code>-O</code> (<code>--object-description</code>)  — 如果可能的话，使用指定语言的描述API来显示。</li>\n<li><code>-T</code> (<code>--show-types</code>)  — 在转储值的时候显示变量类型。</li>\n<li><code>-f &lt;format&gt;</code> (<code>--format &lt;format&gt;</code>) — 指定一种用于显示的格式。</li>\n<li><code>-i &lt;boolean&gt;</code> (<code>--ignore-breakpoints &lt;boolean&gt;</code>) — 在运行表达式时忽略断点。</li>\n</ul>\n<p>假设我们有一个叫 <code>logger</code> 的对象，这个对象有一些字符串和结构体类型的属性。比如说，你可能只是想知道第一层的属性，那只需要用 <code>-D</code> 标志以及恰当的层级深度值，就像这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) e -D 1 -- logger</div><div class=\"line\"></div><div class=\"line\">(LLDB_Debugger_Exploration.Logger) $R5 = 0x0000608000087e90 &#123;</div><div class=\"line\">  currentClassName = &quot;ViewController&quot;</div><div class=\"line\">  debuggerStruct =&#123;...&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>默认情况下，LLDB 会无限地遍历该对象并且给你展示每个嵌套的对象的完整描述：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) e -- logger</div><div class=\"line\"></div><div class=\"line\">(LLDB_Debugger_Exploration.Logger) $R6 = 0x0000608000087e90 &#123;</div><div class=\"line\">  currentClassName = &quot;ViewController&quot;</div><div class=\"line\">  debuggerStruct = (methodName = &quot;name&quot;, lineNumber = 2, commandCounter = 23)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你也可以用 <code>e -O --</code> 获取对象的描述或者更简单地用别名 <code>po</code>，就像下面的示例一样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po logger</div><div class=\"line\"></div><div class=\"line\">&lt;Logger: 0x608000087e90&gt;</div></pre></td></tr></table></figure>\n<p>并不是很有描述性，不是吗？为了获取更加可阅读的描述，你自定义的类必须遵循 <code>CustomStringConvertible</code> 协议，同时实现 <code>var description: String { return ...}</code> 属性。接下来只需要用 <code>po</code> 就能返回可读的描述。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-67b11fbfba92f9c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>在本节的开始，我也提到了 <code>print</code> 命令。基本上 <code>print &lt;expression/variable&gt;</code> 就等同于 <code>expression -- &lt;expression/variable&gt;</code>。但是 <code>print</code> 命令不能带任何标志或者额外的参数。</p>\n<h3 id=\"2-获取整个-APP-的状态和指定语言的命令\"><a href=\"#2-获取整个-APP-的状态和指定语言的命令\" class=\"headerlink\" title=\"2. 获取整个 APP 的状态和指定语言的命令\"></a>2. 获取整个 APP 的状态和指定语言的命令</h3><p><code>bugreport</code>, <code>frame</code>, <code>language</code></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-b6780919d5f067a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>你是否经常复制粘贴崩溃日志到任务管理器中方便稍后能考虑这个问题吗？LLDB 提供了一个很好用的命令叫 <code>bugreport</code>，这个命令能生成当前应用状态的完整报告。在你偶然触发某些问题但是想在稍后再解决它时这个命令就会很有帮助了。为了能恢复应用的状态，你可以使用 <code>bugreport</code> 生成报告。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) bugreport unwind --outfile &lt;path to output file&gt;</div></pre></td></tr></table></figure>\n<p>最终的报告看起来就像下面截图中的例子一样：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-f8a7604c35151d5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br><code>bugreport</code> 命令输出的示例。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-2179c17fefec7742.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>假设你想要获取当前线程的当前栈帧的概述，<code>frame</code> 命令可以帮你完成：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-5207a680ff245ddf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>使用下面的代码片段来快速获取当前地址以及当前的环境条件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) frame info</div><div class=\"line\"></div><div class=\"line\">frame #0: 0x000000010bbe4b4d LLDB-Debugger-Exploration`ViewController.valueOfLifeWithoutSumOf(a=2, b=2, self=0x00007fa0c1406900) -&gt; Int at ViewController.swift:96</div></pre></td></tr></table></figure>\n<p>这些信息在本文后面将要说到的断点管理中非常有用。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-2b16ad60aed4e6af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>LLDB 有几个指定语言的命令，包括C++，Objective-C，Swift 和 RenderScript。在这篇文章中，我们重点关注 Swift。这是两个命令：<code>demangle</code> 和 <code>refcount</code>。</p>\n<p><code>demangle</code> 正如其名字而言，就是用来重组 Swift 类型名的（因为 Swift 在编译的时候会生成类型名来避免命名空间的问题）。如果你想了解多一点的话，我建议你看 WWDC14 的这个分享会 —  <a href=\"https://developer.apple.com/videos/play/wwdc2014/410/\">“Advanced Swift Debugging in LLDB”</a>。</p>\n<p><code>refcount</code> 同样也是一个相当直观的命令，能获得指定对象的引用数量。一起来看一下对象输出的示例，我们用了上一节讲到的对象 — <code>logger</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) language swift refcount logger</div><div class=\"line\"></div><div class=\"line\">refcount data: (strong = 4, weak = 0)</div></pre></td></tr></table></figure>\n<p>当然了，在你调试某些内存泄露问题时，这个命令就会很有帮助。</p>\n<h3 id=\"3-控制应用的执行流程\"><a href=\"#3-控制应用的执行流程\" class=\"headerlink\" title=\"3. 控制应用的执行流程\"></a>3. 控制应用的执行流程</h3><p><code>process</code>, <code>breakpoint</code>, <code>thread</code></p>\n<p>这节是我最喜欢的一节，因为在 LLDB 使用这几个命令（尤其是 <code>breakpoint</code> 命令），你可以在调试的时候使很多常规任务变得自动化，这样就能大大加快你的调试工作。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-190d8c7f7600ae0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>通过 <code>process</code> 基本上你就可以控制调试的过程了，还能链接到特定的 target 或者停止调试器。 但是因为 Xcode 已经自动地帮我们做好了这个工作了（Xcode 在任何时候运行一个 target 时都会连接 LLDB）。我不会在这儿讲太多，你可以在这篇 Apple 的指南中阅读一下如何用终端连接到一个 target — <a href=\"https://developer.apple.com/library/content/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-terminal-workflow-tutorial.html\">“Using LLDB as a Standalone Debugger”</a>。</p>\n<p>使用 <code>process status</code> 的话，你可以知道当前调试器停住的地址：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) process status</div><div class=\"line\"></div><div class=\"line\">Process 27408 stopped</div><div class=\"line\">* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = step over</div><div class=\"line\">frame #0: 0x000000010bbe4889 LLDB-Debugger-Exploration`ViewController.viewDidLoad(self=0x00007fa0c1406900) -&gt; () at ViewController.swift:69</div><div class=\"line\">66</div><div class=\"line\">67           let a = 2, b = 2</div><div class=\"line\">68           let result = valueOfLifeWithoutSumOf(a, and: b)</div><div class=\"line\">-&gt; 69           print(result)</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div></pre></td></tr></table></figure>\n<p>想要继续 target 的执行过程直到遇到下次断点的话，运行这个命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) process continue</div><div class=\"line\"></div><div class=\"line\">(lldb) c // 或者只键入 &quot;c&quot;，这跟上一条命令是一样的</div></pre></td></tr></table></figure>\n<p>这个命令等同于 Xcode 调试器工具栏上的”continue“按钮：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-8d3a7affc384f574.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-779f316d847a475c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><code>breakpoint</code> 命令允许你用任何可能的方式操作断点。我们跳过最显而易见的命令：<code>breakpoint enable</code>, <code>breakpoint disable</code> 和 <code>breakpoint delete</code>。</p>\n<p>首先，查看你所有断点的话可以用如下示例中的 <code>list</code> 子命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) breakpoint list</div><div class=\"line\"></div><div class=\"line\">Current breakpoints:</div><div class=\"line\">1: file = &apos;/Users/Ahmed/Desktop/Recent/LLDB-Debugger-Exploration/LLDB-Debugger-Exploration/ViewController.swift&apos;, line = 95, exact_match = 0, locations = 1, resolved = 1, hit count = 1</div><div class=\"line\"></div><div class=\"line\">1.1: where = LLDB-Debugger-Exploration`LLDB_Debugger_Exploration.ViewController.valueOfLifeWithoutSumOf (Swift.Int, and : Swift.Int) -&gt; Swift.Int + 27 at ViewController.swift:95, address = 0x0000000107f3eb3b, resolved, hit count = 1</div><div class=\"line\"></div><div class=\"line\">2: file = &apos;/Users/Ahmed/Desktop/Recent/LLDB-Debugger-Exploration/LLDB-Debugger-Exploration/ViewController.swift&apos;, line = 60, exact_match = 0, locations = 1, resolved = 1, hit count = 1</div><div class=\"line\"></div><div class=\"line\">2.1: where = LLDB-Debugger-Exploration`LLDB_Debugger_Exploration.ViewController.viewDidLoad () -&gt; () + 521 at ViewController.swift:60, address = 0x0000000107f3e609, resolved, hit count = 1</div></pre></td></tr></table></figure>\n<p>列表中的第一个数字是是断点的 ID，你可以通过这个 ID 引用到指定的断点。现在让我们在控制台中设置一些新的断点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) breakpoint set -f ViewController.swift -l 96</div><div class=\"line\"></div><div class=\"line\">Breakpoint 3: where = LLDB-Debugger-Exploration`LLDB_Debugger_Exploration.ViewController.valueOfLifeWithoutSumOf (Swift.Int, and : Swift.Int) -&gt; Swift.Int + 45 at ViewController.swift:96, address = 0x0000000107f3eb4d</div></pre></td></tr></table></figure>\n<p>这个例子中的 <code>-f</code> 是你想要放置断点处的文件名，<code>-l</code> 是新断点的行数。还有一种更简洁的方式设置同样的断点，就是用快捷方式 <code>b</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) b ViewController.swift:96</div></pre></td></tr></table></figure>\n<p>同样地，你也可以用指定的正则（比如函数名）来设置断点，使用下面的命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) breakpoint set --func-regex valueOfLifeWithoutSumOf</div><div class=\"line\"></div><div class=\"line\">(lldb) b -r valueOfLifeWithoutSumOf // 上一条命令的简化版本</div></pre></td></tr></table></figure>\n<p>有些时候设置断点只命中一次也是有用的，然后指示这个断点立即删除自己，当然啦，有一个命令来处理这件事：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) breakpoint set --one-shot -f ViewController.swift -l 90</div><div class=\"line\"></div><div class=\"line\">(lldb) br s -o -f ViewController.swift -l 91 // 上一条命令的简化版本</div></pre></td></tr></table></figure>\n<p>现在我们来到了最有趣的部分 — 自动化断点。你知道你可以设置一个特定的动作使它在断点停住的时候执行吗？是的，你可以！你是否会在代码中用 <code>print()</code> 来在调试的时候得到你感兴趣的值？请不要再这样做了，这里有一种更好的方法。🙂</p>\n<p>通过 <code>breakpoint</code> 命令，你可以设置好命令，使其在断点命中时可以正确执行。你甚至可以设置”不可见“的断点，这种断点并不会打断运行过程。从技术上讲，这些“不可见的”断点其实是会中断执行的，但如果在命令链的末尾添上“continue”命令的话，你就不会注意到它。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) b ViewController.swift:96 // Let&apos;s add a breakpoint first</div><div class=\"line\"></div><div class=\"line\">Breakpoint 2: where = LLDB-Debugger-Exploration`LLDB_Debugger_Exploration.ViewController.valueOfLifeWithoutSumOf (Swift.Int, and : Swift.Int) -&gt; Swift.Int + 45 at ViewController.swift:96, address = 0x000000010c555b4d</div><div class=\"line\"></div><div class=\"line\">(lldb) breakpoint command add 2 // 准备某些命令</div><div class=\"line\"></div><div class=\"line\">Enter your debugger command(s).  Type &apos;DONE&apos; to end.</div><div class=\"line\">&gt; p sum // 打印变量 &quot;sum&quot; 的值</div><div class=\"line\">&gt; p a + b // 运行 a + b</div><div class=\"line\">&gt; DONE</div></pre></td></tr></table></figure>\n<p>为了确保你添加的命令是正确的，可以使用  <code>breakpoint command list &lt;breakpoint id&gt;</code> 子命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) breakpoint command list 2</div><div class=\"line\"></div><div class=\"line\">Breakpoint 2:</div><div class=\"line\">Breakpoint commands:</div><div class=\"line\">p sum</div><div class=\"line\">p a + b</div></pre></td></tr></table></figure>\n<p>当下次断点命中时我们就会在控制台看到下面的输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Process 36612 resuming</div><div class=\"line\">p sum</div><div class=\"line\">(Int) $R0 = 6</div><div class=\"line\"></div><div class=\"line\">p a + b</div><div class=\"line\">(Int) $R1 = 4</div></pre></td></tr></table></figure>\n<p>太棒了！这正是我们想要的。你可以通过在命令链的末尾添加 <code>continue</code> 命令让执行过程更加顺畅，这样你就不会停在这个断点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) breakpoint command add 2 // 准备某些命令</div><div class=\"line\"></div><div class=\"line\">Enter your debugger command(s).  Type &apos;DONE&apos; to end.</div><div class=\"line\">&gt; p sum // 打印变量 &quot;sum&quot; 的值</div><div class=\"line\">&gt; p a + b // 运行 a + b</div><div class=\"line\">&gt; continue // 第一次命中断点后直接恢复</div><div class=\"line\">&gt; DONE</div></pre></td></tr></table></figure>\n<p>结果会是这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">p sum</div><div class=\"line\">(Int) $R0 = 6</div><div class=\"line\"></div><div class=\"line\">p a + b</div><div class=\"line\">(Int) $R1 = 4</div><div class=\"line\"></div><div class=\"line\">continue</div><div class=\"line\">Process 36863 resuming</div><div class=\"line\">Command #3 &apos;continue&apos; continued the target.</div></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-a1c3ec912e68ba8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>通过 <code>thread</code> 命令和它的子命令，你可以完全操控执行流程：<code>step-over</code>, <code>step-in</code>, <code>step-out</code> 和 <code>continue</code>。这些命令等同于 Xcode 调试器工具栏上的流程控制按钮。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-0dfdf39bff20db4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>LLDB 同样也对这些特殊的命令预先定义好了快捷方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) thread step-over</div><div class=\"line\">(lldb) next // 和 &quot;thread step-over&quot; 命令效果一样</div><div class=\"line\">(lldb) n // 和 &quot;next&quot; 命令效果一样</div><div class=\"line\"></div><div class=\"line\">(lldb) thread step-in</div><div class=\"line\">(lldb) step // 和 &quot;thread step-in&quot; 命令效果一样</div><div class=\"line\">(lldb) s // 和 &quot;step&quot; 命令效果一样</div></pre></td></tr></table></figure>\n<p>为了获取当前线程的更多信息，我们只需要调用 <code>info</code> 子命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) thread info </div><div class=\"line\"></div><div class=\"line\">thread #1: tid = 0x17de17, 0x0000000109429a90 LLDB-Debugger-Exploration`ViewController.sumOf(a=2, b=2, self=0x00007fe775507390) -&gt; Int at ViewController.swift:90, queue = &apos;com.apple.main-thread&apos;, stop reason = step in</div></pre></td></tr></table></figure>\n<p>想要看到当前所有的活动线程的话使用 <code>list</code> 子命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) thread list</div><div class=\"line\"></div><div class=\"line\">Process 50693 stopped</div><div class=\"line\"></div><div class=\"line\">* thread #1: tid = 0x17de17, 0x0000000109429a90 LLDB-Debugger-Exploration`ViewController.sumOf(a=2, b=2, self=0x00007fe775507390) -&gt; Int at ViewController.swift:90, queue = &apos;com.apple.main-thread&apos;, stop reason = step in</div><div class=\"line\"></div><div class=\"line\">  thread #2: tid = 0x17df4a, 0x000000010daa4dc6  libsystem_kernel.dylib`kevent_qos + 10, queue = &apos;com.apple.libdispatch-manager&apos;</div><div class=\"line\">  </div><div class=\"line\">  thread #3: tid = 0x17df4b, 0x000000010daa444e libsystem_kernel.dylib`__workq_kernreturn + 10</div><div class=\"line\"></div><div class=\"line\">  thread #5: tid = 0x17df4e, 0x000000010da9c34a libsystem_kernel.dylib`mach_msg_trap + 10, name = &apos;com.apple.uikit.eventfetch-thread&apos;</div></pre></td></tr></table></figure>\n<h3 id=\"荣誉奖\"><a href=\"#荣誉奖\" class=\"headerlink\" title=\"荣誉奖\"></a>荣誉奖</h3><p><code>command</code>, <code>platform</code>, <code>gui</code></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-93fdf48e5daca771.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>在 LLDB 中你可以找到一个命令管理其他的命令，听起来很奇怪，但实际上它是非常有用的小工具。首先，它允许你从文件中执行一些 LLDB 命令，这样你就可以创建一个储存着一些实用命令的文件，然后就能立刻允许这些命令，就像是单个命令那样。这是所说的文件的简单例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">thread info // 显示当前线程的信息</div><div class=\"line\">br list // 显示所有的断点</div></pre></td></tr></table></figure>\n<p>下面是实际命令的样子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) command source /Users/Ahmed/Desktop/lldb-test-script</div><div class=\"line\"></div><div class=\"line\">Executing commands in &apos;/Users/Ahmed/Desktop/lldb-test-script&apos;.</div><div class=\"line\"></div><div class=\"line\">thread info</div><div class=\"line\">thread #1: tid = 0x17de17, 0x0000000109429a90 LLDB-Debugger-Exploration`ViewController.sumOf(a=2, b=2, self=0x00007fe775507390) -&gt; Int at ViewController.swift:90, queue = &apos;com.apple.main-thread&apos;, stop reason = step in</div><div class=\"line\"></div><div class=\"line\">br list</div><div class=\"line\">Current breakpoints:</div><div class=\"line\">1: file = &apos;/Users/Ahmed/Desktop/Recent/LLDB-Debugger-Exploration/LLDB-Debugger-Exploration/ViewController.swift&apos;, line = 60, exact_match = 0, locations = 1, resolved = 1, hit count = 0</div><div class=\"line\">1.1: where = LLDB-Debugger-Exploration`LLDB_Debugger_Exploration.ViewController.viewDidLoad () -&gt; () + 521 at ViewController.swift:60, address = 0x0000000109429609, resolved, hit count = 0</div></pre></td></tr></table></figure>\n<p>遗憾的是还有一个缺点，你不能传递任何参数给这个源文件（除非你在脚本文件本身中创建一个有效的变量）。</p>\n<p>如果你需要更高级的功能，你也可以使用 <code>script</code> 子命令，这个命令允许你用自定义的 Python 脚本 管理(<code>add</code>, <code>delete</code>, <code>import</code> 和 <code>list</code>)，通过 <code>script</code> 命令能实现真正的自动化。请阅读这个优秀的教程 <a href=\"http://www.fabianguerra.com/ios/introduction-to-lldb-python-scripting/\">Python scripting for LLDB</a>。为了演示的目的，让我们创建一个脚本文件 script.py，然后写一个简单的命令 <strong>print_hello()</strong>，这个命令会在控制台中打印出“Hello Debugger!“：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">import lldb</div><div class=\"line\"></div><div class=\"line\">def print_hello(debugger, command, result, internal_dict):</div><div class=\"line\">\tprint &quot;Hello Debugger!&quot;</div><div class=\"line\">    </div><div class=\"line\">def __lldb_init_module(debugger, internal_dict):</div><div class=\"line\">\tdebugger.HandleCommand(&apos;command script add -f script.print_hello print_hello&apos;) // 控制脚本的初始化同时从这个模块中添加命令</div><div class=\"line\">\tprint &apos;The &quot;print_hello&quot; python command has been installed and is ready for use.&apos; // 打印确认一切正常</div></pre></td></tr></table></figure>\n<p>接下来我们需要导入一个 Python 模块，就能开始正常地使用我们的脚本命令了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) command import ~/Desktop/script.py</div><div class=\"line\"></div><div class=\"line\">The &quot;print_hello&quot; python command has been installed and is ready for use.</div><div class=\"line\"></div><div class=\"line\">(lldb) print_hello</div><div class=\"line\"></div><div class=\"line\">Hello Debugger!</div></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-463b54c539c5eb64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>你可以使用 <code>status</code> 子命令来快速检查当前的环境信息，<code>status</code> 会告诉你：SDK 路径、处理器的架构、操作系统版本甚至是该 SDK 可支持的设备的列表。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) platform status</div><div class=\"line\"></div><div class=\"line\">Platform: ios-simulator</div><div class=\"line\">Triple: x86_64-apple-macosx</div><div class=\"line\">OS Version: 10.12.5 (16F73)</div><div class=\"line\">Kernel: Darwin Kernel Version 16.6.0: Fri Apr 14 16:21:16 PDT 2017; root:xnu-3789.60.24~6/RELEASE_X86_64</div><div class=\"line\">Hostname: 127.0.0.1</div><div class=\"line\">WorkingDir: /</div><div class=\"line\">SDK Path: &quot;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk&quot;</div><div class=\"line\"></div><div class=\"line\">Available devices:</div><div class=\"line\">614F8701-3D93-4B43-AE86-46A42FEB905A: iPhone 4s</div><div class=\"line\">CD516CF7-2AE7-4127-92DF-F536FE56BA22: iPhone 5</div><div class=\"line\">0D76F30F-2332-4E0C-9F00-B86F009D59A3: iPhone 5s</div><div class=\"line\">3084003F-7626-462A-825B-193E6E5B9AA7: iPhone 6</div><div class=\"line\">...</div></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-7ac0c7f2bf73cecd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>你不能在 Xcode 中使用 LLDB GUI 模式，但你总是可以从终端使用（LLDB GUI 模式）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) gui</div><div class=\"line\"></div><div class=\"line\">// 如果你试着在 Xcode 中执行这个 gui 命令的话，你将会看到这个错误：the gui command requires an interactive terminal。</div></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-5d99e8dfc0af41df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>这就是 LLDB GUI 模式看起来的样子。</p>\n<h3 id=\"结论：\"><a href=\"#结论：\" class=\"headerlink\" title=\"结论：\"></a>结论：</h3><p>在这篇文章中，我只是浅析了 LLDB 的皮毛知识而已，即使 LLDB 已经有好些年头了，但是仍然有许多人并没有完全发挥出它的潜能。我只是对基本的方法做了一个概述，以及谈了 LLDB 如何自动化调试步骤。我希望这会是有帮助的。</p>\n<p>还有很多 LLDB 的方法并没有写到，然后还有一些视图调试技术我没有提及。如果你对这些话题感兴趣的话，请在下面留下你的评论，我会更加乐于写这些话题。</p>\n<p>我强烈建议你打开终端，启动 LLDB，只需要敲入 <code>help</code>，就会向你展示完整的文档。你可以花费数小时去阅读，但是我保证这将是一个合理的时间投资。因为了解你的工具是工程师真正产出的唯一途径。</p>\n<hr>\n<ul>\n<li><a href=\"http://lldb.llvm.org\">LLDB 官方网站</a> —  你会在这里找到所有与 LLDB 相关的材料。文档、指南、教程、源文件以及更多。</li>\n<li><a href=\"https://developer.apple.com/library/content/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/Introduction.html#//apple_ref/doc/uid/TP40012917-CH1-SW1\">LLDB Quick Start Guide by Apple</a> — 同样地，Apple 提供了很好的文档。这篇指南能帮你快速上手 LLDB，当然，他们也叙述了怎样不通过 Xcode 地用 LLDB 调试。</li>\n<li><a href=\"http://eli.thegreenplace.net/2011/01/23/how-debuggers-work-part-1\" title=\"Permalink to How debuggers work: Part 1 - Basics\">How debuggers work: Part 1 — Basics</a> — 我非常喜欢这个系列的文章，这是对调试器实际工作方式很好的概述。文章介绍了用 C 语言手工编写的调试器代码要遵循的所有基本原理。我强烈建议你去阅读这个优秀系列的所有部分（<a href=\"http://eli.thegreenplace.net/2011/01/27/how-debuggers-work-part-2-breakpoints\">第2部分</a>, <a href=\"http://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information\">第3部分</a>）。</li>\n<li><a href=\"https://developer.apple.com/videos/play/wwdc2014/410/\">WWDC14 Advanced Swift Debugging in LLDB</a> — 关于在 LLDB 中用 Swift 调试的一篇不错的概述，也讲了 LLDB 如何通过内建的方法和特性实现完整的调试操作，来帮你变得更加高效。</li>\n<li><a href=\"http://www.fabianguerra.com/ios/introduction-to-lldb-python-scripting/\">Introduction To LLDB Python Scripting</a> — 这篇介绍 LLDB Python 脚本的指南能让你快速上手。</li>\n<li><a href=\"https://www.objc.io/issues/19-debugging/lldb-debugging\">Dancing in the Debugger. A Waltz with LLDB</a>  — 对 LLDB 一些基础知识的介绍，有些知识有点过时了（比如说 <code>(lldb) thread return</code> 命令）。遗憾的是，它不能直接用于 Swift，因为它会对引用计数带了一些潜在的隐患。但是，这仍然是你开始 LLDB 之旅不错的文章。</li>\n</ul>\n"},{"title":"(翻译)iOS的Core Text教程：制作一个杂志应用","date":"2017-07-21T02:46:34.000Z","_content":"\n原文链接：https://www.raywenderlich.com/153591/core-text-tutorial-ios-making-magazine-app  \n\n![杂志，Core Text和大脑！](http://upload-images.jianshu.io/upload_images/698554-57c6d4f3c2df1c38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n更新说明：本教程已经由Lyndsey Scott升级为Swift 4和Xcode 9。最初的教程由Marin Todorov所创作。\n\nCore Text是一个底层的文本引擎，当与Core Graphics/Quartz框架配合使用的时候，可以对布局和格式进行细粒度的控制。\n\n随着iOS 7的发布，Apple公司发布了一个名叫Text Kit的高级库，可以用来储存、布局和显示具有各种排版特征的文本。虽然Text Kit在布局文本时不仅强大而且大部分情况下已经足够用了，但是Core Text可以提供更多的控制。例如，如果你想直接使用Quartz的话，那就请用Core Text吧。如果你需要构建你自己的布局引擎的话，Core Text将会帮助你生成[字形(glyphs)并且根据互相之间的关系摆放好这些字形，并具有好的排版的所有特性](https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/CoreText_Programming/Introduction/Introduction.html#//apple_ref/doc/uid/TP40005533)。\n\n本教程将会引导你使用Core Text去创作一本非常简单的杂志应用...给僵尸看的！\n呃，僵尸月刊的读者朋友们已经宽容的答应了，只要你本教程认真使用Core Text的话，就不会吃掉你的大脑了...所以呢，你还是尽快开始吧！\n> 说明：要充分读懂本教程，你首先需要了解iOS开发的基础。如果你是iOS开发的新人的话，你应该首先查看本网站的[其他教程](https://www.raywenderlich.com/category/ios)。\n\n### 开始\n打开Xcode，用Single View Application模板创建一个新的Swift universal project，命名为CoreTextMagazine。\n\n然后，将Core Text框架加到你的工程中：\n1. 单击工程导航器中的工程文件(在左边的导航条上)\n2. 在\"General\"按钮下，滚动到底部的\"Linked Frameworks and Libraries\"\n3. 单击\"+\"按钮然后找到\"CoreText\"\n4. 选中\"CoreText.framework\"然后点击\"Add\"按钮。就这么简单！\n\n现在工程已经配置好了，是时候开始写代码了。\n\n### 添加一个Core Text View\n首先，你将要创建一个自定义的UIView，在这个UIView的draw(_:)方法中将会用到Core Text。\n\n创建一个新的继承于UIView的Cocoa Touch Class file，命名为CTView。打开CTView.swift，然后在 ``` import UIKit ``` 语句下面加上下面的代码：\n```Objective-C\nimport CoreText\n```\n\n然后，将这个自定义的view设置为应用的主视图。打开Main.storyboard，在右边打开Utilities菜单，然后在顶部工具条单击Identity Inspector图标。在Interface Builder的左侧菜单中，选中View。现在在Utilities菜单的Class字段中应该写着UIView。在Class字段输入CTView以子类化主视图控制器的视图，然后点击回车键。\n![](http://upload-images.jianshu.io/upload_images/698554-e426ca1cea702142.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n接下来，打开CTView.swift并将被注释掉的draw(_:)方法全都替换成下面的代码：\n```Objective-C\n//1\t \t \noverride func draw(_ rect: CGRect) {\t \t \n  // 2\t \t \n  guard let context = UIGraphicsGetCurrentContext() else { return }\t \t \n  // 3\t \t \n  let path = CGMutablePath()\t \t \n  path.addRect(bounds)\t \t \n  // 4\n  let attrString = NSAttributedString(string: \"Hello World\")\n  // 5\n  let framesetter = CTFramesetterCreateWithAttributedString(attrString as CFAttributedString)\n  // 6\n  let frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, attrString.length), path, nil) \n  // 7\n  CTFrameDraw(frame, context)\n}\n```\n\n让我们一步一步地分析一下代码：\n1. 在视图创建的时候，draw(_:)会自动运行，渲染这个视图的背景图层。\n2. 打开用于绘制的当前图形上下文。\n3. 创建一条用来限定绘图区域的路径，在这个例子中就是整个视图的bounds。\n4. 在Core Text，使用NSAttributedString而不是String或者NSString，保存文本和属性(attributes)。初始化一个\"Hello World\"的属性字符串。\n5. CTFramesetterCreateWithAttributedString使用提供的属性字符串创建一个CTFramesetter。CTFramesetter会管理你引用的字体和绘图区域。\n6. 通过使CTFramesetterCreateFrame在路径内渲染整个字符串，可以创建一个CTFrame。\n7. CTFrameDraw在给定的上下文中绘制CTFrame。\n   这就是你绘制简单文本所需要做的全部了！Build，运行然后查看结果。\n   ![](http://upload-images.jianshu.io/upload_images/698554-bdfec1f8b8817617.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n噢不...似乎看起来不太对。就像很多的底层API一样，Core Text使用的是Y-flipped坐标系统。更糟糕的是，内容在竖直方向上也翻转了！\n\n添加以下代码到``` guard let context ```语句以修正内容的方向：\n```Objective-C\n// Flip the coordinate system\ncontext.textMatrix = .identity\ncontext.translateBy(x: 0, y: bounds.size.height)\ncontext.scaleBy(x: 1.0, y: -1.0)\n```\n\n这段代码通过应用变换(transformation)到视图的上下文来将内容翻转。\n\nBuild然后运行app。别担心状态栏重叠的问题，你接下来会学到怎样通过约束解决这个问题。\n![](http://upload-images.jianshu.io/upload_images/698554-5febf55f8e6bc993.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n祝贺你的第一个Core Text软件！僵尸们很高兴看到你的进步。\n\n### Core Text对象模型\n如果你对CTFramesetter和CTFrame感到有点疑惑也是正常的，也是时候说明一下它们了。:]\nCore Text对象模型如下所示：\n![](http://upload-images.jianshu.io/upload_images/698554-e7418de12cb5ae45.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n当你提供一个NSAttributedString创建一个CTFramesetter对象实例的时候，一个CTTypesetter的实例对象会自动为你创建用以管理你的字体。接下来你会在渲染文本的时候用到这个CTFramesetter去创建一个或者多个frame。\n\n当你创建了一个frame，你可以为这个frame提供文本的一个subrange去渲染这段文本。Core Text会自动为文本的每一行创建一个CTLine，并为每个具有相同格式的字符创建一个CTRun。举个例子，Core Text只会创建一个CTRun用于同一行中的几个红色的单词，创建一个CTRun用于接下来的纯文本，创建一个CTRun用于粗体段落等等。Core Text创建会根据你提供的NSAttributedString中的属性创建CTRun。此外，上面说到的每一个CTRun对象都可以采用不同的属性，也就是说，你可以很好地控制字距、连字、宽度、高度等。\n\n### 深入杂志App！\n下载并解压[the zombie magazine materials](http://www.raywenderlich.com/downloads/zombieMagMaterials.zip)。拖拽解压出来的文件夹到你的Xcode工程中。当弹出对话框时，确保Copy items if needed和Create groups选中。\n\n为了创建这个app，你需要对文本应用各种属性。你将要创建一个用标签设置杂志格式的简单文本标记解析器。\n\n创建一个新的Cocoa Touch Class file，命名为MarkupParser，继承于NSObject。\n\n首先，我们快速看一下zombies.txt。看看它是如何在整个文本中包含括号内的格式化标签的。\"img src\"标签指向杂志的图片，而\"font color/face\"标签则确定了文本的颜色和字体。\n\n打开MarkupParser.swift然后将它的内容替换为以下代码：\n```Objective-C\nimport UIKit\nimport CoreText\n\nclass MarkupParser: NSObject {\n  \n  // MARK: - Properties\n  var color: UIColor = .black\n  var fontName: String = \"Arial\"\n  var attrString: NSMutableAttributedString!\n  var images: [[String: Any]] = []\n\n  // MARK: - Initializers\n  override init() {\n    super.init()\n  }\n  \n  // MARK: - Internal\n  func parseMarkup(_ markup: String) {\n\n  }\n}\n```\n你在这段代码中添加了属性持有字体和文本颜色，设置了它们的初始值。创建了一个变量去持有parseMarkup(_:)生成的属性字符串。还创建了一个数组用来持有定义了尺寸、位置以及从文本中解析出来的图片文件名等信息的键值对。\n\n通常来说，写一个解析器并不是一个轻松的工作，但是本教程所实现的解析器将会非常简易，只提供开放标签的支持，也就意味着一个标签会决定紧随着这个标签的文本的样式，直到找到一个新的标签。这段文本的标记如下所示：\n```\nThese are <font color=\"red\">red<font color=\"black\"> and\n<font color=\"blue\">blue <font color=\"black\">words.\n```\n输出如下所示：\n![](http://upload-images.jianshu.io/upload_images/698554-6d55091e685937d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n将以下代码加到 ``` parseMarkup(_:) ``` 方法中：\n```Objective-C\n//1\nattrString = NSMutableAttributedString(string: \"\")\n//2 \ndo {\n  let regex = try NSRegularExpression(pattern: \"(.*?)(<[^>]+>|\\\\Z)\",\n                                      options: [.caseInsensitive,\n                                                .dotMatchesLineSeparators])\n  //3\n  let chunks = regex.matches(in: markup, \n                             options: NSRegularExpression.MatchingOptions(rawValue: 0), \n                             range: NSRange(location: 0,\n                                            length: markup.characters.count))\n} catch _ {\n}\n```\n1. attrString初始为空，但是最后会包含解析出来的标记。\n2. 这个正则表达式，匹配了紧跟着这些标签的文本块。它就好像在说：“去查看字符串直到你找到一个开头的括号，然后查看字符串直到你找到一个结束的括号（或者文档的末尾）”。\n3. 搜索regex匹配到的整个标记范围，然后生成一个NSTextCheckingResult的数组。\n\n> 想要学习更多有关正则表达式的内容，访问[NSRegularExpression Tutorial](https://www.raywenderlich.com/86205/nsregularexpression-swift-tutorial)吧。\n\n现在你已经解析了所有的文本并将所有格式化的标签都放进了chunks中，你要做的就是遍历chunks数组去生成对应的属性字符串。\n\n但在那之前，你是否留意到matches(in:options:range:)方法是如何接受一个NSRange作为参数的吗？在你应用NSRegularExpression到你的标记String的时候会有大量NSRange到Range的转化。Swift已经成为了我们所有人的好帮手，所以它值得帮助。\n\n还是在MarkupParser.swift中，将下面的extension加到文件的最后面：\n```Objective-C\n// MARK: - String\nextension String {\n  func range(from range: NSRange) -> Range<String.Index>? {\n    guard let from16 = utf16.index(utf16.startIndex,\n                                   offsetBy: range.location,\n                                   limitedBy: utf16.endIndex),\n      let to16 = utf16.index(from16, offsetBy: range.length, limitedBy: utf16.endIndex),\n      let from = String.Index(from16, within: self),\n      let to = String.Index(to16, within: self) else {\n        return nil\n   }\n\n    return from ..< to\n  }\n}\n```\n上面这个函数将以NSRange表示的字符串的起止索引转换为了String.UTF16View.Index格式，即UTF-16字符串中的位置(position)集合，然后将每个String.UTF16View.Index格式转换为String.Index格式。String.Index格式在组合时，会生成Swift的范围格式：Range。只要索引是有效的，这个函数就会返回原始NSRange格式对应的Range格式。\n\n现在是时候回头处理文本和标签数组了。\n![](http://upload-images.jianshu.io/upload_images/698554-2c69a03c16835494.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在parseMarkup(_:)函数中添加一下代码到 ``` let chunks ``` 到下面(在do循环语句块中)：\n```Objective-C\nlet defaultFont: UIFont = .systemFont(ofSize: UIScreen.main.bounds.size.height / 40)\n//1\nfor chunk in chunks {  \n  //2\n  guard let markupRange = markup.range(from: chunk.range) else { continue }\n  //3    \n  let parts = markup.substring(with: markupRange).components(separatedBy: \"<\")\n  //4\n  let font = UIFont(name: fontName, size: UIScreen.main.bounds.size.height / 40) ?? defaultFont       \n  //5\n  let attrs = [NSAttributedStringKey.foregroundColor: color, NSAttributedStringKey.font: font] as [NSAttributedStringKey : Any]\n  let text = NSMutableAttributedString(string: parts[0], attributes: attrs)\n  attrString.append(text)\n}\n```\n1. 循环chunks数组。\n2. 获取当前NSTextCheckingResult的range，展开Range<String.Index>并且只要range存在就继续执行以下的语句块。\n3. 将chunk用\"<\"分割成几部分。第一部分包含了杂志的文本而第二部分包含了对应的标签(如果标签存在的话)。\n4. 用fontName生成字体，现在的默认字体是\"Arial\"，并且根据设备屏幕创建了字体的大小。假如fontName不能产生有效的UIFont的话，将默认字体设为当前字体。\n5. 创建字体格式的字典，将其应用于parts[0]以创建属性字符串，然后将该字符串添加到结果字符串后面。\n\n将下面用来处理\"font\"标签的代码插到attrString.append(text)下面：\n```Objective-C\n// 1\nif parts.count <= 1 {\n  continue\n}\nlet tag = parts[1]\n//2\nif tag.hasPrefix(\"font\") {\n  let colorRegex = try NSRegularExpression(pattern: \"(?<=color=\\\")\\\\w+\", \n                                           options: NSRegularExpression.Options(rawValue: 0))\n  colorRegex.enumerateMatches(in: tag, \n    options: NSRegularExpression.MatchingOptions(rawValue: 0), \n    range: NSMakeRange(0, tag.characters.count)) { (match, _, _) in\n      //3\n      if let match = match,\n        let range = tag.range(from: match.range) {\n          let colorSel = NSSelectorFromString(tag.substring(with:range) + \"Color\")\n          color = UIColor.perform(colorSel).takeRetainedValue() as? UIColor ?? .black\n      }\n  }\n  //5    \n  let faceRegex = try NSRegularExpression(pattern: \"(?<=face=\\\")[^\\\"]+\",\n                                          options: NSRegularExpression.Options(rawValue: 0))\n  faceRegex.enumerateMatches(in: tag, \n    options: NSRegularExpression.MatchingOptions(rawValue: 0), \n    range: NSMakeRange(0, tag.characters.count)) { (match, _, _) in\n\n      if let match = match,\n        let range = tag.range(from: match.range) {\n          fontName = tag.substring(with: range)\n      }\n  }\n} //end of font parsing\n```\n1. 如果parts数组元素少于2个，则跳过这个循环语句块。否则的话，将parts的第二部分存为tag。\n2. 如果tag以\"font\"开始则创建一个正则表达式去匹配字体的\"color\"值，然后用这个正则去枚举匹配到的tag中的\"color\"值。在这种情况下，只应该有一个匹配到的颜色值。\n3. 如果enumerateMatches(in:options:range:using:)函数返回标签的一个有效的match和一个有效的range的话，就去搜索出指示值，接着用这个颜色值生成一个UIColor的selector。执行这个selector所返回得到的color(如果存在的话)会赋值到你的类的color属性上，如果返回的color不存在的话，color属性会被赋值为black。\n4. 同样的，创建一个正则表达式去处理文本中字体的\"face\"值。如果匹配到一个\"face\"值，则将类的fontName属性设置为匹配的\"face\"值。\n\n干得漂亮！现在parseMarkup(_:)函数已经可以获取文本中的标记并生成一个对应的NSAttributedString了。\n\n现在也是时候把你的app喂给一些僵尸了！我的意思是，喂一些僵尸给你的app... 也就是说，(开始处理)zombies.txt。\n\n事实上，显示出被赋予的内容才是UIView的职责所在，而不是去加载内容。打开CTView.swift然后将下面代码添加到draw(_:)方法之前：\n```Objective-C\n// MARK: - Properties\nvar attrString: NSAttributedString!\n\n// MARK: - Internal\nfunc importAttrString(_ attrString: NSAttributedString) {\n  self.attrString = attrString\n}\n```\n\n接下来，将 ``` let attrString = NSAttributedString(string: \"Hello World\") ``` 从draw(_:)函数中删除。\n\n这段代码中你创建了一个实例变量持有属性字符串和一个函数以便app的其他地方可以设置这个属性字符串。\n\n然后，打开ViewController.swift并将以下代码添加到viewDidLoad()中：\n```Objective-C\n// 1\nguard let file = Bundle.main.path(forResource: \"zombies\", ofType: \"txt\") else { return }\n  \ndo {\n  let text = try String(contentsOfFile: file, encoding: .utf8)\n  // 2\n  let parser = MarkupParser()\n  parser.parseMarkup(text)\n  (view as? CTView)?.importAttrString(parser.attrString)\n} catch _ {\n}\n```\n然后一步步的过一下这段代码：\n1. 从zombie.txt文件中加载文本。\n2. 创建一个新的解析器，传入文本作为参数，然后将返回的属性字符串赋给ViewController的CTView。\n\nBuild并且运行这个app！\n![](http://upload-images.jianshu.io/upload_images/698554-a816139b2aed7b2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n简直太棒了！归功于这50多行解析代码你可以轻松的用文本文件持有你杂志app的内容了。\n\n### 基本的杂志布局\n如果你认为僵尸新闻的每月杂志只能全塞在一个可怜的页面中，那么你就错了！幸运的是，Core Text在文本列布局时相当有用，因为CTFrameGetVisibleStringRange可以告诉给定frame的情况下显示多少文本才是合适的。也就是说，你可以创建一列文本，当这一列塞满文本之后，你可以知道并开始新的一列。\n\n就本app而言，你需要先打印出列，然后集列成页，再集页成文。未免冒犯这些亡灵，所以。。。你还是尽快把把你的CTView改成继承于UIScrollView。\n打开CTView.swift然后将 ``` class CTView ``` 一行改成以下代码：\n```Objective-C\nclass CTView: UIScrollView {\n```\n看到了吗，僵尸老爷？现在这个app已经支持永恒不死了！对的，行、滚动以及翻页现在都是可用的了。\n![](http://upload-images.jianshu.io/upload_images/698554-f7c0cd8d0f47a219.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n到现在为止，你已经在draw(_:)方法里创建了framesetter和frame了，不过由于你有很多不同格式的文本列，所以最好还是创建一个独立的实例表征所述的文本列。\n\n创建一个新的名为CTColumnView的Cocoa Touch Class file，继承于UIView。\n打开CTColumnView.swift并添加下列初始代码：\n```Objective-C\nimport UIKit\nimport CoreText\n\nclass CTColumnView: UIView {\n  \n  // MARK: - Properties\n  var ctFrame: CTFrame!\n  \n  // MARK: - Initializers\n  required init(coder aDecoder: NSCoder) {\n    super.init(coder: aDecoder)!\n  }\n  \n  required init(frame: CGRect, ctframe: CTFrame) {\n    super.init(frame: frame)\n    self.ctFrame = ctframe\n    backgroundColor = .white\n  }\n  \n  // MARK: - Life Cycle\n  override func draw(_ rect: CGRect) {\n    guard let context = UIGraphicsGetCurrentContext() else { return }\n      \n    context.textMatrix = .identity\n    context.translateBy(x: 0, y: bounds.size.height)\n    context.scaleBy(x: 1.0, y: -1.0)\n      \n    CTFrameDraw(ctFrame, context)\n  }\n}\n```\n跟开始在CTView里做的工作一样，这段代码生成了一个CTFrame。自定义的初始化函数init(frame:ctframe:)设置了：\n1. 这个视图的frame。\n2. 在当前上下文中绘制的CTFrame。\n3. 以及将这个视图的背景颜色设置为白色。\n\n接下来，创建一个新的swift文件命名为CTSettings.swift，用来持有你的文本列的设置。\n将CTSettings.swift的内容替换为以下代码：\n```Objective-C\nimport UIKit\nimport Foundation\n\nclass CTSettings {\n  //1\n  // MARK: - Properties\n  let margin: CGFloat = 20\n  var columnsPerPage: CGFloat!\n  var pageRect: CGRect!\n  var columnRect: CGRect!\n  \n  // MARK: - Initializers\n  init() {\n    //2\n    columnsPerPage = UIDevice.current.userInterfaceIdiom == .phone ? 1 : 2\n    //3\n    pageRect = UIScreen.main.bounds.insetBy(dx: margin, dy: margin)\n    //4\n    columnRect = CGRect(x: 0,\n                        y: 0,\n                        width: pageRect.width / columnsPerPage,\n                        height: pageRect.height).insetBy(dx: margin, dy: margin)\n  }\n}\n```\n1. 这些属性将用来确定page的约束(在这个教程中约束默认是20)、在每一个页中文本列的数量、包含文本列的每一页的frame以及每一页中的每一个文本列的frame。\n2. 由于这本杂志的服务对象是拿着iPhone和iPad的僵尸们，iPad上显示两列，iPhone上显示一列，这样的列数对于任意的屏幕尺寸来说都是适宜的。\n3. 用约束的大小计算出来的pageRect去布局页面的边界。\n4. 用每一页的文本列数量划分pageRect的宽度并配合约束去计算出columnRect。\n\n打开CTView.swift，将文件中的内容整个替换成下列代码：\n```Objective-C\nimport UIKit\nimport CoreText\n\nclass CTView: UIScrollView {\n\n  //1\n  func buildFrames(withAttrString attrString: NSAttributedString,\n                   andImages images: [[String: Any]]) {\n    //2\n    isPagingEnabled = true\n    //3\n    let framesetter = CTFramesetterCreateWithAttributedString(attrString as CFAttributedString)\n    //4\n    var pageView = UIView()\n    var textPos = 0\n    var columnIndex: CGFloat = 0\n    var pageIndex: CGFloat = 0\n    let settings = CTSettings()\n    //5\n    while textPos < attrString.length {\n    }\n  }\n}\n```\n1. buildFrames(withAttrString:andImages:)函数会创建并添加CTColumnView到滚动视图。\n2. 运行滚动视图的翻页行为；也就是说，用户不管什么时候停止滚动，滚动视图都能卡到位置使得同一时间只有一个完整的页面在显示。\n3. CTFramesetter framesetter会为创建的每一列CTFrame提供属性字符串。\n4. UIView pageView会作为每个页面文本列对应的子视图的容器；textPos会持续跟踪接下来的文字；columnIndex会持续跟踪当前列；pageIndex会持续跟踪当前页；同时settings能让你访问app的约束尺寸、每页的列、页的frame和列frame的设置等。\n5. 你将要遍历attrString然后逐列布局文本直到当前文本的位置到了最末尾。\n\n是时候开始遍历attrString了。把下列代码加进 ``` while textPos < attrString.length { ``` 里面：\n```Objective-C\n//1\nif columnIndex.truncatingRemainder(dividingBy: settings.columnsPerPage) == 0 {\n  columnIndex = 0\n  pageView = UIView(frame: settings.pageRect.offsetBy(dx: pageIndex * bounds.width, dy: 0))\n  addSubview(pageView)\n  //2\n  pageIndex += 1\n}   \n//3\nlet columnXOrigin = pageView.frame.size.width / settings.columnsPerPage\nlet columnOffset = columnIndex * columnXOrigin\nlet columnFrame = settings.columnRect.offsetBy(dx: columnOffset, dy: 0)\n```\n1. 如果用每页列数划分的列索引等于0，也就能说明这是所在页的第一列，那么就创建新页视图持有这些列。为了设置这些列的frame，需要获取算好约束的setting. pageRect按照当前页面索引乘以屏幕宽度来对其原点计算偏移量。这样才能在翻页滚动视图内部保证杂志每一页都在前一页的右边。\n2. 自增pageIndex。\n3. 通过settings.columnsPerPage将pageView的宽度除以第一列的x原点，将该列乘以列索引以获得列偏移量；然后通过采用标准columnRect并通过columnOffset将其x原点偏移来创建当前列的frame。\n\n接下来把下列代码加到columnFrame初始化方法的下面：\n```Objective-C\n//1   \nlet path = CGMutablePath()\npath.addRect(CGRect(origin: .zero, size: columnFrame.size))\nlet ctframe = CTFramesetterCreateFrame(framesetter, CFRangeMake(textPos, 0), path, nil)\n//2\nlet column = CTColumnView(frame: columnFrame, ctframe: ctframe)\npageView.addSubview(column)\n//3\nlet frameRange = CTFrameGetVisibleStringRange(ctframe)\ntextPos += frameRange.length\n//4\ncolumnIndex += 1\n```\n1. 创建一个CGMutablePath大小的列，然后从textPos开始在合适的范围内渲染足够多的文本到CTFrame中。\n2. 用CGRect类型的columnFrame和CTFrame类型的ctframe创建一个CTColumnView并将这一列加到pageView上。\n3. 用CTFrameGetVisibleStringRange(_:)函数计算用列限制的文本的范围，然后用这个计算出来的范围自增textPos的值。\n4. 在遍历到下一列之前将column的索引值加1。\n\n最后在遍历完成之后设置好滚动视图的size：\n```Objective-C\ncontentSize = CGSize(width: CGFloat(pageIndex) * bounds.size.width,\n                     height: bounds.size.height)\n```\n\n通过将内容大小设置为屏幕宽度乘以页数，僵尸先生现在可以滚动杂志到最后了。\n\n打开ViewController.swift，将原先的下列代码：\n```Objective-C\n(view as? CTView)?.importAttrString(parser.attrString)\n```\n替换为下列代码：\n```Objective-C\n(view as? CTView)?.buildFrames(withAttrString: parser.attrString, andImages: parser.images)\n```\nBuild并在iPad上运行应用。检查一下双列布局！在页面间左右拖动试试。看起来棒极了！\n![](http://upload-images.jianshu.io/upload_images/698554-b14a1b1e5fe27a9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n你已经有了按列排列且格式化好的文本了，但是你还忘了图片呢。用Core Text绘制图片并不是那么简单，Core Text毕竟是一个文本处理框架，但是呢在你刚刚创建的标记解析器的帮助之下，添加图片也没有那么糟糕。\n\n### 用Core Text绘制图片\n虽然Core Text不能直接绘制图片，但是作为一个布局引擎，它可以为图片留开空间。通过设置为CTRun的delegate，你可以确定CTRun的ascent空间、decent空间和宽度。就像下面这样：\n![](http://upload-images.jianshu.io/upload_images/698554-2f22c94e5dde428a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n当Core Text遇到一个设置了CTRunDelegate的CTRun，它就会询问delegate：“我需要留多少空间给这块的数据”。通过在CTRunDelegate中设置这些属性，您可以在文本中给图片留开空位。\n\n首先让(解析器)支持\"img\"标签。打开MarkupParser.swift然后找到\"} //end of font parsing\"语句。并将下面代码加到后面：\n```Objective-C\n//1\nelse if tag.hasPrefix(\"img\") { \n      \n  var filename:String = \"\"\n  let imageRegex = try NSRegularExpression(pattern: \"(?<=src=\\\")[^\\\"]+\",\n                                           options: NSRegularExpression.Options(rawValue: 0))\n  imageRegex.enumerateMatches(in: tag, \n    options: NSRegularExpression.MatchingOptions(rawValue: 0), \n    range: NSMakeRange(0, tag.characters.count)) { (match, _, _) in\n\n    if let match = match,\n      let range = tag.range(from: match.range) {\n        filename = tag.substring(with: range)\n    }\n  }\n  //2\n  let settings = CTSettings()\n  var width: CGFloat = settings.columnRect.width\n  var height: CGFloat = 0\n\n  if let image = UIImage(named: filename) {\n    height = width * (image.size.height / image.size.width)\n    // 3\n    if height > settings.columnRect.height - font.lineHeight {\n      height = settings.columnRect.height - font.lineHeight\n      width = height * (image.size.width / image.size.height)\n    }\n  }\n}\n```\n1. 如果tag是以\"img\"开头的话就用正则去查找图片的\"src\"值，比如图片的filename。\n2. 设置图片宽度为列的宽度同时在保证图片宽高比的情况下设置图片高度。\n3. 如果图片的高度高过了列的高度就将列的高度设置为图片高度并减少图片的宽度以维持图片的宽高比。\n\n接下来，将下面代码加到紧随 ``` if let image ``` 语句块后面的地方：\n```Objective-C\n//1\nimages += [[\"width\": NSNumber(value: Float(width)),\n            \"height\": NSNumber(value: Float(height)),\n            \"filename\": filename,\n            \"location\": NSNumber(value: attrString.length)]]\n//2\nstruct RunStruct {\n  let ascent: CGFloat\n  let descent: CGFloat\n  let width: CGFloat\n}\n\nlet extentBuffer = UnsafeMutablePointer<RunStruct>.allocate(capacity: 1)\nextentBuffer.initialize(to: RunStruct(ascent: height, descent: 0, width: width))\n//3\nvar callbacks = CTRunDelegateCallbacks(version: kCTRunDelegateVersion1, dealloc: { (pointer) in\n}, getAscent: { (pointer) -> CGFloat in\n  let d = pointer.assumingMemoryBound(to: RunStruct.self)\n  return d.pointee.ascent\n}, getDescent: { (pointer) -> CGFloat in\n  let d = pointer.assumingMemoryBound(to: RunStruct.self)\n  return d.pointee.descent\n}, getWidth: { (pointer) -> CGFloat in\n  let d = pointer.assumingMemoryBound(to: RunStruct.self)\n  return d.pointee.width\n})\n//4\nlet delegate = CTRunDelegateCreate(&callbacks, extentBuffer)\n//5\nlet attrDictionaryDelegate = [(kCTRunDelegateAttributeName as NSAttributedStringKey): (delegate as Any)]              \nattrString.append(NSAttributedString(string: \" \", attributes: attrDictionaryDelegate))\n```\n1. 添加包含图片尺寸、文件名和文本位置的字典到images数组中。\n2. 定义RunStruct结构图去持有用来描述空格的属性。然后初始化一个包含RunStruct的指针，这个结构体的ascent等于图片的高度，宽度等于图片的宽度。\n3. 创建一个CTRunDelegateCallbacks返回ascent、decent和宽度。\n4. 用CTRunDelegateCreate生成一个绑定了callbacks和数据的委托实例。\n5. 创建一个包含委托实例的属性字典，然后添加单个空格到attrString末尾，属性字典其实就是用来持有这些占位空格的位置和大小信息的。\n\n现在MarkupParser可以处理\"img\"标签了，你需要调整CTColumnView和CTView去渲染图片。\n\n打开CTColumnView.swift。把下列用来持有列的图片和图片的frame的代码加到 ``` var ctFrame:CTFrame! ```  语句后面：\n```Objective-C\nvar images: [(image: UIImage, frame: CGRect)] = []\n```\n再然后就是把下列代码加到draw(_:)函数的后面：\n```Objective-C\nfor imageData in images {\n  if let image = imageData.image.cgImage {\n    let imgBounds = imageData.frame\n    context.draw(image, in: imgBounds)\n  }\n}\n```\n在这段代码中你遍历了每一张图片然后把图片绘制到上下文它正确的frame内。\n\n然后打开CTView.swift并添加下面这个属性到类的顶部：\n```Objective-C\n// MARK: - Properties\nvar imageIndex: Int!\n```\nimageIndex会持续追踪当前的图片索引在你绘制CTColumnView时。\n\n接下来，把下面一行代码添加到buildFrames(withAttrString:andImages:)函数上方：\n```Objective-C\nimageIndex = 0\n```\n这标志着images数组的第一个元素。\n\n然后添加下述attachImagesWithFrame(_:ctframe:margin:columnView)函数到buildFrames(withAttrString:andImages:)函数后面：\n```Objective-C\nfunc attachImagesWithFrame(_ images: [[String: Any]],\n                           ctframe: CTFrame,\n                           margin: CGFloat,\n                           columnView: CTColumnView) {\n  //1\n  let lines = CTFrameGetLines(ctframe) as NSArray\n  //2\n  var origins = [CGPoint](repeating: .zero, count: lines.count)\n  CTFrameGetLineOrigins(ctframe, CFRangeMake(0, 0), &origins)\n  //3\n  var nextImage = images[imageIndex]\n  guard var imgLocation = nextImage[\"location\"] as? Int else {\n    return\n  }\n  //4\n  for lineIndex in 0..<lines.count {\n    let line = lines[lineIndex] as! CTLine\n    //5\n    if let glyphRuns = CTLineGetGlyphRuns(line) as? [CTRun], \n      let imageFilename = nextImage[\"filename\"] as? String, \n      let img = UIImage(named: imageFilename)  { \n        for run in glyphRuns {\n\n        }\n    }\n  }\n}\n```\n1. 获取一个ctframe的CTLine对象的数组。\n2. 用CTFrameGetOrigins去复制ctframe的行初始点坐标到origins数组中。通过设置长度为0的range，CTFrameGetOrigins将知道要遍历整个CTFrame。\n3. 设置nextImage以包含当前图像的属性数据。如果nextImage包含图像的位置，请将其展开并继续；否则，早点返回函数。\n4. 遍历下一行文本。\n5. 如果这一行的字形、文件名和图片文件名都存在的话，则遍历这一行的字形。\n\n然后呢，添加下列代码到字形的for-loop语句块中：\n```Objective-C\n// 1\nlet runRange = CTRunGetStringRange(run)    \nif runRange.location > imgLocation || runRange.location + runRange.length <= imgLocation {\n  continue\n}\n//2\nvar imgBounds: CGRect = .zero\nvar ascent: CGFloat = 0       \nimgBounds.size.width = CGFloat(CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &ascent, nil, nil))\nimgBounds.size.height = ascent\n//3\nlet xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, nil)\nimgBounds.origin.x = origins[lineIndex].x + xOffset \nimgBounds.origin.y = origins[lineIndex].y\n//4\ncolumnView.images += [(image: img, frame: imgBounds)]\n//5\nimageIndex! += 1\nif imageIndex < images.count {\n  nextImage = images[imageIndex]\n  imgLocation = (nextImage[\"location\"] as AnyObject).intValue\n}\n```\n1. 如果当前字形的范围不包含下一个图像，则跳过循环的其余部分。否则，在此渲染图像。\n2. 使用CTRunGetTypographicBounds计算图像宽度，并将高度设置为ascent。\n3. 用CTLineGetOffsetForStringIndex获取线的x偏移，然后将其添加到imgBounds的起点坐标。\n4. 将图像及其frame添加到当前的CTColumnView。\n5. 增加图像索引。如果images[imageIndex]是一个图片，则更新nextImage和imgLocation，以便它们引用下一个图像。\n   ![](http://upload-images.jianshu.io/upload_images/698554-b00481e7f05f0bce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n好了！干得漂亮！基本完成，还剩下最后一步。\n\n在buildFrames(withAttrString:andImages:)内部的pageView.addSubview(column)上面添加以下代码用以附加图像(如果图像存在的话)：\n```Objective-C\nif images.count > imageIndex {\n  attachImagesWithFrame(images, ctframe: ctframe, margin: settings.margin, columnView: column)\n}\n```\nBuild并且运行到iPhone和iPad上：\n![](http://upload-images.jianshu.io/upload_images/698554-9a01dbec1c6ea94d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n恭喜你！因为感激你所做的这些辛苦的工作，僵尸先生决定不吃你的大脑了！\n\n### 何去何从\n在[这里](https://koenig-media.raywenderlich.com/uploads/2017/06/CoreTextMagazine-2.zip)查看完整的项目。\n\n正如介绍中所述，Text Kit通常可以替代Core Text；所以尝试用Text Kit编写同一个教程吧，比较一下两者有什么不同。也就是说，这堂Core Text课程不会白学！\nText Kit提供免费桥接(toll free bridging)到Core Text，因此你可以根据你的需要轻松地在框架之间进行转换。\n\n有任何问题，意见或建议？加入论坛讨论吧！","source":"_posts/翻译杂志应用.md","raw":"---\ntitle: (翻译)iOS的Core Text教程：制作一个杂志应用\ndate: 2017-07-21 10:46:34\ntags:\n- iOS\n- 翻译\ncategories:\n- ruanpapa--技术贴\n---\n\n原文链接：https://www.raywenderlich.com/153591/core-text-tutorial-ios-making-magazine-app  \n\n![杂志，Core Text和大脑！](http://upload-images.jianshu.io/upload_images/698554-57c6d4f3c2df1c38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n更新说明：本教程已经由Lyndsey Scott升级为Swift 4和Xcode 9。最初的教程由Marin Todorov所创作。\n\nCore Text是一个底层的文本引擎，当与Core Graphics/Quartz框架配合使用的时候，可以对布局和格式进行细粒度的控制。\n\n随着iOS 7的发布，Apple公司发布了一个名叫Text Kit的高级库，可以用来储存、布局和显示具有各种排版特征的文本。虽然Text Kit在布局文本时不仅强大而且大部分情况下已经足够用了，但是Core Text可以提供更多的控制。例如，如果你想直接使用Quartz的话，那就请用Core Text吧。如果你需要构建你自己的布局引擎的话，Core Text将会帮助你生成[字形(glyphs)并且根据互相之间的关系摆放好这些字形，并具有好的排版的所有特性](https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/CoreText_Programming/Introduction/Introduction.html#//apple_ref/doc/uid/TP40005533)。\n\n本教程将会引导你使用Core Text去创作一本非常简单的杂志应用...给僵尸看的！\n呃，僵尸月刊的读者朋友们已经宽容的答应了，只要你本教程认真使用Core Text的话，就不会吃掉你的大脑了...所以呢，你还是尽快开始吧！\n> 说明：要充分读懂本教程，你首先需要了解iOS开发的基础。如果你是iOS开发的新人的话，你应该首先查看本网站的[其他教程](https://www.raywenderlich.com/category/ios)。\n\n### 开始\n打开Xcode，用Single View Application模板创建一个新的Swift universal project，命名为CoreTextMagazine。\n\n然后，将Core Text框架加到你的工程中：\n1. 单击工程导航器中的工程文件(在左边的导航条上)\n2. 在\"General\"按钮下，滚动到底部的\"Linked Frameworks and Libraries\"\n3. 单击\"+\"按钮然后找到\"CoreText\"\n4. 选中\"CoreText.framework\"然后点击\"Add\"按钮。就这么简单！\n\n现在工程已经配置好了，是时候开始写代码了。\n\n### 添加一个Core Text View\n首先，你将要创建一个自定义的UIView，在这个UIView的draw(_:)方法中将会用到Core Text。\n\n创建一个新的继承于UIView的Cocoa Touch Class file，命名为CTView。打开CTView.swift，然后在 ``` import UIKit ``` 语句下面加上下面的代码：\n```Objective-C\nimport CoreText\n```\n\n然后，将这个自定义的view设置为应用的主视图。打开Main.storyboard，在右边打开Utilities菜单，然后在顶部工具条单击Identity Inspector图标。在Interface Builder的左侧菜单中，选中View。现在在Utilities菜单的Class字段中应该写着UIView。在Class字段输入CTView以子类化主视图控制器的视图，然后点击回车键。\n![](http://upload-images.jianshu.io/upload_images/698554-e426ca1cea702142.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n接下来，打开CTView.swift并将被注释掉的draw(_:)方法全都替换成下面的代码：\n```Objective-C\n//1\t \t \noverride func draw(_ rect: CGRect) {\t \t \n  // 2\t \t \n  guard let context = UIGraphicsGetCurrentContext() else { return }\t \t \n  // 3\t \t \n  let path = CGMutablePath()\t \t \n  path.addRect(bounds)\t \t \n  // 4\n  let attrString = NSAttributedString(string: \"Hello World\")\n  // 5\n  let framesetter = CTFramesetterCreateWithAttributedString(attrString as CFAttributedString)\n  // 6\n  let frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, attrString.length), path, nil) \n  // 7\n  CTFrameDraw(frame, context)\n}\n```\n\n让我们一步一步地分析一下代码：\n1. 在视图创建的时候，draw(_:)会自动运行，渲染这个视图的背景图层。\n2. 打开用于绘制的当前图形上下文。\n3. 创建一条用来限定绘图区域的路径，在这个例子中就是整个视图的bounds。\n4. 在Core Text，使用NSAttributedString而不是String或者NSString，保存文本和属性(attributes)。初始化一个\"Hello World\"的属性字符串。\n5. CTFramesetterCreateWithAttributedString使用提供的属性字符串创建一个CTFramesetter。CTFramesetter会管理你引用的字体和绘图区域。\n6. 通过使CTFramesetterCreateFrame在路径内渲染整个字符串，可以创建一个CTFrame。\n7. CTFrameDraw在给定的上下文中绘制CTFrame。\n   这就是你绘制简单文本所需要做的全部了！Build，运行然后查看结果。\n   ![](http://upload-images.jianshu.io/upload_images/698554-bdfec1f8b8817617.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n噢不...似乎看起来不太对。就像很多的底层API一样，Core Text使用的是Y-flipped坐标系统。更糟糕的是，内容在竖直方向上也翻转了！\n\n添加以下代码到``` guard let context ```语句以修正内容的方向：\n```Objective-C\n// Flip the coordinate system\ncontext.textMatrix = .identity\ncontext.translateBy(x: 0, y: bounds.size.height)\ncontext.scaleBy(x: 1.0, y: -1.0)\n```\n\n这段代码通过应用变换(transformation)到视图的上下文来将内容翻转。\n\nBuild然后运行app。别担心状态栏重叠的问题，你接下来会学到怎样通过约束解决这个问题。\n![](http://upload-images.jianshu.io/upload_images/698554-5febf55f8e6bc993.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n祝贺你的第一个Core Text软件！僵尸们很高兴看到你的进步。\n\n### Core Text对象模型\n如果你对CTFramesetter和CTFrame感到有点疑惑也是正常的，也是时候说明一下它们了。:]\nCore Text对象模型如下所示：\n![](http://upload-images.jianshu.io/upload_images/698554-e7418de12cb5ae45.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n当你提供一个NSAttributedString创建一个CTFramesetter对象实例的时候，一个CTTypesetter的实例对象会自动为你创建用以管理你的字体。接下来你会在渲染文本的时候用到这个CTFramesetter去创建一个或者多个frame。\n\n当你创建了一个frame，你可以为这个frame提供文本的一个subrange去渲染这段文本。Core Text会自动为文本的每一行创建一个CTLine，并为每个具有相同格式的字符创建一个CTRun。举个例子，Core Text只会创建一个CTRun用于同一行中的几个红色的单词，创建一个CTRun用于接下来的纯文本，创建一个CTRun用于粗体段落等等。Core Text创建会根据你提供的NSAttributedString中的属性创建CTRun。此外，上面说到的每一个CTRun对象都可以采用不同的属性，也就是说，你可以很好地控制字距、连字、宽度、高度等。\n\n### 深入杂志App！\n下载并解压[the zombie magazine materials](http://www.raywenderlich.com/downloads/zombieMagMaterials.zip)。拖拽解压出来的文件夹到你的Xcode工程中。当弹出对话框时，确保Copy items if needed和Create groups选中。\n\n为了创建这个app，你需要对文本应用各种属性。你将要创建一个用标签设置杂志格式的简单文本标记解析器。\n\n创建一个新的Cocoa Touch Class file，命名为MarkupParser，继承于NSObject。\n\n首先，我们快速看一下zombies.txt。看看它是如何在整个文本中包含括号内的格式化标签的。\"img src\"标签指向杂志的图片，而\"font color/face\"标签则确定了文本的颜色和字体。\n\n打开MarkupParser.swift然后将它的内容替换为以下代码：\n```Objective-C\nimport UIKit\nimport CoreText\n\nclass MarkupParser: NSObject {\n  \n  // MARK: - Properties\n  var color: UIColor = .black\n  var fontName: String = \"Arial\"\n  var attrString: NSMutableAttributedString!\n  var images: [[String: Any]] = []\n\n  // MARK: - Initializers\n  override init() {\n    super.init()\n  }\n  \n  // MARK: - Internal\n  func parseMarkup(_ markup: String) {\n\n  }\n}\n```\n你在这段代码中添加了属性持有字体和文本颜色，设置了它们的初始值。创建了一个变量去持有parseMarkup(_:)生成的属性字符串。还创建了一个数组用来持有定义了尺寸、位置以及从文本中解析出来的图片文件名等信息的键值对。\n\n通常来说，写一个解析器并不是一个轻松的工作，但是本教程所实现的解析器将会非常简易，只提供开放标签的支持，也就意味着一个标签会决定紧随着这个标签的文本的样式，直到找到一个新的标签。这段文本的标记如下所示：\n```\nThese are <font color=\"red\">red<font color=\"black\"> and\n<font color=\"blue\">blue <font color=\"black\">words.\n```\n输出如下所示：\n![](http://upload-images.jianshu.io/upload_images/698554-6d55091e685937d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n将以下代码加到 ``` parseMarkup(_:) ``` 方法中：\n```Objective-C\n//1\nattrString = NSMutableAttributedString(string: \"\")\n//2 \ndo {\n  let regex = try NSRegularExpression(pattern: \"(.*?)(<[^>]+>|\\\\Z)\",\n                                      options: [.caseInsensitive,\n                                                .dotMatchesLineSeparators])\n  //3\n  let chunks = regex.matches(in: markup, \n                             options: NSRegularExpression.MatchingOptions(rawValue: 0), \n                             range: NSRange(location: 0,\n                                            length: markup.characters.count))\n} catch _ {\n}\n```\n1. attrString初始为空，但是最后会包含解析出来的标记。\n2. 这个正则表达式，匹配了紧跟着这些标签的文本块。它就好像在说：“去查看字符串直到你找到一个开头的括号，然后查看字符串直到你找到一个结束的括号（或者文档的末尾）”。\n3. 搜索regex匹配到的整个标记范围，然后生成一个NSTextCheckingResult的数组。\n\n> 想要学习更多有关正则表达式的内容，访问[NSRegularExpression Tutorial](https://www.raywenderlich.com/86205/nsregularexpression-swift-tutorial)吧。\n\n现在你已经解析了所有的文本并将所有格式化的标签都放进了chunks中，你要做的就是遍历chunks数组去生成对应的属性字符串。\n\n但在那之前，你是否留意到matches(in:options:range:)方法是如何接受一个NSRange作为参数的吗？在你应用NSRegularExpression到你的标记String的时候会有大量NSRange到Range的转化。Swift已经成为了我们所有人的好帮手，所以它值得帮助。\n\n还是在MarkupParser.swift中，将下面的extension加到文件的最后面：\n```Objective-C\n// MARK: - String\nextension String {\n  func range(from range: NSRange) -> Range<String.Index>? {\n    guard let from16 = utf16.index(utf16.startIndex,\n                                   offsetBy: range.location,\n                                   limitedBy: utf16.endIndex),\n      let to16 = utf16.index(from16, offsetBy: range.length, limitedBy: utf16.endIndex),\n      let from = String.Index(from16, within: self),\n      let to = String.Index(to16, within: self) else {\n        return nil\n   }\n\n    return from ..< to\n  }\n}\n```\n上面这个函数将以NSRange表示的字符串的起止索引转换为了String.UTF16View.Index格式，即UTF-16字符串中的位置(position)集合，然后将每个String.UTF16View.Index格式转换为String.Index格式。String.Index格式在组合时，会生成Swift的范围格式：Range。只要索引是有效的，这个函数就会返回原始NSRange格式对应的Range格式。\n\n现在是时候回头处理文本和标签数组了。\n![](http://upload-images.jianshu.io/upload_images/698554-2c69a03c16835494.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在parseMarkup(_:)函数中添加一下代码到 ``` let chunks ``` 到下面(在do循环语句块中)：\n```Objective-C\nlet defaultFont: UIFont = .systemFont(ofSize: UIScreen.main.bounds.size.height / 40)\n//1\nfor chunk in chunks {  \n  //2\n  guard let markupRange = markup.range(from: chunk.range) else { continue }\n  //3    \n  let parts = markup.substring(with: markupRange).components(separatedBy: \"<\")\n  //4\n  let font = UIFont(name: fontName, size: UIScreen.main.bounds.size.height / 40) ?? defaultFont       \n  //5\n  let attrs = [NSAttributedStringKey.foregroundColor: color, NSAttributedStringKey.font: font] as [NSAttributedStringKey : Any]\n  let text = NSMutableAttributedString(string: parts[0], attributes: attrs)\n  attrString.append(text)\n}\n```\n1. 循环chunks数组。\n2. 获取当前NSTextCheckingResult的range，展开Range<String.Index>并且只要range存在就继续执行以下的语句块。\n3. 将chunk用\"<\"分割成几部分。第一部分包含了杂志的文本而第二部分包含了对应的标签(如果标签存在的话)。\n4. 用fontName生成字体，现在的默认字体是\"Arial\"，并且根据设备屏幕创建了字体的大小。假如fontName不能产生有效的UIFont的话，将默认字体设为当前字体。\n5. 创建字体格式的字典，将其应用于parts[0]以创建属性字符串，然后将该字符串添加到结果字符串后面。\n\n将下面用来处理\"font\"标签的代码插到attrString.append(text)下面：\n```Objective-C\n// 1\nif parts.count <= 1 {\n  continue\n}\nlet tag = parts[1]\n//2\nif tag.hasPrefix(\"font\") {\n  let colorRegex = try NSRegularExpression(pattern: \"(?<=color=\\\")\\\\w+\", \n                                           options: NSRegularExpression.Options(rawValue: 0))\n  colorRegex.enumerateMatches(in: tag, \n    options: NSRegularExpression.MatchingOptions(rawValue: 0), \n    range: NSMakeRange(0, tag.characters.count)) { (match, _, _) in\n      //3\n      if let match = match,\n        let range = tag.range(from: match.range) {\n          let colorSel = NSSelectorFromString(tag.substring(with:range) + \"Color\")\n          color = UIColor.perform(colorSel).takeRetainedValue() as? UIColor ?? .black\n      }\n  }\n  //5    \n  let faceRegex = try NSRegularExpression(pattern: \"(?<=face=\\\")[^\\\"]+\",\n                                          options: NSRegularExpression.Options(rawValue: 0))\n  faceRegex.enumerateMatches(in: tag, \n    options: NSRegularExpression.MatchingOptions(rawValue: 0), \n    range: NSMakeRange(0, tag.characters.count)) { (match, _, _) in\n\n      if let match = match,\n        let range = tag.range(from: match.range) {\n          fontName = tag.substring(with: range)\n      }\n  }\n} //end of font parsing\n```\n1. 如果parts数组元素少于2个，则跳过这个循环语句块。否则的话，将parts的第二部分存为tag。\n2. 如果tag以\"font\"开始则创建一个正则表达式去匹配字体的\"color\"值，然后用这个正则去枚举匹配到的tag中的\"color\"值。在这种情况下，只应该有一个匹配到的颜色值。\n3. 如果enumerateMatches(in:options:range:using:)函数返回标签的一个有效的match和一个有效的range的话，就去搜索出指示值，接着用这个颜色值生成一个UIColor的selector。执行这个selector所返回得到的color(如果存在的话)会赋值到你的类的color属性上，如果返回的color不存在的话，color属性会被赋值为black。\n4. 同样的，创建一个正则表达式去处理文本中字体的\"face\"值。如果匹配到一个\"face\"值，则将类的fontName属性设置为匹配的\"face\"值。\n\n干得漂亮！现在parseMarkup(_:)函数已经可以获取文本中的标记并生成一个对应的NSAttributedString了。\n\n现在也是时候把你的app喂给一些僵尸了！我的意思是，喂一些僵尸给你的app... 也就是说，(开始处理)zombies.txt。\n\n事实上，显示出被赋予的内容才是UIView的职责所在，而不是去加载内容。打开CTView.swift然后将下面代码添加到draw(_:)方法之前：\n```Objective-C\n// MARK: - Properties\nvar attrString: NSAttributedString!\n\n// MARK: - Internal\nfunc importAttrString(_ attrString: NSAttributedString) {\n  self.attrString = attrString\n}\n```\n\n接下来，将 ``` let attrString = NSAttributedString(string: \"Hello World\") ``` 从draw(_:)函数中删除。\n\n这段代码中你创建了一个实例变量持有属性字符串和一个函数以便app的其他地方可以设置这个属性字符串。\n\n然后，打开ViewController.swift并将以下代码添加到viewDidLoad()中：\n```Objective-C\n// 1\nguard let file = Bundle.main.path(forResource: \"zombies\", ofType: \"txt\") else { return }\n  \ndo {\n  let text = try String(contentsOfFile: file, encoding: .utf8)\n  // 2\n  let parser = MarkupParser()\n  parser.parseMarkup(text)\n  (view as? CTView)?.importAttrString(parser.attrString)\n} catch _ {\n}\n```\n然后一步步的过一下这段代码：\n1. 从zombie.txt文件中加载文本。\n2. 创建一个新的解析器，传入文本作为参数，然后将返回的属性字符串赋给ViewController的CTView。\n\nBuild并且运行这个app！\n![](http://upload-images.jianshu.io/upload_images/698554-a816139b2aed7b2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n简直太棒了！归功于这50多行解析代码你可以轻松的用文本文件持有你杂志app的内容了。\n\n### 基本的杂志布局\n如果你认为僵尸新闻的每月杂志只能全塞在一个可怜的页面中，那么你就错了！幸运的是，Core Text在文本列布局时相当有用，因为CTFrameGetVisibleStringRange可以告诉给定frame的情况下显示多少文本才是合适的。也就是说，你可以创建一列文本，当这一列塞满文本之后，你可以知道并开始新的一列。\n\n就本app而言，你需要先打印出列，然后集列成页，再集页成文。未免冒犯这些亡灵，所以。。。你还是尽快把把你的CTView改成继承于UIScrollView。\n打开CTView.swift然后将 ``` class CTView ``` 一行改成以下代码：\n```Objective-C\nclass CTView: UIScrollView {\n```\n看到了吗，僵尸老爷？现在这个app已经支持永恒不死了！对的，行、滚动以及翻页现在都是可用的了。\n![](http://upload-images.jianshu.io/upload_images/698554-f7c0cd8d0f47a219.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n到现在为止，你已经在draw(_:)方法里创建了framesetter和frame了，不过由于你有很多不同格式的文本列，所以最好还是创建一个独立的实例表征所述的文本列。\n\n创建一个新的名为CTColumnView的Cocoa Touch Class file，继承于UIView。\n打开CTColumnView.swift并添加下列初始代码：\n```Objective-C\nimport UIKit\nimport CoreText\n\nclass CTColumnView: UIView {\n  \n  // MARK: - Properties\n  var ctFrame: CTFrame!\n  \n  // MARK: - Initializers\n  required init(coder aDecoder: NSCoder) {\n    super.init(coder: aDecoder)!\n  }\n  \n  required init(frame: CGRect, ctframe: CTFrame) {\n    super.init(frame: frame)\n    self.ctFrame = ctframe\n    backgroundColor = .white\n  }\n  \n  // MARK: - Life Cycle\n  override func draw(_ rect: CGRect) {\n    guard let context = UIGraphicsGetCurrentContext() else { return }\n      \n    context.textMatrix = .identity\n    context.translateBy(x: 0, y: bounds.size.height)\n    context.scaleBy(x: 1.0, y: -1.0)\n      \n    CTFrameDraw(ctFrame, context)\n  }\n}\n```\n跟开始在CTView里做的工作一样，这段代码生成了一个CTFrame。自定义的初始化函数init(frame:ctframe:)设置了：\n1. 这个视图的frame。\n2. 在当前上下文中绘制的CTFrame。\n3. 以及将这个视图的背景颜色设置为白色。\n\n接下来，创建一个新的swift文件命名为CTSettings.swift，用来持有你的文本列的设置。\n将CTSettings.swift的内容替换为以下代码：\n```Objective-C\nimport UIKit\nimport Foundation\n\nclass CTSettings {\n  //1\n  // MARK: - Properties\n  let margin: CGFloat = 20\n  var columnsPerPage: CGFloat!\n  var pageRect: CGRect!\n  var columnRect: CGRect!\n  \n  // MARK: - Initializers\n  init() {\n    //2\n    columnsPerPage = UIDevice.current.userInterfaceIdiom == .phone ? 1 : 2\n    //3\n    pageRect = UIScreen.main.bounds.insetBy(dx: margin, dy: margin)\n    //4\n    columnRect = CGRect(x: 0,\n                        y: 0,\n                        width: pageRect.width / columnsPerPage,\n                        height: pageRect.height).insetBy(dx: margin, dy: margin)\n  }\n}\n```\n1. 这些属性将用来确定page的约束(在这个教程中约束默认是20)、在每一个页中文本列的数量、包含文本列的每一页的frame以及每一页中的每一个文本列的frame。\n2. 由于这本杂志的服务对象是拿着iPhone和iPad的僵尸们，iPad上显示两列，iPhone上显示一列，这样的列数对于任意的屏幕尺寸来说都是适宜的。\n3. 用约束的大小计算出来的pageRect去布局页面的边界。\n4. 用每一页的文本列数量划分pageRect的宽度并配合约束去计算出columnRect。\n\n打开CTView.swift，将文件中的内容整个替换成下列代码：\n```Objective-C\nimport UIKit\nimport CoreText\n\nclass CTView: UIScrollView {\n\n  //1\n  func buildFrames(withAttrString attrString: NSAttributedString,\n                   andImages images: [[String: Any]]) {\n    //2\n    isPagingEnabled = true\n    //3\n    let framesetter = CTFramesetterCreateWithAttributedString(attrString as CFAttributedString)\n    //4\n    var pageView = UIView()\n    var textPos = 0\n    var columnIndex: CGFloat = 0\n    var pageIndex: CGFloat = 0\n    let settings = CTSettings()\n    //5\n    while textPos < attrString.length {\n    }\n  }\n}\n```\n1. buildFrames(withAttrString:andImages:)函数会创建并添加CTColumnView到滚动视图。\n2. 运行滚动视图的翻页行为；也就是说，用户不管什么时候停止滚动，滚动视图都能卡到位置使得同一时间只有一个完整的页面在显示。\n3. CTFramesetter framesetter会为创建的每一列CTFrame提供属性字符串。\n4. UIView pageView会作为每个页面文本列对应的子视图的容器；textPos会持续跟踪接下来的文字；columnIndex会持续跟踪当前列；pageIndex会持续跟踪当前页；同时settings能让你访问app的约束尺寸、每页的列、页的frame和列frame的设置等。\n5. 你将要遍历attrString然后逐列布局文本直到当前文本的位置到了最末尾。\n\n是时候开始遍历attrString了。把下列代码加进 ``` while textPos < attrString.length { ``` 里面：\n```Objective-C\n//1\nif columnIndex.truncatingRemainder(dividingBy: settings.columnsPerPage) == 0 {\n  columnIndex = 0\n  pageView = UIView(frame: settings.pageRect.offsetBy(dx: pageIndex * bounds.width, dy: 0))\n  addSubview(pageView)\n  //2\n  pageIndex += 1\n}   \n//3\nlet columnXOrigin = pageView.frame.size.width / settings.columnsPerPage\nlet columnOffset = columnIndex * columnXOrigin\nlet columnFrame = settings.columnRect.offsetBy(dx: columnOffset, dy: 0)\n```\n1. 如果用每页列数划分的列索引等于0，也就能说明这是所在页的第一列，那么就创建新页视图持有这些列。为了设置这些列的frame，需要获取算好约束的setting. pageRect按照当前页面索引乘以屏幕宽度来对其原点计算偏移量。这样才能在翻页滚动视图内部保证杂志每一页都在前一页的右边。\n2. 自增pageIndex。\n3. 通过settings.columnsPerPage将pageView的宽度除以第一列的x原点，将该列乘以列索引以获得列偏移量；然后通过采用标准columnRect并通过columnOffset将其x原点偏移来创建当前列的frame。\n\n接下来把下列代码加到columnFrame初始化方法的下面：\n```Objective-C\n//1   \nlet path = CGMutablePath()\npath.addRect(CGRect(origin: .zero, size: columnFrame.size))\nlet ctframe = CTFramesetterCreateFrame(framesetter, CFRangeMake(textPos, 0), path, nil)\n//2\nlet column = CTColumnView(frame: columnFrame, ctframe: ctframe)\npageView.addSubview(column)\n//3\nlet frameRange = CTFrameGetVisibleStringRange(ctframe)\ntextPos += frameRange.length\n//4\ncolumnIndex += 1\n```\n1. 创建一个CGMutablePath大小的列，然后从textPos开始在合适的范围内渲染足够多的文本到CTFrame中。\n2. 用CGRect类型的columnFrame和CTFrame类型的ctframe创建一个CTColumnView并将这一列加到pageView上。\n3. 用CTFrameGetVisibleStringRange(_:)函数计算用列限制的文本的范围，然后用这个计算出来的范围自增textPos的值。\n4. 在遍历到下一列之前将column的索引值加1。\n\n最后在遍历完成之后设置好滚动视图的size：\n```Objective-C\ncontentSize = CGSize(width: CGFloat(pageIndex) * bounds.size.width,\n                     height: bounds.size.height)\n```\n\n通过将内容大小设置为屏幕宽度乘以页数，僵尸先生现在可以滚动杂志到最后了。\n\n打开ViewController.swift，将原先的下列代码：\n```Objective-C\n(view as? CTView)?.importAttrString(parser.attrString)\n```\n替换为下列代码：\n```Objective-C\n(view as? CTView)?.buildFrames(withAttrString: parser.attrString, andImages: parser.images)\n```\nBuild并在iPad上运行应用。检查一下双列布局！在页面间左右拖动试试。看起来棒极了！\n![](http://upload-images.jianshu.io/upload_images/698554-b14a1b1e5fe27a9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n你已经有了按列排列且格式化好的文本了，但是你还忘了图片呢。用Core Text绘制图片并不是那么简单，Core Text毕竟是一个文本处理框架，但是呢在你刚刚创建的标记解析器的帮助之下，添加图片也没有那么糟糕。\n\n### 用Core Text绘制图片\n虽然Core Text不能直接绘制图片，但是作为一个布局引擎，它可以为图片留开空间。通过设置为CTRun的delegate，你可以确定CTRun的ascent空间、decent空间和宽度。就像下面这样：\n![](http://upload-images.jianshu.io/upload_images/698554-2f22c94e5dde428a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n当Core Text遇到一个设置了CTRunDelegate的CTRun，它就会询问delegate：“我需要留多少空间给这块的数据”。通过在CTRunDelegate中设置这些属性，您可以在文本中给图片留开空位。\n\n首先让(解析器)支持\"img\"标签。打开MarkupParser.swift然后找到\"} //end of font parsing\"语句。并将下面代码加到后面：\n```Objective-C\n//1\nelse if tag.hasPrefix(\"img\") { \n      \n  var filename:String = \"\"\n  let imageRegex = try NSRegularExpression(pattern: \"(?<=src=\\\")[^\\\"]+\",\n                                           options: NSRegularExpression.Options(rawValue: 0))\n  imageRegex.enumerateMatches(in: tag, \n    options: NSRegularExpression.MatchingOptions(rawValue: 0), \n    range: NSMakeRange(0, tag.characters.count)) { (match, _, _) in\n\n    if let match = match,\n      let range = tag.range(from: match.range) {\n        filename = tag.substring(with: range)\n    }\n  }\n  //2\n  let settings = CTSettings()\n  var width: CGFloat = settings.columnRect.width\n  var height: CGFloat = 0\n\n  if let image = UIImage(named: filename) {\n    height = width * (image.size.height / image.size.width)\n    // 3\n    if height > settings.columnRect.height - font.lineHeight {\n      height = settings.columnRect.height - font.lineHeight\n      width = height * (image.size.width / image.size.height)\n    }\n  }\n}\n```\n1. 如果tag是以\"img\"开头的话就用正则去查找图片的\"src\"值，比如图片的filename。\n2. 设置图片宽度为列的宽度同时在保证图片宽高比的情况下设置图片高度。\n3. 如果图片的高度高过了列的高度就将列的高度设置为图片高度并减少图片的宽度以维持图片的宽高比。\n\n接下来，将下面代码加到紧随 ``` if let image ``` 语句块后面的地方：\n```Objective-C\n//1\nimages += [[\"width\": NSNumber(value: Float(width)),\n            \"height\": NSNumber(value: Float(height)),\n            \"filename\": filename,\n            \"location\": NSNumber(value: attrString.length)]]\n//2\nstruct RunStruct {\n  let ascent: CGFloat\n  let descent: CGFloat\n  let width: CGFloat\n}\n\nlet extentBuffer = UnsafeMutablePointer<RunStruct>.allocate(capacity: 1)\nextentBuffer.initialize(to: RunStruct(ascent: height, descent: 0, width: width))\n//3\nvar callbacks = CTRunDelegateCallbacks(version: kCTRunDelegateVersion1, dealloc: { (pointer) in\n}, getAscent: { (pointer) -> CGFloat in\n  let d = pointer.assumingMemoryBound(to: RunStruct.self)\n  return d.pointee.ascent\n}, getDescent: { (pointer) -> CGFloat in\n  let d = pointer.assumingMemoryBound(to: RunStruct.self)\n  return d.pointee.descent\n}, getWidth: { (pointer) -> CGFloat in\n  let d = pointer.assumingMemoryBound(to: RunStruct.self)\n  return d.pointee.width\n})\n//4\nlet delegate = CTRunDelegateCreate(&callbacks, extentBuffer)\n//5\nlet attrDictionaryDelegate = [(kCTRunDelegateAttributeName as NSAttributedStringKey): (delegate as Any)]              \nattrString.append(NSAttributedString(string: \" \", attributes: attrDictionaryDelegate))\n```\n1. 添加包含图片尺寸、文件名和文本位置的字典到images数组中。\n2. 定义RunStruct结构图去持有用来描述空格的属性。然后初始化一个包含RunStruct的指针，这个结构体的ascent等于图片的高度，宽度等于图片的宽度。\n3. 创建一个CTRunDelegateCallbacks返回ascent、decent和宽度。\n4. 用CTRunDelegateCreate生成一个绑定了callbacks和数据的委托实例。\n5. 创建一个包含委托实例的属性字典，然后添加单个空格到attrString末尾，属性字典其实就是用来持有这些占位空格的位置和大小信息的。\n\n现在MarkupParser可以处理\"img\"标签了，你需要调整CTColumnView和CTView去渲染图片。\n\n打开CTColumnView.swift。把下列用来持有列的图片和图片的frame的代码加到 ``` var ctFrame:CTFrame! ```  语句后面：\n```Objective-C\nvar images: [(image: UIImage, frame: CGRect)] = []\n```\n再然后就是把下列代码加到draw(_:)函数的后面：\n```Objective-C\nfor imageData in images {\n  if let image = imageData.image.cgImage {\n    let imgBounds = imageData.frame\n    context.draw(image, in: imgBounds)\n  }\n}\n```\n在这段代码中你遍历了每一张图片然后把图片绘制到上下文它正确的frame内。\n\n然后打开CTView.swift并添加下面这个属性到类的顶部：\n```Objective-C\n// MARK: - Properties\nvar imageIndex: Int!\n```\nimageIndex会持续追踪当前的图片索引在你绘制CTColumnView时。\n\n接下来，把下面一行代码添加到buildFrames(withAttrString:andImages:)函数上方：\n```Objective-C\nimageIndex = 0\n```\n这标志着images数组的第一个元素。\n\n然后添加下述attachImagesWithFrame(_:ctframe:margin:columnView)函数到buildFrames(withAttrString:andImages:)函数后面：\n```Objective-C\nfunc attachImagesWithFrame(_ images: [[String: Any]],\n                           ctframe: CTFrame,\n                           margin: CGFloat,\n                           columnView: CTColumnView) {\n  //1\n  let lines = CTFrameGetLines(ctframe) as NSArray\n  //2\n  var origins = [CGPoint](repeating: .zero, count: lines.count)\n  CTFrameGetLineOrigins(ctframe, CFRangeMake(0, 0), &origins)\n  //3\n  var nextImage = images[imageIndex]\n  guard var imgLocation = nextImage[\"location\"] as? Int else {\n    return\n  }\n  //4\n  for lineIndex in 0..<lines.count {\n    let line = lines[lineIndex] as! CTLine\n    //5\n    if let glyphRuns = CTLineGetGlyphRuns(line) as? [CTRun], \n      let imageFilename = nextImage[\"filename\"] as? String, \n      let img = UIImage(named: imageFilename)  { \n        for run in glyphRuns {\n\n        }\n    }\n  }\n}\n```\n1. 获取一个ctframe的CTLine对象的数组。\n2. 用CTFrameGetOrigins去复制ctframe的行初始点坐标到origins数组中。通过设置长度为0的range，CTFrameGetOrigins将知道要遍历整个CTFrame。\n3. 设置nextImage以包含当前图像的属性数据。如果nextImage包含图像的位置，请将其展开并继续；否则，早点返回函数。\n4. 遍历下一行文本。\n5. 如果这一行的字形、文件名和图片文件名都存在的话，则遍历这一行的字形。\n\n然后呢，添加下列代码到字形的for-loop语句块中：\n```Objective-C\n// 1\nlet runRange = CTRunGetStringRange(run)    \nif runRange.location > imgLocation || runRange.location + runRange.length <= imgLocation {\n  continue\n}\n//2\nvar imgBounds: CGRect = .zero\nvar ascent: CGFloat = 0       \nimgBounds.size.width = CGFloat(CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &ascent, nil, nil))\nimgBounds.size.height = ascent\n//3\nlet xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, nil)\nimgBounds.origin.x = origins[lineIndex].x + xOffset \nimgBounds.origin.y = origins[lineIndex].y\n//4\ncolumnView.images += [(image: img, frame: imgBounds)]\n//5\nimageIndex! += 1\nif imageIndex < images.count {\n  nextImage = images[imageIndex]\n  imgLocation = (nextImage[\"location\"] as AnyObject).intValue\n}\n```\n1. 如果当前字形的范围不包含下一个图像，则跳过循环的其余部分。否则，在此渲染图像。\n2. 使用CTRunGetTypographicBounds计算图像宽度，并将高度设置为ascent。\n3. 用CTLineGetOffsetForStringIndex获取线的x偏移，然后将其添加到imgBounds的起点坐标。\n4. 将图像及其frame添加到当前的CTColumnView。\n5. 增加图像索引。如果images[imageIndex]是一个图片，则更新nextImage和imgLocation，以便它们引用下一个图像。\n   ![](http://upload-images.jianshu.io/upload_images/698554-b00481e7f05f0bce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n好了！干得漂亮！基本完成，还剩下最后一步。\n\n在buildFrames(withAttrString:andImages:)内部的pageView.addSubview(column)上面添加以下代码用以附加图像(如果图像存在的话)：\n```Objective-C\nif images.count > imageIndex {\n  attachImagesWithFrame(images, ctframe: ctframe, margin: settings.margin, columnView: column)\n}\n```\nBuild并且运行到iPhone和iPad上：\n![](http://upload-images.jianshu.io/upload_images/698554-9a01dbec1c6ea94d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n恭喜你！因为感激你所做的这些辛苦的工作，僵尸先生决定不吃你的大脑了！\n\n### 何去何从\n在[这里](https://koenig-media.raywenderlich.com/uploads/2017/06/CoreTextMagazine-2.zip)查看完整的项目。\n\n正如介绍中所述，Text Kit通常可以替代Core Text；所以尝试用Text Kit编写同一个教程吧，比较一下两者有什么不同。也就是说，这堂Core Text课程不会白学！\nText Kit提供免费桥接(toll free bridging)到Core Text，因此你可以根据你的需要轻松地在框架之间进行转换。\n\n有任何问题，意见或建议？加入论坛讨论吧！","slug":"翻译杂志应用","published":1,"updated":"2017-10-24T08:21:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg4j8w2s0025vfwxdofnl3yk","content":"<p>原文链接：<a href=\"https://www.raywenderlich.com/153591/core-text-tutorial-ios-making-magazine-app\" target=\"_blank\" rel=\"external\">https://www.raywenderlich.com/153591/core-text-tutorial-ios-making-magazine-app</a>  </p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-57c6d4f3c2df1c38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"杂志，Core Text和大脑！\"><br>更新说明：本教程已经由Lyndsey Scott升级为Swift 4和Xcode 9。最初的教程由Marin Todorov所创作。</p>\n<p>Core Text是一个底层的文本引擎，当与Core Graphics/Quartz框架配合使用的时候，可以对布局和格式进行细粒度的控制。</p>\n<p>随着iOS 7的发布，Apple公司发布了一个名叫Text Kit的高级库，可以用来储存、布局和显示具有各种排版特征的文本。虽然Text Kit在布局文本时不仅强大而且大部分情况下已经足够用了，但是Core Text可以提供更多的控制。例如，如果你想直接使用Quartz的话，那就请用Core Text吧。如果你需要构建你自己的布局引擎的话，Core Text将会帮助你生成<a href=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/CoreText_Programming/Introduction/Introduction.html#//apple_ref/doc/uid/TP40005533\" target=\"_blank\" rel=\"external\">字形(glyphs)并且根据互相之间的关系摆放好这些字形，并具有好的排版的所有特性</a>。</p>\n<p>本教程将会引导你使用Core Text去创作一本非常简单的杂志应用…给僵尸看的！<br>呃，僵尸月刊的读者朋友们已经宽容的答应了，只要你本教程认真使用Core Text的话，就不会吃掉你的大脑了…所以呢，你还是尽快开始吧！</p>\n<blockquote>\n<p>说明：要充分读懂本教程，你首先需要了解iOS开发的基础。如果你是iOS开发的新人的话，你应该首先查看本网站的<a href=\"https://www.raywenderlich.com/category/ios\" target=\"_blank\" rel=\"external\">其他教程</a>。</p>\n</blockquote>\n<h3 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h3><p>打开Xcode，用Single View Application模板创建一个新的Swift universal project，命名为CoreTextMagazine。</p>\n<p>然后，将Core Text框架加到你的工程中：</p>\n<ol>\n<li>单击工程导航器中的工程文件(在左边的导航条上)</li>\n<li>在”General”按钮下，滚动到底部的”Linked Frameworks and Libraries”</li>\n<li>单击”+”按钮然后找到”CoreText”</li>\n<li>选中”CoreText.framework”然后点击”Add”按钮。就这么简单！</li>\n</ol>\n<p>现在工程已经配置好了，是时候开始写代码了。</p>\n<h3 id=\"添加一个Core-Text-View\"><a href=\"#添加一个Core-Text-View\" class=\"headerlink\" title=\"添加一个Core Text View\"></a>添加一个Core Text View</h3><p>首先，你将要创建一个自定义的UIView，在这个UIView的draw(_:)方法中将会用到Core Text。</p>\n<p>创建一个新的继承于UIView的Cocoa Touch Class file，命名为CTView。打开CTView.swift，然后在 <figure class=\"highlight plain\"><figcaption><span>UIKit ``` 语句下面加上下面的代码：</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">```Objective-C</div><div class=\"line\">import CoreText</div></pre></td></tr></table></figure></p>\n<p>然后，将这个自定义的view设置为应用的主视图。打开Main.storyboard，在右边打开Utilities菜单，然后在顶部工具条单击Identity Inspector图标。在Interface Builder的左侧菜单中，选中View。现在在Utilities菜单的Class字段中应该写着UIView。在Class字段输入CTView以子类化主视图控制器的视图，然后点击回车键。<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-e426ca1cea702142.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>接下来，打开CTView.swift并将被注释掉的draw(_:)方法全都替换成下面的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">//1\t \t </div><div class=\"line\">override func draw(_ rect: CGRect) &#123;\t \t </div><div class=\"line\">  // 2\t \t </div><div class=\"line\">  guard let context = UIGraphicsGetCurrentContext() else &#123; return &#125;\t \t </div><div class=\"line\">  // 3\t \t </div><div class=\"line\">  let path = CGMutablePath()\t \t </div><div class=\"line\">  path.addRect(bounds)\t \t </div><div class=\"line\">  // 4</div><div class=\"line\">  let attrString = NSAttributedString(string: &quot;Hello World&quot;)</div><div class=\"line\">  // 5</div><div class=\"line\">  let framesetter = CTFramesetterCreateWithAttributedString(attrString as CFAttributedString)</div><div class=\"line\">  // 6</div><div class=\"line\">  let frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, attrString.length), path, nil) </div><div class=\"line\">  // 7</div><div class=\"line\">  CTFrameDraw(frame, context)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>让我们一步一步地分析一下代码：</p>\n<ol>\n<li>在视图创建的时候，draw(_:)会自动运行，渲染这个视图的背景图层。</li>\n<li>打开用于绘制的当前图形上下文。</li>\n<li>创建一条用来限定绘图区域的路径，在这个例子中就是整个视图的bounds。</li>\n<li>在Core Text，使用NSAttributedString而不是String或者NSString，保存文本和属性(attributes)。初始化一个”Hello World”的属性字符串。</li>\n<li>CTFramesetterCreateWithAttributedString使用提供的属性字符串创建一个CTFramesetter。CTFramesetter会管理你引用的字体和绘图区域。</li>\n<li>通过使CTFramesetterCreateFrame在路径内渲染整个字符串，可以创建一个CTFrame。</li>\n<li>CTFrameDraw在给定的上下文中绘制CTFrame。<br>这就是你绘制简单文本所需要做的全部了！Build，运行然后查看结果。<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-bdfec1f8b8817617.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></li>\n</ol>\n<p>噢不…似乎看起来不太对。就像很多的底层API一样，Core Text使用的是Y-flipped坐标系统。更糟糕的是，内容在竖直方向上也翻转了！</p>\n<p>添加以下代码到<figure class=\"highlight plain\"><figcaption><span>let context ```语句以修正内容的方向：</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">```Objective-C</div><div class=\"line\">// Flip the coordinate system</div><div class=\"line\">context.textMatrix = .identity</div><div class=\"line\">context.translateBy(x: 0, y: bounds.size.height)</div><div class=\"line\">context.scaleBy(x: 1.0, y: -1.0)</div></pre></td></tr></table></figure></p>\n<p>这段代码通过应用变换(transformation)到视图的上下文来将内容翻转。</p>\n<p>Build然后运行app。别担心状态栏重叠的问题，你接下来会学到怎样通过约束解决这个问题。<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-5febf55f8e6bc993.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>祝贺你的第一个Core Text软件！僵尸们很高兴看到你的进步。</p>\n<h3 id=\"Core-Text对象模型\"><a href=\"#Core-Text对象模型\" class=\"headerlink\" title=\"Core Text对象模型\"></a>Core Text对象模型</h3><p>如果你对CTFramesetter和CTFrame感到有点疑惑也是正常的，也是时候说明一下它们了。:]<br>Core Text对象模型如下所示：<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-e7418de12cb5ae45.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>当你提供一个NSAttributedString创建一个CTFramesetter对象实例的时候，一个CTTypesetter的实例对象会自动为你创建用以管理你的字体。接下来你会在渲染文本的时候用到这个CTFramesetter去创建一个或者多个frame。</p>\n<p>当你创建了一个frame，你可以为这个frame提供文本的一个subrange去渲染这段文本。Core Text会自动为文本的每一行创建一个CTLine，并为每个具有相同格式的字符创建一个CTRun。举个例子，Core Text只会创建一个CTRun用于同一行中的几个红色的单词，创建一个CTRun用于接下来的纯文本，创建一个CTRun用于粗体段落等等。Core Text创建会根据你提供的NSAttributedString中的属性创建CTRun。此外，上面说到的每一个CTRun对象都可以采用不同的属性，也就是说，你可以很好地控制字距、连字、宽度、高度等。</p>\n<h3 id=\"深入杂志App！\"><a href=\"#深入杂志App！\" class=\"headerlink\" title=\"深入杂志App！\"></a>深入杂志App！</h3><p>下载并解压<a href=\"http://www.raywenderlich.com/downloads/zombieMagMaterials.zip\" target=\"_blank\" rel=\"external\">the zombie magazine materials</a>。拖拽解压出来的文件夹到你的Xcode工程中。当弹出对话框时，确保Copy items if needed和Create groups选中。</p>\n<p>为了创建这个app，你需要对文本应用各种属性。你将要创建一个用标签设置杂志格式的简单文本标记解析器。</p>\n<p>创建一个新的Cocoa Touch Class file，命名为MarkupParser，继承于NSObject。</p>\n<p>首先，我们快速看一下zombies.txt。看看它是如何在整个文本中包含括号内的格式化标签的。”img src”标签指向杂志的图片，而”font color/face”标签则确定了文本的颜色和字体。</p>\n<p>打开MarkupParser.swift然后将它的内容替换为以下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">import UIKit</div><div class=\"line\">import CoreText</div><div class=\"line\"></div><div class=\"line\">class MarkupParser: NSObject &#123;</div><div class=\"line\">  </div><div class=\"line\">  // MARK: - Properties</div><div class=\"line\">  var color: UIColor = .black</div><div class=\"line\">  var fontName: String = &quot;Arial&quot;</div><div class=\"line\">  var attrString: NSMutableAttributedString!</div><div class=\"line\">  var images: [[String: Any]] = []</div><div class=\"line\"></div><div class=\"line\">  // MARK: - Initializers</div><div class=\"line\">  override init() &#123;</div><div class=\"line\">    super.init()</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  // MARK: - Internal</div><div class=\"line\">  func parseMarkup(_ markup: String) &#123;</div><div class=\"line\"></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>你在这段代码中添加了属性持有字体和文本颜色，设置了它们的初始值。创建了一个变量去持有parseMarkup(_:)生成的属性字符串。还创建了一个数组用来持有定义了尺寸、位置以及从文本中解析出来的图片文件名等信息的键值对。</p>\n<p>通常来说，写一个解析器并不是一个轻松的工作，但是本教程所实现的解析器将会非常简易，只提供开放标签的支持，也就意味着一个标签会决定紧随着这个标签的文本的样式，直到找到一个新的标签。这段文本的标记如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">These are &lt;font color=&quot;red&quot;&gt;red&lt;font color=&quot;black&quot;&gt; and</div><div class=\"line\">&lt;font color=&quot;blue&quot;&gt;blue &lt;font color=&quot;black&quot;&gt;words.</div></pre></td></tr></table></figure></p>\n<p>输出如下所示：<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-6d55091e685937d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>将以下代码加到 <figure class=\"highlight plain\"><figcaption><span>``` 方法中：</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">```Objective-C</div><div class=\"line\">//1</div><div class=\"line\">attrString = NSMutableAttributedString(string: &quot;&quot;)</div><div class=\"line\">//2 </div><div class=\"line\">do &#123;</div><div class=\"line\">  let regex = try NSRegularExpression(pattern: &quot;(.*?)(&lt;[^&gt;]+&gt;|\\\\Z)&quot;,</div><div class=\"line\">                                      options: [.caseInsensitive,</div><div class=\"line\">                                                .dotMatchesLineSeparators])</div><div class=\"line\">  //3</div><div class=\"line\">  let chunks = regex.matches(in: markup, </div><div class=\"line\">                             options: NSRegularExpression.MatchingOptions(rawValue: 0), </div><div class=\"line\">                             range: NSRange(location: 0,</div><div class=\"line\">                                            length: markup.characters.count))</div><div class=\"line\">&#125; catch _ &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ol>\n<li>attrString初始为空，但是最后会包含解析出来的标记。</li>\n<li>这个正则表达式，匹配了紧跟着这些标签的文本块。它就好像在说：“去查看字符串直到你找到一个开头的括号，然后查看字符串直到你找到一个结束的括号（或者文档的末尾）”。</li>\n<li>搜索regex匹配到的整个标记范围，然后生成一个NSTextCheckingResult的数组。</li>\n</ol>\n<blockquote>\n<p>想要学习更多有关正则表达式的内容，访问<a href=\"https://www.raywenderlich.com/86205/nsregularexpression-swift-tutorial\" target=\"_blank\" rel=\"external\">NSRegularExpression Tutorial</a>吧。</p>\n</blockquote>\n<p>现在你已经解析了所有的文本并将所有格式化的标签都放进了chunks中，你要做的就是遍历chunks数组去生成对应的属性字符串。</p>\n<p>但在那之前，你是否留意到matches(in:options:range:)方法是如何接受一个NSRange作为参数的吗？在你应用NSRegularExpression到你的标记String的时候会有大量NSRange到Range的转化。Swift已经成为了我们所有人的好帮手，所以它值得帮助。</p>\n<p>还是在MarkupParser.swift中，将下面的extension加到文件的最后面：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">// MARK: - String</div><div class=\"line\">extension String &#123;</div><div class=\"line\">  func range(from range: NSRange) -&gt; Range&lt;String.Index&gt;? &#123;</div><div class=\"line\">    guard let from16 = utf16.index(utf16.startIndex,</div><div class=\"line\">                                   offsetBy: range.location,</div><div class=\"line\">                                   limitedBy: utf16.endIndex),</div><div class=\"line\">      let to16 = utf16.index(from16, offsetBy: range.length, limitedBy: utf16.endIndex),</div><div class=\"line\">      let from = String.Index(from16, within: self),</div><div class=\"line\">      let to = String.Index(to16, within: self) else &#123;</div><div class=\"line\">        return nil</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">    return from ..&lt; to</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面这个函数将以NSRange表示的字符串的起止索引转换为了String.UTF16View.Index格式，即UTF-16字符串中的位置(position)集合，然后将每个String.UTF16View.Index格式转换为String.Index格式。String.Index格式在组合时，会生成Swift的范围格式：Range。只要索引是有效的，这个函数就会返回原始NSRange格式对应的Range格式。</p>\n<p>现在是时候回头处理文本和标签数组了。<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-2c69a03c16835494.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>在parseMarkup(_:)函数中添加一下代码到 <figure class=\"highlight plain\"><figcaption><span>chunks ``` 到下面(在do循环语句块中)：</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">```Objective-C</div><div class=\"line\">let defaultFont: UIFont = .systemFont(ofSize: UIScreen.main.bounds.size.height / 40)</div><div class=\"line\">//1</div><div class=\"line\">for chunk in chunks &#123;  </div><div class=\"line\">  //2</div><div class=\"line\">  guard let markupRange = markup.range(from: chunk.range) else &#123; continue &#125;</div><div class=\"line\">  //3    </div><div class=\"line\">  let parts = markup.substring(with: markupRange).components(separatedBy: &quot;&lt;&quot;)</div><div class=\"line\">  //4</div><div class=\"line\">  let font = UIFont(name: fontName, size: UIScreen.main.bounds.size.height / 40) ?? defaultFont       </div><div class=\"line\">  //5</div><div class=\"line\">  let attrs = [NSAttributedStringKey.foregroundColor: color, NSAttributedStringKey.font: font] as [NSAttributedStringKey : Any]</div><div class=\"line\">  let text = NSMutableAttributedString(string: parts[0], attributes: attrs)</div><div class=\"line\">  attrString.append(text)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ol>\n<li>循环chunks数组。</li>\n<li>获取当前NSTextCheckingResult的range，展开Range<string.index>并且只要range存在就继续执行以下的语句块。</string.index></li>\n<li>将chunk用”&lt;”分割成几部分。第一部分包含了杂志的文本而第二部分包含了对应的标签(如果标签存在的话)。</li>\n<li>用fontName生成字体，现在的默认字体是”Arial”，并且根据设备屏幕创建了字体的大小。假如fontName不能产生有效的UIFont的话，将默认字体设为当前字体。</li>\n<li>创建字体格式的字典，将其应用于parts[0]以创建属性字符串，然后将该字符串添加到结果字符串后面。</li>\n</ol>\n<p>将下面用来处理”font”标签的代码插到attrString.append(text)下面：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1</div><div class=\"line\">if parts.count &lt;= 1 &#123;</div><div class=\"line\">  continue</div><div class=\"line\">&#125;</div><div class=\"line\">let tag = parts[1]</div><div class=\"line\">//2</div><div class=\"line\">if tag.hasPrefix(&quot;font&quot;) &#123;</div><div class=\"line\">  let colorRegex = try NSRegularExpression(pattern: &quot;(?&lt;=color=\\&quot;)\\\\w+&quot;, </div><div class=\"line\">                                           options: NSRegularExpression.Options(rawValue: 0))</div><div class=\"line\">  colorRegex.enumerateMatches(in: tag, </div><div class=\"line\">    options: NSRegularExpression.MatchingOptions(rawValue: 0), </div><div class=\"line\">    range: NSMakeRange(0, tag.characters.count)) &#123; (match, _, _) in</div><div class=\"line\">      //3</div><div class=\"line\">      if let match = match,</div><div class=\"line\">        let range = tag.range(from: match.range) &#123;</div><div class=\"line\">          let colorSel = NSSelectorFromString(tag.substring(with:range) + &quot;Color&quot;)</div><div class=\"line\">          color = UIColor.perform(colorSel).takeRetainedValue() as? UIColor ?? .black</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  //5    </div><div class=\"line\">  let faceRegex = try NSRegularExpression(pattern: &quot;(?&lt;=face=\\&quot;)[^\\&quot;]+&quot;,</div><div class=\"line\">                                          options: NSRegularExpression.Options(rawValue: 0))</div><div class=\"line\">  faceRegex.enumerateMatches(in: tag, </div><div class=\"line\">    options: NSRegularExpression.MatchingOptions(rawValue: 0), </div><div class=\"line\">    range: NSMakeRange(0, tag.characters.count)) &#123; (match, _, _) in</div><div class=\"line\"></div><div class=\"line\">      if let match = match,</div><div class=\"line\">        let range = tag.range(from: match.range) &#123;</div><div class=\"line\">          fontName = tag.substring(with: range)</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125; //end of font parsing</div></pre></td></tr></table></figure></p>\n<ol>\n<li>如果parts数组元素少于2个，则跳过这个循环语句块。否则的话，将parts的第二部分存为tag。</li>\n<li>如果tag以”font”开始则创建一个正则表达式去匹配字体的”color”值，然后用这个正则去枚举匹配到的tag中的”color”值。在这种情况下，只应该有一个匹配到的颜色值。</li>\n<li>如果enumerateMatches(in:options:range:using:)函数返回标签的一个有效的match和一个有效的range的话，就去搜索出指示值，接着用这个颜色值生成一个UIColor的selector。执行这个selector所返回得到的color(如果存在的话)会赋值到你的类的color属性上，如果返回的color不存在的话，color属性会被赋值为black。</li>\n<li>同样的，创建一个正则表达式去处理文本中字体的”face”值。如果匹配到一个”face”值，则将类的fontName属性设置为匹配的”face”值。</li>\n</ol>\n<p>干得漂亮！现在parseMarkup(_:)函数已经可以获取文本中的标记并生成一个对应的NSAttributedString了。</p>\n<p>现在也是时候把你的app喂给一些僵尸了！我的意思是，喂一些僵尸给你的app… 也就是说，(开始处理)zombies.txt。</p>\n<p>事实上，显示出被赋予的内容才是UIView的职责所在，而不是去加载内容。打开CTView.swift然后将下面代码添加到draw(_:)方法之前：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// MARK: - Properties</div><div class=\"line\">var attrString: NSAttributedString!</div><div class=\"line\"></div><div class=\"line\">// MARK: - Internal</div><div class=\"line\">func importAttrString(_ attrString: NSAttributedString) &#123;</div><div class=\"line\">  self.attrString = attrString</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>接下来，将 <figure class=\"highlight plain\"><figcaption><span>attrString = NSAttributedString(string: \"Hello World\") ``` 从draw(_:)函数中删除。</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">这段代码中你创建了一个实例变量持有属性字符串和一个函数以便app的其他地方可以设置这个属性字符串。</div><div class=\"line\"></div><div class=\"line\">然后，打开ViewController.swift并将以下代码添加到viewDidLoad()中：</div><div class=\"line\">```Objective-C</div><div class=\"line\">// 1</div><div class=\"line\">guard let file = Bundle.main.path(forResource: &quot;zombies&quot;, ofType: &quot;txt&quot;) else &#123; return &#125;</div><div class=\"line\">  </div><div class=\"line\">do &#123;</div><div class=\"line\">  let text = try String(contentsOfFile: file, encoding: .utf8)</div><div class=\"line\">  // 2</div><div class=\"line\">  let parser = MarkupParser()</div><div class=\"line\">  parser.parseMarkup(text)</div><div class=\"line\">  (view as? CTView)?.importAttrString(parser.attrString)</div><div class=\"line\">&#125; catch _ &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后一步步的过一下这段代码：</p>\n<ol>\n<li>从zombie.txt文件中加载文本。</li>\n<li>创建一个新的解析器，传入文本作为参数，然后将返回的属性字符串赋给ViewController的CTView。</li>\n</ol>\n<p>Build并且运行这个app！<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-a816139b2aed7b2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>简直太棒了！归功于这50多行解析代码你可以轻松的用文本文件持有你杂志app的内容了。</p>\n<h3 id=\"基本的杂志布局\"><a href=\"#基本的杂志布局\" class=\"headerlink\" title=\"基本的杂志布局\"></a>基本的杂志布局</h3><p>如果你认为僵尸新闻的每月杂志只能全塞在一个可怜的页面中，那么你就错了！幸运的是，Core Text在文本列布局时相当有用，因为CTFrameGetVisibleStringRange可以告诉给定frame的情况下显示多少文本才是合适的。也就是说，你可以创建一列文本，当这一列塞满文本之后，你可以知道并开始新的一列。</p>\n<p>就本app而言，你需要先打印出列，然后集列成页，再集页成文。未免冒犯这些亡灵，所以。。。你还是尽快把把你的CTView改成继承于UIScrollView。<br>打开CTView.swift然后将 <figure class=\"highlight plain\"><figcaption><span>CTView ``` 一行改成以下代码：</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">```Objective-C</div><div class=\"line\">class CTView: UIScrollView &#123;</div></pre></td></tr></table></figure></p>\n<p>看到了吗，僵尸老爷？现在这个app已经支持永恒不死了！对的，行、滚动以及翻页现在都是可用的了。<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-f7c0cd8d0f47a219.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>到现在为止，你已经在draw(_:)方法里创建了framesetter和frame了，不过由于你有很多不同格式的文本列，所以最好还是创建一个独立的实例表征所述的文本列。</p>\n<p>创建一个新的名为CTColumnView的Cocoa Touch Class file，继承于UIView。<br>打开CTColumnView.swift并添加下列初始代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">import UIKit</div><div class=\"line\">import CoreText</div><div class=\"line\"></div><div class=\"line\">class CTColumnView: UIView &#123;</div><div class=\"line\">  </div><div class=\"line\">  // MARK: - Properties</div><div class=\"line\">  var ctFrame: CTFrame!</div><div class=\"line\">  </div><div class=\"line\">  // MARK: - Initializers</div><div class=\"line\">  required init(coder aDecoder: NSCoder) &#123;</div><div class=\"line\">    super.init(coder: aDecoder)!</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  required init(frame: CGRect, ctframe: CTFrame) &#123;</div><div class=\"line\">    super.init(frame: frame)</div><div class=\"line\">    self.ctFrame = ctframe</div><div class=\"line\">    backgroundColor = .white</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  // MARK: - Life Cycle</div><div class=\"line\">  override func draw(_ rect: CGRect) &#123;</div><div class=\"line\">    guard let context = UIGraphicsGetCurrentContext() else &#123; return &#125;</div><div class=\"line\">      </div><div class=\"line\">    context.textMatrix = .identity</div><div class=\"line\">    context.translateBy(x: 0, y: bounds.size.height)</div><div class=\"line\">    context.scaleBy(x: 1.0, y: -1.0)</div><div class=\"line\">      </div><div class=\"line\">    CTFrameDraw(ctFrame, context)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>跟开始在CTView里做的工作一样，这段代码生成了一个CTFrame。自定义的初始化函数init(frame:ctframe:)设置了：</p>\n<ol>\n<li>这个视图的frame。</li>\n<li>在当前上下文中绘制的CTFrame。</li>\n<li>以及将这个视图的背景颜色设置为白色。</li>\n</ol>\n<p>接下来，创建一个新的swift文件命名为CTSettings.swift，用来持有你的文本列的设置。<br>将CTSettings.swift的内容替换为以下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">import UIKit</div><div class=\"line\">import Foundation</div><div class=\"line\"></div><div class=\"line\">class CTSettings &#123;</div><div class=\"line\">  //1</div><div class=\"line\">  // MARK: - Properties</div><div class=\"line\">  let margin: CGFloat = 20</div><div class=\"line\">  var columnsPerPage: CGFloat!</div><div class=\"line\">  var pageRect: CGRect!</div><div class=\"line\">  var columnRect: CGRect!</div><div class=\"line\">  </div><div class=\"line\">  // MARK: - Initializers</div><div class=\"line\">  init() &#123;</div><div class=\"line\">    //2</div><div class=\"line\">    columnsPerPage = UIDevice.current.userInterfaceIdiom == .phone ? 1 : 2</div><div class=\"line\">    //3</div><div class=\"line\">    pageRect = UIScreen.main.bounds.insetBy(dx: margin, dy: margin)</div><div class=\"line\">    //4</div><div class=\"line\">    columnRect = CGRect(x: 0,</div><div class=\"line\">                        y: 0,</div><div class=\"line\">                        width: pageRect.width / columnsPerPage,</div><div class=\"line\">                        height: pageRect.height).insetBy(dx: margin, dy: margin)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ol>\n<li>这些属性将用来确定page的约束(在这个教程中约束默认是20)、在每一个页中文本列的数量、包含文本列的每一页的frame以及每一页中的每一个文本列的frame。</li>\n<li>由于这本杂志的服务对象是拿着iPhone和iPad的僵尸们，iPad上显示两列，iPhone上显示一列，这样的列数对于任意的屏幕尺寸来说都是适宜的。</li>\n<li>用约束的大小计算出来的pageRect去布局页面的边界。</li>\n<li>用每一页的文本列数量划分pageRect的宽度并配合约束去计算出columnRect。</li>\n</ol>\n<p>打开CTView.swift，将文件中的内容整个替换成下列代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">import UIKit</div><div class=\"line\">import CoreText</div><div class=\"line\"></div><div class=\"line\">class CTView: UIScrollView &#123;</div><div class=\"line\"></div><div class=\"line\">  //1</div><div class=\"line\">  func buildFrames(withAttrString attrString: NSAttributedString,</div><div class=\"line\">                   andImages images: [[String: Any]]) &#123;</div><div class=\"line\">    //2</div><div class=\"line\">    isPagingEnabled = true</div><div class=\"line\">    //3</div><div class=\"line\">    let framesetter = CTFramesetterCreateWithAttributedString(attrString as CFAttributedString)</div><div class=\"line\">    //4</div><div class=\"line\">    var pageView = UIView()</div><div class=\"line\">    var textPos = 0</div><div class=\"line\">    var columnIndex: CGFloat = 0</div><div class=\"line\">    var pageIndex: CGFloat = 0</div><div class=\"line\">    let settings = CTSettings()</div><div class=\"line\">    //5</div><div class=\"line\">    while textPos &lt; attrString.length &#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ol>\n<li>buildFrames(withAttrString:andImages:)函数会创建并添加CTColumnView到滚动视图。</li>\n<li>运行滚动视图的翻页行为；也就是说，用户不管什么时候停止滚动，滚动视图都能卡到位置使得同一时间只有一个完整的页面在显示。</li>\n<li>CTFramesetter framesetter会为创建的每一列CTFrame提供属性字符串。</li>\n<li>UIView pageView会作为每个页面文本列对应的子视图的容器；textPos会持续跟踪接下来的文字；columnIndex会持续跟踪当前列；pageIndex会持续跟踪当前页；同时settings能让你访问app的约束尺寸、每页的列、页的frame和列frame的设置等。</li>\n<li>你将要遍历attrString然后逐列布局文本直到当前文本的位置到了最末尾。</li>\n</ol>\n<p>是时候开始遍历attrString了。把下列代码加进 <figure class=\"highlight plain\"><figcaption><span>textPos < attrString.length &#123; ``` 里面：</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">```Objective-C</div><div class=\"line\">//1</div><div class=\"line\">if columnIndex.truncatingRemainder(dividingBy: settings.columnsPerPage) == 0 &#123;</div><div class=\"line\">  columnIndex = 0</div><div class=\"line\">  pageView = UIView(frame: settings.pageRect.offsetBy(dx: pageIndex * bounds.width, dy: 0))</div><div class=\"line\">  addSubview(pageView)</div><div class=\"line\">  //2</div><div class=\"line\">  pageIndex += 1</div><div class=\"line\">&#125;   </div><div class=\"line\">//3</div><div class=\"line\">let columnXOrigin = pageView.frame.size.width / settings.columnsPerPage</div><div class=\"line\">let columnOffset = columnIndex * columnXOrigin</div><div class=\"line\">let columnFrame = settings.columnRect.offsetBy(dx: columnOffset, dy: 0)</div></pre></td></tr></table></figure></p>\n<ol>\n<li>如果用每页列数划分的列索引等于0，也就能说明这是所在页的第一列，那么就创建新页视图持有这些列。为了设置这些列的frame，需要获取算好约束的setting. pageRect按照当前页面索引乘以屏幕宽度来对其原点计算偏移量。这样才能在翻页滚动视图内部保证杂志每一页都在前一页的右边。</li>\n<li>自增pageIndex。</li>\n<li>通过settings.columnsPerPage将pageView的宽度除以第一列的x原点，将该列乘以列索引以获得列偏移量；然后通过采用标准columnRect并通过columnOffset将其x原点偏移来创建当前列的frame。</li>\n</ol>\n<p>接下来把下列代码加到columnFrame初始化方法的下面：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">//1   </div><div class=\"line\">let path = CGMutablePath()</div><div class=\"line\">path.addRect(CGRect(origin: .zero, size: columnFrame.size))</div><div class=\"line\">let ctframe = CTFramesetterCreateFrame(framesetter, CFRangeMake(textPos, 0), path, nil)</div><div class=\"line\">//2</div><div class=\"line\">let column = CTColumnView(frame: columnFrame, ctframe: ctframe)</div><div class=\"line\">pageView.addSubview(column)</div><div class=\"line\">//3</div><div class=\"line\">let frameRange = CTFrameGetVisibleStringRange(ctframe)</div><div class=\"line\">textPos += frameRange.length</div><div class=\"line\">//4</div><div class=\"line\">columnIndex += 1</div></pre></td></tr></table></figure></p>\n<ol>\n<li>创建一个CGMutablePath大小的列，然后从textPos开始在合适的范围内渲染足够多的文本到CTFrame中。</li>\n<li>用CGRect类型的columnFrame和CTFrame类型的ctframe创建一个CTColumnView并将这一列加到pageView上。</li>\n<li>用CTFrameGetVisibleStringRange(_:)函数计算用列限制的文本的范围，然后用这个计算出来的范围自增textPos的值。</li>\n<li>在遍历到下一列之前将column的索引值加1。</li>\n</ol>\n<p>最后在遍历完成之后设置好滚动视图的size：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">contentSize = CGSize(width: CGFloat(pageIndex) * bounds.size.width,</div><div class=\"line\">                     height: bounds.size.height)</div></pre></td></tr></table></figure></p>\n<p>通过将内容大小设置为屏幕宽度乘以页数，僵尸先生现在可以滚动杂志到最后了。</p>\n<p>打开ViewController.swift，将原先的下列代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(view as? CTView)?.importAttrString(parser.attrString)</div></pre></td></tr></table></figure></p>\n<p>替换为下列代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(view as? CTView)?.buildFrames(withAttrString: parser.attrString, andImages: parser.images)</div></pre></td></tr></table></figure></p>\n<p>Build并在iPad上运行应用。检查一下双列布局！在页面间左右拖动试试。看起来棒极了！<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-b14a1b1e5fe27a9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>你已经有了按列排列且格式化好的文本了，但是你还忘了图片呢。用Core Text绘制图片并不是那么简单，Core Text毕竟是一个文本处理框架，但是呢在你刚刚创建的标记解析器的帮助之下，添加图片也没有那么糟糕。</p>\n<h3 id=\"用Core-Text绘制图片\"><a href=\"#用Core-Text绘制图片\" class=\"headerlink\" title=\"用Core Text绘制图片\"></a>用Core Text绘制图片</h3><p>虽然Core Text不能直接绘制图片，但是作为一个布局引擎，它可以为图片留开空间。通过设置为CTRun的delegate，你可以确定CTRun的ascent空间、decent空间和宽度。就像下面这样：<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-2f22c94e5dde428a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>当Core Text遇到一个设置了CTRunDelegate的CTRun，它就会询问delegate：“我需要留多少空间给这块的数据”。通过在CTRunDelegate中设置这些属性，您可以在文本中给图片留开空位。</p>\n<p>首先让(解析器)支持”img”标签。打开MarkupParser.swift然后找到”} //end of font parsing”语句。并将下面代码加到后面：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">//1</div><div class=\"line\">else if tag.hasPrefix(&quot;img&quot;) &#123; </div><div class=\"line\">      </div><div class=\"line\">  var filename:String = &quot;&quot;</div><div class=\"line\">  let imageRegex = try NSRegularExpression(pattern: &quot;(?&lt;=src=\\&quot;)[^\\&quot;]+&quot;,</div><div class=\"line\">                                           options: NSRegularExpression.Options(rawValue: 0))</div><div class=\"line\">  imageRegex.enumerateMatches(in: tag, </div><div class=\"line\">    options: NSRegularExpression.MatchingOptions(rawValue: 0), </div><div class=\"line\">    range: NSMakeRange(0, tag.characters.count)) &#123; (match, _, _) in</div><div class=\"line\"></div><div class=\"line\">    if let match = match,</div><div class=\"line\">      let range = tag.range(from: match.range) &#123;</div><div class=\"line\">        filename = tag.substring(with: range)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  //2</div><div class=\"line\">  let settings = CTSettings()</div><div class=\"line\">  var width: CGFloat = settings.columnRect.width</div><div class=\"line\">  var height: CGFloat = 0</div><div class=\"line\"></div><div class=\"line\">  if let image = UIImage(named: filename) &#123;</div><div class=\"line\">    height = width * (image.size.height / image.size.width)</div><div class=\"line\">    // 3</div><div class=\"line\">    if height &gt; settings.columnRect.height - font.lineHeight &#123;</div><div class=\"line\">      height = settings.columnRect.height - font.lineHeight</div><div class=\"line\">      width = height * (image.size.width / image.size.height)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ol>\n<li>如果tag是以”img”开头的话就用正则去查找图片的”src”值，比如图片的filename。</li>\n<li>设置图片宽度为列的宽度同时在保证图片宽高比的情况下设置图片高度。</li>\n<li>如果图片的高度高过了列的高度就将列的高度设置为图片高度并减少图片的宽度以维持图片的宽高比。</li>\n</ol>\n<p>接下来，将下面代码加到紧随 <figure class=\"highlight plain\"><figcaption><span>let image ``` 语句块后面的地方：</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">```Objective-C</div><div class=\"line\">//1</div><div class=\"line\">images += [[&quot;width&quot;: NSNumber(value: Float(width)),</div><div class=\"line\">            &quot;height&quot;: NSNumber(value: Float(height)),</div><div class=\"line\">            &quot;filename&quot;: filename,</div><div class=\"line\">            &quot;location&quot;: NSNumber(value: attrString.length)]]</div><div class=\"line\">//2</div><div class=\"line\">struct RunStruct &#123;</div><div class=\"line\">  let ascent: CGFloat</div><div class=\"line\">  let descent: CGFloat</div><div class=\"line\">  let width: CGFloat</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let extentBuffer = UnsafeMutablePointer&lt;RunStruct&gt;.allocate(capacity: 1)</div><div class=\"line\">extentBuffer.initialize(to: RunStruct(ascent: height, descent: 0, width: width))</div><div class=\"line\">//3</div><div class=\"line\">var callbacks = CTRunDelegateCallbacks(version: kCTRunDelegateVersion1, dealloc: &#123; (pointer) in</div><div class=\"line\">&#125;, getAscent: &#123; (pointer) -&gt; CGFloat in</div><div class=\"line\">  let d = pointer.assumingMemoryBound(to: RunStruct.self)</div><div class=\"line\">  return d.pointee.ascent</div><div class=\"line\">&#125;, getDescent: &#123; (pointer) -&gt; CGFloat in</div><div class=\"line\">  let d = pointer.assumingMemoryBound(to: RunStruct.self)</div><div class=\"line\">  return d.pointee.descent</div><div class=\"line\">&#125;, getWidth: &#123; (pointer) -&gt; CGFloat in</div><div class=\"line\">  let d = pointer.assumingMemoryBound(to: RunStruct.self)</div><div class=\"line\">  return d.pointee.width</div><div class=\"line\">&#125;)</div><div class=\"line\">//4</div><div class=\"line\">let delegate = CTRunDelegateCreate(&amp;callbacks, extentBuffer)</div><div class=\"line\">//5</div><div class=\"line\">let attrDictionaryDelegate = [(kCTRunDelegateAttributeName as NSAttributedStringKey): (delegate as Any)]              </div><div class=\"line\">attrString.append(NSAttributedString(string: &quot; &quot;, attributes: attrDictionaryDelegate))</div></pre></td></tr></table></figure></p>\n<ol>\n<li>添加包含图片尺寸、文件名和文本位置的字典到images数组中。</li>\n<li>定义RunStruct结构图去持有用来描述空格的属性。然后初始化一个包含RunStruct的指针，这个结构体的ascent等于图片的高度，宽度等于图片的宽度。</li>\n<li>创建一个CTRunDelegateCallbacks返回ascent、decent和宽度。</li>\n<li>用CTRunDelegateCreate生成一个绑定了callbacks和数据的委托实例。</li>\n<li>创建一个包含委托实例的属性字典，然后添加单个空格到attrString末尾，属性字典其实就是用来持有这些占位空格的位置和大小信息的。</li>\n</ol>\n<p>现在MarkupParser可以处理”img”标签了，你需要调整CTColumnView和CTView去渲染图片。</p>\n<p>打开CTColumnView.swift。把下列用来持有列的图片和图片的frame的代码加到 <figure class=\"highlight plain\"><figcaption><span>ctFrame:CTFrame! ```  语句后面：</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">```Objective-C</div><div class=\"line\">var images: [(image: UIImage, frame: CGRect)] = []</div></pre></td></tr></table></figure></p>\n<p>再然后就是把下列代码加到draw(_:)函数的后面：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">for imageData in images &#123;</div><div class=\"line\">  if let image = imageData.image.cgImage &#123;</div><div class=\"line\">    let imgBounds = imageData.frame</div><div class=\"line\">    context.draw(image, in: imgBounds)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在这段代码中你遍历了每一张图片然后把图片绘制到上下文它正确的frame内。</p>\n<p>然后打开CTView.swift并添加下面这个属性到类的顶部：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// MARK: - Properties</div><div class=\"line\">var imageIndex: Int!</div></pre></td></tr></table></figure></p>\n<p>imageIndex会持续追踪当前的图片索引在你绘制CTColumnView时。</p>\n<p>接下来，把下面一行代码添加到buildFrames(withAttrString:andImages:)函数上方：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">imageIndex = 0</div></pre></td></tr></table></figure></p>\n<p>这标志着images数组的第一个元素。</p>\n<p>然后添加下述attachImagesWithFrame(_:ctframe:margin:columnView)函数到buildFrames(withAttrString:andImages:)函数后面：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">func attachImagesWithFrame(_ images: [[String: Any]],</div><div class=\"line\">                           ctframe: CTFrame,</div><div class=\"line\">                           margin: CGFloat,</div><div class=\"line\">                           columnView: CTColumnView) &#123;</div><div class=\"line\">  //1</div><div class=\"line\">  let lines = CTFrameGetLines(ctframe) as NSArray</div><div class=\"line\">  //2</div><div class=\"line\">  var origins = [CGPoint](repeating: .zero, count: lines.count)</div><div class=\"line\">  CTFrameGetLineOrigins(ctframe, CFRangeMake(0, 0), &amp;origins)</div><div class=\"line\">  //3</div><div class=\"line\">  var nextImage = images[imageIndex]</div><div class=\"line\">  guard var imgLocation = nextImage[&quot;location&quot;] as? Int else &#123;</div><div class=\"line\">    return</div><div class=\"line\">  &#125;</div><div class=\"line\">  //4</div><div class=\"line\">  for lineIndex in 0..&lt;lines.count &#123;</div><div class=\"line\">    let line = lines[lineIndex] as! CTLine</div><div class=\"line\">    //5</div><div class=\"line\">    if let glyphRuns = CTLineGetGlyphRuns(line) as? [CTRun], </div><div class=\"line\">      let imageFilename = nextImage[&quot;filename&quot;] as? String, </div><div class=\"line\">      let img = UIImage(named: imageFilename)  &#123; </div><div class=\"line\">        for run in glyphRuns &#123;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ol>\n<li>获取一个ctframe的CTLine对象的数组。</li>\n<li>用CTFrameGetOrigins去复制ctframe的行初始点坐标到origins数组中。通过设置长度为0的range，CTFrameGetOrigins将知道要遍历整个CTFrame。</li>\n<li>设置nextImage以包含当前图像的属性数据。如果nextImage包含图像的位置，请将其展开并继续；否则，早点返回函数。</li>\n<li>遍历下一行文本。</li>\n<li>如果这一行的字形、文件名和图片文件名都存在的话，则遍历这一行的字形。</li>\n</ol>\n<p>然后呢，添加下列代码到字形的for-loop语句块中：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1</div><div class=\"line\">let runRange = CTRunGetStringRange(run)    </div><div class=\"line\">if runRange.location &gt; imgLocation || runRange.location + runRange.length &lt;= imgLocation &#123;</div><div class=\"line\">  continue</div><div class=\"line\">&#125;</div><div class=\"line\">//2</div><div class=\"line\">var imgBounds: CGRect = .zero</div><div class=\"line\">var ascent: CGFloat = 0       </div><div class=\"line\">imgBounds.size.width = CGFloat(CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &amp;ascent, nil, nil))</div><div class=\"line\">imgBounds.size.height = ascent</div><div class=\"line\">//3</div><div class=\"line\">let xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, nil)</div><div class=\"line\">imgBounds.origin.x = origins[lineIndex].x + xOffset </div><div class=\"line\">imgBounds.origin.y = origins[lineIndex].y</div><div class=\"line\">//4</div><div class=\"line\">columnView.images += [(image: img, frame: imgBounds)]</div><div class=\"line\">//5</div><div class=\"line\">imageIndex! += 1</div><div class=\"line\">if imageIndex &lt; images.count &#123;</div><div class=\"line\">  nextImage = images[imageIndex]</div><div class=\"line\">  imgLocation = (nextImage[&quot;location&quot;] as AnyObject).intValue</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ol>\n<li>如果当前字形的范围不包含下一个图像，则跳过循环的其余部分。否则，在此渲染图像。</li>\n<li>使用CTRunGetTypographicBounds计算图像宽度，并将高度设置为ascent。</li>\n<li>用CTLineGetOffsetForStringIndex获取线的x偏移，然后将其添加到imgBounds的起点坐标。</li>\n<li>将图像及其frame添加到当前的CTColumnView。</li>\n<li>增加图像索引。如果images[imageIndex]是一个图片，则更新nextImage和imgLocation，以便它们引用下一个图像。<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-b00481e7f05f0bce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></li>\n</ol>\n<p>好了！干得漂亮！基本完成，还剩下最后一步。</p>\n<p>在buildFrames(withAttrString:andImages:)内部的pageView.addSubview(column)上面添加以下代码用以附加图像(如果图像存在的话)：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">if images.count &gt; imageIndex &#123;</div><div class=\"line\">  attachImagesWithFrame(images, ctframe: ctframe, margin: settings.margin, columnView: column)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Build并且运行到iPhone和iPad上：<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-9a01dbec1c6ea94d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>恭喜你！因为感激你所做的这些辛苦的工作，僵尸先生决定不吃你的大脑了！</p>\n<h3 id=\"何去何从\"><a href=\"#何去何从\" class=\"headerlink\" title=\"何去何从\"></a>何去何从</h3><p>在<a href=\"https://koenig-media.raywenderlich.com/uploads/2017/06/CoreTextMagazine-2.zip\" target=\"_blank\" rel=\"external\">这里</a>查看完整的项目。</p>\n<p>正如介绍中所述，Text Kit通常可以替代Core Text；所以尝试用Text Kit编写同一个教程吧，比较一下两者有什么不同。也就是说，这堂Core Text课程不会白学！<br>Text Kit提供免费桥接(toll free bridging)到Core Text，因此你可以根据你的需要轻松地在框架之间进行转换。</p>\n<p>有任何问题，意见或建议？加入论坛讨论吧！</p>\n","excerpt":"","more":"<p>原文链接：<a href=\"https://www.raywenderlich.com/153591/core-text-tutorial-ios-making-magazine-app\">https://www.raywenderlich.com/153591/core-text-tutorial-ios-making-magazine-app</a>  </p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/698554-57c6d4f3c2df1c38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"杂志，Core Text和大脑！\"><br>更新说明：本教程已经由Lyndsey Scott升级为Swift 4和Xcode 9。最初的教程由Marin Todorov所创作。</p>\n<p>Core Text是一个底层的文本引擎，当与Core Graphics/Quartz框架配合使用的时候，可以对布局和格式进行细粒度的控制。</p>\n<p>随着iOS 7的发布，Apple公司发布了一个名叫Text Kit的高级库，可以用来储存、布局和显示具有各种排版特征的文本。虽然Text Kit在布局文本时不仅强大而且大部分情况下已经足够用了，但是Core Text可以提供更多的控制。例如，如果你想直接使用Quartz的话，那就请用Core Text吧。如果你需要构建你自己的布局引擎的话，Core Text将会帮助你生成<a href=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/CoreText_Programming/Introduction/Introduction.html#//apple_ref/doc/uid/TP40005533\">字形(glyphs)并且根据互相之间的关系摆放好这些字形，并具有好的排版的所有特性</a>。</p>\n<p>本教程将会引导你使用Core Text去创作一本非常简单的杂志应用…给僵尸看的！<br>呃，僵尸月刊的读者朋友们已经宽容的答应了，只要你本教程认真使用Core Text的话，就不会吃掉你的大脑了…所以呢，你还是尽快开始吧！</p>\n<blockquote>\n<p>说明：要充分读懂本教程，你首先需要了解iOS开发的基础。如果你是iOS开发的新人的话，你应该首先查看本网站的<a href=\"https://www.raywenderlich.com/category/ios\">其他教程</a>。</p>\n</blockquote>\n<h3 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h3><p>打开Xcode，用Single View Application模板创建一个新的Swift universal project，命名为CoreTextMagazine。</p>\n<p>然后，将Core Text框架加到你的工程中：</p>\n<ol>\n<li>单击工程导航器中的工程文件(在左边的导航条上)</li>\n<li>在”General”按钮下，滚动到底部的”Linked Frameworks and Libraries”</li>\n<li>单击”+”按钮然后找到”CoreText”</li>\n<li>选中”CoreText.framework”然后点击”Add”按钮。就这么简单！</li>\n</ol>\n<p>现在工程已经配置好了，是时候开始写代码了。</p>\n<h3 id=\"添加一个Core-Text-View\"><a href=\"#添加一个Core-Text-View\" class=\"headerlink\" title=\"添加一个Core Text View\"></a>添加一个Core Text View</h3><p>首先，你将要创建一个自定义的UIView，在这个UIView的draw(_:)方法中将会用到Core Text。</p>\n<p>创建一个新的继承于UIView的Cocoa Touch Class file，命名为CTView。打开CTView.swift，然后在 <figure class=\"highlight plain\"><figcaption><span>UIKit ``` 语句下面加上下面的代码：</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">```Objective-C</div><div class=\"line\">import CoreText</div></pre></td></tr></table></figure></p>\n<p>然后，将这个自定义的view设置为应用的主视图。打开Main.storyboard，在右边打开Utilities菜单，然后在顶部工具条单击Identity Inspector图标。在Interface Builder的左侧菜单中，选中View。现在在Utilities菜单的Class字段中应该写着UIView。在Class字段输入CTView以子类化主视图控制器的视图，然后点击回车键。<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-e426ca1cea702142.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>接下来，打开CTView.swift并将被注释掉的draw(_:)方法全都替换成下面的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">//1\t \t </div><div class=\"line\">override func draw(_ rect: CGRect) &#123;\t \t </div><div class=\"line\">  // 2\t \t </div><div class=\"line\">  guard let context = UIGraphicsGetCurrentContext() else &#123; return &#125;\t \t </div><div class=\"line\">  // 3\t \t </div><div class=\"line\">  let path = CGMutablePath()\t \t </div><div class=\"line\">  path.addRect(bounds)\t \t </div><div class=\"line\">  // 4</div><div class=\"line\">  let attrString = NSAttributedString(string: &quot;Hello World&quot;)</div><div class=\"line\">  // 5</div><div class=\"line\">  let framesetter = CTFramesetterCreateWithAttributedString(attrString as CFAttributedString)</div><div class=\"line\">  // 6</div><div class=\"line\">  let frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, attrString.length), path, nil) </div><div class=\"line\">  // 7</div><div class=\"line\">  CTFrameDraw(frame, context)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>让我们一步一步地分析一下代码：</p>\n<ol>\n<li>在视图创建的时候，draw(_:)会自动运行，渲染这个视图的背景图层。</li>\n<li>打开用于绘制的当前图形上下文。</li>\n<li>创建一条用来限定绘图区域的路径，在这个例子中就是整个视图的bounds。</li>\n<li>在Core Text，使用NSAttributedString而不是String或者NSString，保存文本和属性(attributes)。初始化一个”Hello World”的属性字符串。</li>\n<li>CTFramesetterCreateWithAttributedString使用提供的属性字符串创建一个CTFramesetter。CTFramesetter会管理你引用的字体和绘图区域。</li>\n<li>通过使CTFramesetterCreateFrame在路径内渲染整个字符串，可以创建一个CTFrame。</li>\n<li>CTFrameDraw在给定的上下文中绘制CTFrame。<br>这就是你绘制简单文本所需要做的全部了！Build，运行然后查看结果。<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-bdfec1f8b8817617.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></li>\n</ol>\n<p>噢不…似乎看起来不太对。就像很多的底层API一样，Core Text使用的是Y-flipped坐标系统。更糟糕的是，内容在竖直方向上也翻转了！</p>\n<p>添加以下代码到<figure class=\"highlight plain\"><figcaption><span>let context ```语句以修正内容的方向：</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">```Objective-C</div><div class=\"line\">// Flip the coordinate system</div><div class=\"line\">context.textMatrix = .identity</div><div class=\"line\">context.translateBy(x: 0, y: bounds.size.height)</div><div class=\"line\">context.scaleBy(x: 1.0, y: -1.0)</div></pre></td></tr></table></figure></p>\n<p>这段代码通过应用变换(transformation)到视图的上下文来将内容翻转。</p>\n<p>Build然后运行app。别担心状态栏重叠的问题，你接下来会学到怎样通过约束解决这个问题。<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-5febf55f8e6bc993.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>祝贺你的第一个Core Text软件！僵尸们很高兴看到你的进步。</p>\n<h3 id=\"Core-Text对象模型\"><a href=\"#Core-Text对象模型\" class=\"headerlink\" title=\"Core Text对象模型\"></a>Core Text对象模型</h3><p>如果你对CTFramesetter和CTFrame感到有点疑惑也是正常的，也是时候说明一下它们了。:]<br>Core Text对象模型如下所示：<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-e7418de12cb5ae45.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>当你提供一个NSAttributedString创建一个CTFramesetter对象实例的时候，一个CTTypesetter的实例对象会自动为你创建用以管理你的字体。接下来你会在渲染文本的时候用到这个CTFramesetter去创建一个或者多个frame。</p>\n<p>当你创建了一个frame，你可以为这个frame提供文本的一个subrange去渲染这段文本。Core Text会自动为文本的每一行创建一个CTLine，并为每个具有相同格式的字符创建一个CTRun。举个例子，Core Text只会创建一个CTRun用于同一行中的几个红色的单词，创建一个CTRun用于接下来的纯文本，创建一个CTRun用于粗体段落等等。Core Text创建会根据你提供的NSAttributedString中的属性创建CTRun。此外，上面说到的每一个CTRun对象都可以采用不同的属性，也就是说，你可以很好地控制字距、连字、宽度、高度等。</p>\n<h3 id=\"深入杂志App！\"><a href=\"#深入杂志App！\" class=\"headerlink\" title=\"深入杂志App！\"></a>深入杂志App！</h3><p>下载并解压<a href=\"http://www.raywenderlich.com/downloads/zombieMagMaterials.zip\">the zombie magazine materials</a>。拖拽解压出来的文件夹到你的Xcode工程中。当弹出对话框时，确保Copy items if needed和Create groups选中。</p>\n<p>为了创建这个app，你需要对文本应用各种属性。你将要创建一个用标签设置杂志格式的简单文本标记解析器。</p>\n<p>创建一个新的Cocoa Touch Class file，命名为MarkupParser，继承于NSObject。</p>\n<p>首先，我们快速看一下zombies.txt。看看它是如何在整个文本中包含括号内的格式化标签的。”img src”标签指向杂志的图片，而”font color/face”标签则确定了文本的颜色和字体。</p>\n<p>打开MarkupParser.swift然后将它的内容替换为以下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">import UIKit</div><div class=\"line\">import CoreText</div><div class=\"line\"></div><div class=\"line\">class MarkupParser: NSObject &#123;</div><div class=\"line\">  </div><div class=\"line\">  // MARK: - Properties</div><div class=\"line\">  var color: UIColor = .black</div><div class=\"line\">  var fontName: String = &quot;Arial&quot;</div><div class=\"line\">  var attrString: NSMutableAttributedString!</div><div class=\"line\">  var images: [[String: Any]] = []</div><div class=\"line\"></div><div class=\"line\">  // MARK: - Initializers</div><div class=\"line\">  override init() &#123;</div><div class=\"line\">    super.init()</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  // MARK: - Internal</div><div class=\"line\">  func parseMarkup(_ markup: String) &#123;</div><div class=\"line\"></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>你在这段代码中添加了属性持有字体和文本颜色，设置了它们的初始值。创建了一个变量去持有parseMarkup(_:)生成的属性字符串。还创建了一个数组用来持有定义了尺寸、位置以及从文本中解析出来的图片文件名等信息的键值对。</p>\n<p>通常来说，写一个解析器并不是一个轻松的工作，但是本教程所实现的解析器将会非常简易，只提供开放标签的支持，也就意味着一个标签会决定紧随着这个标签的文本的样式，直到找到一个新的标签。这段文本的标记如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">These are &lt;font color=&quot;red&quot;&gt;red&lt;font color=&quot;black&quot;&gt; and</div><div class=\"line\">&lt;font color=&quot;blue&quot;&gt;blue &lt;font color=&quot;black&quot;&gt;words.</div></pre></td></tr></table></figure></p>\n<p>输出如下所示：<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-6d55091e685937d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>将以下代码加到 <figure class=\"highlight plain\"><figcaption><span>``` 方法中：</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">```Objective-C</div><div class=\"line\">//1</div><div class=\"line\">attrString = NSMutableAttributedString(string: &quot;&quot;)</div><div class=\"line\">//2 </div><div class=\"line\">do &#123;</div><div class=\"line\">  let regex = try NSRegularExpression(pattern: &quot;(.*?)(&lt;[^&gt;]+&gt;|\\\\Z)&quot;,</div><div class=\"line\">                                      options: [.caseInsensitive,</div><div class=\"line\">                                                .dotMatchesLineSeparators])</div><div class=\"line\">  //3</div><div class=\"line\">  let chunks = regex.matches(in: markup, </div><div class=\"line\">                             options: NSRegularExpression.MatchingOptions(rawValue: 0), </div><div class=\"line\">                             range: NSRange(location: 0,</div><div class=\"line\">                                            length: markup.characters.count))</div><div class=\"line\">&#125; catch _ &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ol>\n<li>attrString初始为空，但是最后会包含解析出来的标记。</li>\n<li>这个正则表达式，匹配了紧跟着这些标签的文本块。它就好像在说：“去查看字符串直到你找到一个开头的括号，然后查看字符串直到你找到一个结束的括号（或者文档的末尾）”。</li>\n<li>搜索regex匹配到的整个标记范围，然后生成一个NSTextCheckingResult的数组。</li>\n</ol>\n<blockquote>\n<p>想要学习更多有关正则表达式的内容，访问<a href=\"https://www.raywenderlich.com/86205/nsregularexpression-swift-tutorial\">NSRegularExpression Tutorial</a>吧。</p>\n</blockquote>\n<p>现在你已经解析了所有的文本并将所有格式化的标签都放进了chunks中，你要做的就是遍历chunks数组去生成对应的属性字符串。</p>\n<p>但在那之前，你是否留意到matches(in:options:range:)方法是如何接受一个NSRange作为参数的吗？在你应用NSRegularExpression到你的标记String的时候会有大量NSRange到Range的转化。Swift已经成为了我们所有人的好帮手，所以它值得帮助。</p>\n<p>还是在MarkupParser.swift中，将下面的extension加到文件的最后面：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">// MARK: - String</div><div class=\"line\">extension String &#123;</div><div class=\"line\">  func range(from range: NSRange) -&gt; Range&lt;String.Index&gt;? &#123;</div><div class=\"line\">    guard let from16 = utf16.index(utf16.startIndex,</div><div class=\"line\">                                   offsetBy: range.location,</div><div class=\"line\">                                   limitedBy: utf16.endIndex),</div><div class=\"line\">      let to16 = utf16.index(from16, offsetBy: range.length, limitedBy: utf16.endIndex),</div><div class=\"line\">      let from = String.Index(from16, within: self),</div><div class=\"line\">      let to = String.Index(to16, within: self) else &#123;</div><div class=\"line\">        return nil</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">    return from ..&lt; to</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面这个函数将以NSRange表示的字符串的起止索引转换为了String.UTF16View.Index格式，即UTF-16字符串中的位置(position)集合，然后将每个String.UTF16View.Index格式转换为String.Index格式。String.Index格式在组合时，会生成Swift的范围格式：Range。只要索引是有效的，这个函数就会返回原始NSRange格式对应的Range格式。</p>\n<p>现在是时候回头处理文本和标签数组了。<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-2c69a03c16835494.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>在parseMarkup(_:)函数中添加一下代码到 <figure class=\"highlight plain\"><figcaption><span>chunks ``` 到下面(在do循环语句块中)：</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">```Objective-C</div><div class=\"line\">let defaultFont: UIFont = .systemFont(ofSize: UIScreen.main.bounds.size.height / 40)</div><div class=\"line\">//1</div><div class=\"line\">for chunk in chunks &#123;  </div><div class=\"line\">  //2</div><div class=\"line\">  guard let markupRange = markup.range(from: chunk.range) else &#123; continue &#125;</div><div class=\"line\">  //3    </div><div class=\"line\">  let parts = markup.substring(with: markupRange).components(separatedBy: &quot;&lt;&quot;)</div><div class=\"line\">  //4</div><div class=\"line\">  let font = UIFont(name: fontName, size: UIScreen.main.bounds.size.height / 40) ?? defaultFont       </div><div class=\"line\">  //5</div><div class=\"line\">  let attrs = [NSAttributedStringKey.foregroundColor: color, NSAttributedStringKey.font: font] as [NSAttributedStringKey : Any]</div><div class=\"line\">  let text = NSMutableAttributedString(string: parts[0], attributes: attrs)</div><div class=\"line\">  attrString.append(text)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ol>\n<li>循环chunks数组。</li>\n<li>获取当前NSTextCheckingResult的range，展开Range<String.Index>并且只要range存在就继续执行以下的语句块。</li>\n<li>将chunk用”&lt;”分割成几部分。第一部分包含了杂志的文本而第二部分包含了对应的标签(如果标签存在的话)。</li>\n<li>用fontName生成字体，现在的默认字体是”Arial”，并且根据设备屏幕创建了字体的大小。假如fontName不能产生有效的UIFont的话，将默认字体设为当前字体。</li>\n<li>创建字体格式的字典，将其应用于parts[0]以创建属性字符串，然后将该字符串添加到结果字符串后面。</li>\n</ol>\n<p>将下面用来处理”font”标签的代码插到attrString.append(text)下面：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1</div><div class=\"line\">if parts.count &lt;= 1 &#123;</div><div class=\"line\">  continue</div><div class=\"line\">&#125;</div><div class=\"line\">let tag = parts[1]</div><div class=\"line\">//2</div><div class=\"line\">if tag.hasPrefix(&quot;font&quot;) &#123;</div><div class=\"line\">  let colorRegex = try NSRegularExpression(pattern: &quot;(?&lt;=color=\\&quot;)\\\\w+&quot;, </div><div class=\"line\">                                           options: NSRegularExpression.Options(rawValue: 0))</div><div class=\"line\">  colorRegex.enumerateMatches(in: tag, </div><div class=\"line\">    options: NSRegularExpression.MatchingOptions(rawValue: 0), </div><div class=\"line\">    range: NSMakeRange(0, tag.characters.count)) &#123; (match, _, _) in</div><div class=\"line\">      //3</div><div class=\"line\">      if let match = match,</div><div class=\"line\">        let range = tag.range(from: match.range) &#123;</div><div class=\"line\">          let colorSel = NSSelectorFromString(tag.substring(with:range) + &quot;Color&quot;)</div><div class=\"line\">          color = UIColor.perform(colorSel).takeRetainedValue() as? UIColor ?? .black</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  //5    </div><div class=\"line\">  let faceRegex = try NSRegularExpression(pattern: &quot;(?&lt;=face=\\&quot;)[^\\&quot;]+&quot;,</div><div class=\"line\">                                          options: NSRegularExpression.Options(rawValue: 0))</div><div class=\"line\">  faceRegex.enumerateMatches(in: tag, </div><div class=\"line\">    options: NSRegularExpression.MatchingOptions(rawValue: 0), </div><div class=\"line\">    range: NSMakeRange(0, tag.characters.count)) &#123; (match, _, _) in</div><div class=\"line\"></div><div class=\"line\">      if let match = match,</div><div class=\"line\">        let range = tag.range(from: match.range) &#123;</div><div class=\"line\">          fontName = tag.substring(with: range)</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125; //end of font parsing</div></pre></td></tr></table></figure></p>\n<ol>\n<li>如果parts数组元素少于2个，则跳过这个循环语句块。否则的话，将parts的第二部分存为tag。</li>\n<li>如果tag以”font”开始则创建一个正则表达式去匹配字体的”color”值，然后用这个正则去枚举匹配到的tag中的”color”值。在这种情况下，只应该有一个匹配到的颜色值。</li>\n<li>如果enumerateMatches(in:options:range:using:)函数返回标签的一个有效的match和一个有效的range的话，就去搜索出指示值，接着用这个颜色值生成一个UIColor的selector。执行这个selector所返回得到的color(如果存在的话)会赋值到你的类的color属性上，如果返回的color不存在的话，color属性会被赋值为black。</li>\n<li>同样的，创建一个正则表达式去处理文本中字体的”face”值。如果匹配到一个”face”值，则将类的fontName属性设置为匹配的”face”值。</li>\n</ol>\n<p>干得漂亮！现在parseMarkup(_:)函数已经可以获取文本中的标记并生成一个对应的NSAttributedString了。</p>\n<p>现在也是时候把你的app喂给一些僵尸了！我的意思是，喂一些僵尸给你的app… 也就是说，(开始处理)zombies.txt。</p>\n<p>事实上，显示出被赋予的内容才是UIView的职责所在，而不是去加载内容。打开CTView.swift然后将下面代码添加到draw(_:)方法之前：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// MARK: - Properties</div><div class=\"line\">var attrString: NSAttributedString!</div><div class=\"line\"></div><div class=\"line\">// MARK: - Internal</div><div class=\"line\">func importAttrString(_ attrString: NSAttributedString) &#123;</div><div class=\"line\">  self.attrString = attrString</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>接下来，将 <figure class=\"highlight plain\"><figcaption><span>attrString = NSAttributedString(string: \"Hello World\") ``` 从draw(_:)函数中删除。</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">这段代码中你创建了一个实例变量持有属性字符串和一个函数以便app的其他地方可以设置这个属性字符串。</div><div class=\"line\"></div><div class=\"line\">然后，打开ViewController.swift并将以下代码添加到viewDidLoad()中：</div><div class=\"line\">```Objective-C</div><div class=\"line\">// 1</div><div class=\"line\">guard let file = Bundle.main.path(forResource: &quot;zombies&quot;, ofType: &quot;txt&quot;) else &#123; return &#125;</div><div class=\"line\">  </div><div class=\"line\">do &#123;</div><div class=\"line\">  let text = try String(contentsOfFile: file, encoding: .utf8)</div><div class=\"line\">  // 2</div><div class=\"line\">  let parser = MarkupParser()</div><div class=\"line\">  parser.parseMarkup(text)</div><div class=\"line\">  (view as? CTView)?.importAttrString(parser.attrString)</div><div class=\"line\">&#125; catch _ &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后一步步的过一下这段代码：</p>\n<ol>\n<li>从zombie.txt文件中加载文本。</li>\n<li>创建一个新的解析器，传入文本作为参数，然后将返回的属性字符串赋给ViewController的CTView。</li>\n</ol>\n<p>Build并且运行这个app！<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-a816139b2aed7b2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>简直太棒了！归功于这50多行解析代码你可以轻松的用文本文件持有你杂志app的内容了。</p>\n<h3 id=\"基本的杂志布局\"><a href=\"#基本的杂志布局\" class=\"headerlink\" title=\"基本的杂志布局\"></a>基本的杂志布局</h3><p>如果你认为僵尸新闻的每月杂志只能全塞在一个可怜的页面中，那么你就错了！幸运的是，Core Text在文本列布局时相当有用，因为CTFrameGetVisibleStringRange可以告诉给定frame的情况下显示多少文本才是合适的。也就是说，你可以创建一列文本，当这一列塞满文本之后，你可以知道并开始新的一列。</p>\n<p>就本app而言，你需要先打印出列，然后集列成页，再集页成文。未免冒犯这些亡灵，所以。。。你还是尽快把把你的CTView改成继承于UIScrollView。<br>打开CTView.swift然后将 <figure class=\"highlight plain\"><figcaption><span>CTView ``` 一行改成以下代码：</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">```Objective-C</div><div class=\"line\">class CTView: UIScrollView &#123;</div></pre></td></tr></table></figure></p>\n<p>看到了吗，僵尸老爷？现在这个app已经支持永恒不死了！对的，行、滚动以及翻页现在都是可用的了。<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-f7c0cd8d0f47a219.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>到现在为止，你已经在draw(_:)方法里创建了framesetter和frame了，不过由于你有很多不同格式的文本列，所以最好还是创建一个独立的实例表征所述的文本列。</p>\n<p>创建一个新的名为CTColumnView的Cocoa Touch Class file，继承于UIView。<br>打开CTColumnView.swift并添加下列初始代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">import UIKit</div><div class=\"line\">import CoreText</div><div class=\"line\"></div><div class=\"line\">class CTColumnView: UIView &#123;</div><div class=\"line\">  </div><div class=\"line\">  // MARK: - Properties</div><div class=\"line\">  var ctFrame: CTFrame!</div><div class=\"line\">  </div><div class=\"line\">  // MARK: - Initializers</div><div class=\"line\">  required init(coder aDecoder: NSCoder) &#123;</div><div class=\"line\">    super.init(coder: aDecoder)!</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  required init(frame: CGRect, ctframe: CTFrame) &#123;</div><div class=\"line\">    super.init(frame: frame)</div><div class=\"line\">    self.ctFrame = ctframe</div><div class=\"line\">    backgroundColor = .white</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  // MARK: - Life Cycle</div><div class=\"line\">  override func draw(_ rect: CGRect) &#123;</div><div class=\"line\">    guard let context = UIGraphicsGetCurrentContext() else &#123; return &#125;</div><div class=\"line\">      </div><div class=\"line\">    context.textMatrix = .identity</div><div class=\"line\">    context.translateBy(x: 0, y: bounds.size.height)</div><div class=\"line\">    context.scaleBy(x: 1.0, y: -1.0)</div><div class=\"line\">      </div><div class=\"line\">    CTFrameDraw(ctFrame, context)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>跟开始在CTView里做的工作一样，这段代码生成了一个CTFrame。自定义的初始化函数init(frame:ctframe:)设置了：</p>\n<ol>\n<li>这个视图的frame。</li>\n<li>在当前上下文中绘制的CTFrame。</li>\n<li>以及将这个视图的背景颜色设置为白色。</li>\n</ol>\n<p>接下来，创建一个新的swift文件命名为CTSettings.swift，用来持有你的文本列的设置。<br>将CTSettings.swift的内容替换为以下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">import UIKit</div><div class=\"line\">import Foundation</div><div class=\"line\"></div><div class=\"line\">class CTSettings &#123;</div><div class=\"line\">  //1</div><div class=\"line\">  // MARK: - Properties</div><div class=\"line\">  let margin: CGFloat = 20</div><div class=\"line\">  var columnsPerPage: CGFloat!</div><div class=\"line\">  var pageRect: CGRect!</div><div class=\"line\">  var columnRect: CGRect!</div><div class=\"line\">  </div><div class=\"line\">  // MARK: - Initializers</div><div class=\"line\">  init() &#123;</div><div class=\"line\">    //2</div><div class=\"line\">    columnsPerPage = UIDevice.current.userInterfaceIdiom == .phone ? 1 : 2</div><div class=\"line\">    //3</div><div class=\"line\">    pageRect = UIScreen.main.bounds.insetBy(dx: margin, dy: margin)</div><div class=\"line\">    //4</div><div class=\"line\">    columnRect = CGRect(x: 0,</div><div class=\"line\">                        y: 0,</div><div class=\"line\">                        width: pageRect.width / columnsPerPage,</div><div class=\"line\">                        height: pageRect.height).insetBy(dx: margin, dy: margin)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ol>\n<li>这些属性将用来确定page的约束(在这个教程中约束默认是20)、在每一个页中文本列的数量、包含文本列的每一页的frame以及每一页中的每一个文本列的frame。</li>\n<li>由于这本杂志的服务对象是拿着iPhone和iPad的僵尸们，iPad上显示两列，iPhone上显示一列，这样的列数对于任意的屏幕尺寸来说都是适宜的。</li>\n<li>用约束的大小计算出来的pageRect去布局页面的边界。</li>\n<li>用每一页的文本列数量划分pageRect的宽度并配合约束去计算出columnRect。</li>\n</ol>\n<p>打开CTView.swift，将文件中的内容整个替换成下列代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">import UIKit</div><div class=\"line\">import CoreText</div><div class=\"line\"></div><div class=\"line\">class CTView: UIScrollView &#123;</div><div class=\"line\"></div><div class=\"line\">  //1</div><div class=\"line\">  func buildFrames(withAttrString attrString: NSAttributedString,</div><div class=\"line\">                   andImages images: [[String: Any]]) &#123;</div><div class=\"line\">    //2</div><div class=\"line\">    isPagingEnabled = true</div><div class=\"line\">    //3</div><div class=\"line\">    let framesetter = CTFramesetterCreateWithAttributedString(attrString as CFAttributedString)</div><div class=\"line\">    //4</div><div class=\"line\">    var pageView = UIView()</div><div class=\"line\">    var textPos = 0</div><div class=\"line\">    var columnIndex: CGFloat = 0</div><div class=\"line\">    var pageIndex: CGFloat = 0</div><div class=\"line\">    let settings = CTSettings()</div><div class=\"line\">    //5</div><div class=\"line\">    while textPos &lt; attrString.length &#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ol>\n<li>buildFrames(withAttrString:andImages:)函数会创建并添加CTColumnView到滚动视图。</li>\n<li>运行滚动视图的翻页行为；也就是说，用户不管什么时候停止滚动，滚动视图都能卡到位置使得同一时间只有一个完整的页面在显示。</li>\n<li>CTFramesetter framesetter会为创建的每一列CTFrame提供属性字符串。</li>\n<li>UIView pageView会作为每个页面文本列对应的子视图的容器；textPos会持续跟踪接下来的文字；columnIndex会持续跟踪当前列；pageIndex会持续跟踪当前页；同时settings能让你访问app的约束尺寸、每页的列、页的frame和列frame的设置等。</li>\n<li>你将要遍历attrString然后逐列布局文本直到当前文本的位置到了最末尾。</li>\n</ol>\n<p>是时候开始遍历attrString了。把下列代码加进 <figure class=\"highlight plain\"><figcaption><span>textPos < attrString.length &#123; ``` 里面：</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">```Objective-C</div><div class=\"line\">//1</div><div class=\"line\">if columnIndex.truncatingRemainder(dividingBy: settings.columnsPerPage) == 0 &#123;</div><div class=\"line\">  columnIndex = 0</div><div class=\"line\">  pageView = UIView(frame: settings.pageRect.offsetBy(dx: pageIndex * bounds.width, dy: 0))</div><div class=\"line\">  addSubview(pageView)</div><div class=\"line\">  //2</div><div class=\"line\">  pageIndex += 1</div><div class=\"line\">&#125;   </div><div class=\"line\">//3</div><div class=\"line\">let columnXOrigin = pageView.frame.size.width / settings.columnsPerPage</div><div class=\"line\">let columnOffset = columnIndex * columnXOrigin</div><div class=\"line\">let columnFrame = settings.columnRect.offsetBy(dx: columnOffset, dy: 0)</div></pre></td></tr></table></figure></p>\n<ol>\n<li>如果用每页列数划分的列索引等于0，也就能说明这是所在页的第一列，那么就创建新页视图持有这些列。为了设置这些列的frame，需要获取算好约束的setting. pageRect按照当前页面索引乘以屏幕宽度来对其原点计算偏移量。这样才能在翻页滚动视图内部保证杂志每一页都在前一页的右边。</li>\n<li>自增pageIndex。</li>\n<li>通过settings.columnsPerPage将pageView的宽度除以第一列的x原点，将该列乘以列索引以获得列偏移量；然后通过采用标准columnRect并通过columnOffset将其x原点偏移来创建当前列的frame。</li>\n</ol>\n<p>接下来把下列代码加到columnFrame初始化方法的下面：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">//1   </div><div class=\"line\">let path = CGMutablePath()</div><div class=\"line\">path.addRect(CGRect(origin: .zero, size: columnFrame.size))</div><div class=\"line\">let ctframe = CTFramesetterCreateFrame(framesetter, CFRangeMake(textPos, 0), path, nil)</div><div class=\"line\">//2</div><div class=\"line\">let column = CTColumnView(frame: columnFrame, ctframe: ctframe)</div><div class=\"line\">pageView.addSubview(column)</div><div class=\"line\">//3</div><div class=\"line\">let frameRange = CTFrameGetVisibleStringRange(ctframe)</div><div class=\"line\">textPos += frameRange.length</div><div class=\"line\">//4</div><div class=\"line\">columnIndex += 1</div></pre></td></tr></table></figure></p>\n<ol>\n<li>创建一个CGMutablePath大小的列，然后从textPos开始在合适的范围内渲染足够多的文本到CTFrame中。</li>\n<li>用CGRect类型的columnFrame和CTFrame类型的ctframe创建一个CTColumnView并将这一列加到pageView上。</li>\n<li>用CTFrameGetVisibleStringRange(_:)函数计算用列限制的文本的范围，然后用这个计算出来的范围自增textPos的值。</li>\n<li>在遍历到下一列之前将column的索引值加1。</li>\n</ol>\n<p>最后在遍历完成之后设置好滚动视图的size：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">contentSize = CGSize(width: CGFloat(pageIndex) * bounds.size.width,</div><div class=\"line\">                     height: bounds.size.height)</div></pre></td></tr></table></figure></p>\n<p>通过将内容大小设置为屏幕宽度乘以页数，僵尸先生现在可以滚动杂志到最后了。</p>\n<p>打开ViewController.swift，将原先的下列代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(view as? CTView)?.importAttrString(parser.attrString)</div></pre></td></tr></table></figure></p>\n<p>替换为下列代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(view as? CTView)?.buildFrames(withAttrString: parser.attrString, andImages: parser.images)</div></pre></td></tr></table></figure></p>\n<p>Build并在iPad上运行应用。检查一下双列布局！在页面间左右拖动试试。看起来棒极了！<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-b14a1b1e5fe27a9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>你已经有了按列排列且格式化好的文本了，但是你还忘了图片呢。用Core Text绘制图片并不是那么简单，Core Text毕竟是一个文本处理框架，但是呢在你刚刚创建的标记解析器的帮助之下，添加图片也没有那么糟糕。</p>\n<h3 id=\"用Core-Text绘制图片\"><a href=\"#用Core-Text绘制图片\" class=\"headerlink\" title=\"用Core Text绘制图片\"></a>用Core Text绘制图片</h3><p>虽然Core Text不能直接绘制图片，但是作为一个布局引擎，它可以为图片留开空间。通过设置为CTRun的delegate，你可以确定CTRun的ascent空间、decent空间和宽度。就像下面这样：<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-2f22c94e5dde428a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>当Core Text遇到一个设置了CTRunDelegate的CTRun，它就会询问delegate：“我需要留多少空间给这块的数据”。通过在CTRunDelegate中设置这些属性，您可以在文本中给图片留开空位。</p>\n<p>首先让(解析器)支持”img”标签。打开MarkupParser.swift然后找到”} //end of font parsing”语句。并将下面代码加到后面：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">//1</div><div class=\"line\">else if tag.hasPrefix(&quot;img&quot;) &#123; </div><div class=\"line\">      </div><div class=\"line\">  var filename:String = &quot;&quot;</div><div class=\"line\">  let imageRegex = try NSRegularExpression(pattern: &quot;(?&lt;=src=\\&quot;)[^\\&quot;]+&quot;,</div><div class=\"line\">                                           options: NSRegularExpression.Options(rawValue: 0))</div><div class=\"line\">  imageRegex.enumerateMatches(in: tag, </div><div class=\"line\">    options: NSRegularExpression.MatchingOptions(rawValue: 0), </div><div class=\"line\">    range: NSMakeRange(0, tag.characters.count)) &#123; (match, _, _) in</div><div class=\"line\"></div><div class=\"line\">    if let match = match,</div><div class=\"line\">      let range = tag.range(from: match.range) &#123;</div><div class=\"line\">        filename = tag.substring(with: range)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  //2</div><div class=\"line\">  let settings = CTSettings()</div><div class=\"line\">  var width: CGFloat = settings.columnRect.width</div><div class=\"line\">  var height: CGFloat = 0</div><div class=\"line\"></div><div class=\"line\">  if let image = UIImage(named: filename) &#123;</div><div class=\"line\">    height = width * (image.size.height / image.size.width)</div><div class=\"line\">    // 3</div><div class=\"line\">    if height &gt; settings.columnRect.height - font.lineHeight &#123;</div><div class=\"line\">      height = settings.columnRect.height - font.lineHeight</div><div class=\"line\">      width = height * (image.size.width / image.size.height)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ol>\n<li>如果tag是以”img”开头的话就用正则去查找图片的”src”值，比如图片的filename。</li>\n<li>设置图片宽度为列的宽度同时在保证图片宽高比的情况下设置图片高度。</li>\n<li>如果图片的高度高过了列的高度就将列的高度设置为图片高度并减少图片的宽度以维持图片的宽高比。</li>\n</ol>\n<p>接下来，将下面代码加到紧随 <figure class=\"highlight plain\"><figcaption><span>let image ``` 语句块后面的地方：</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">```Objective-C</div><div class=\"line\">//1</div><div class=\"line\">images += [[&quot;width&quot;: NSNumber(value: Float(width)),</div><div class=\"line\">            &quot;height&quot;: NSNumber(value: Float(height)),</div><div class=\"line\">            &quot;filename&quot;: filename,</div><div class=\"line\">            &quot;location&quot;: NSNumber(value: attrString.length)]]</div><div class=\"line\">//2</div><div class=\"line\">struct RunStruct &#123;</div><div class=\"line\">  let ascent: CGFloat</div><div class=\"line\">  let descent: CGFloat</div><div class=\"line\">  let width: CGFloat</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let extentBuffer = UnsafeMutablePointer&lt;RunStruct&gt;.allocate(capacity: 1)</div><div class=\"line\">extentBuffer.initialize(to: RunStruct(ascent: height, descent: 0, width: width))</div><div class=\"line\">//3</div><div class=\"line\">var callbacks = CTRunDelegateCallbacks(version: kCTRunDelegateVersion1, dealloc: &#123; (pointer) in</div><div class=\"line\">&#125;, getAscent: &#123; (pointer) -&gt; CGFloat in</div><div class=\"line\">  let d = pointer.assumingMemoryBound(to: RunStruct.self)</div><div class=\"line\">  return d.pointee.ascent</div><div class=\"line\">&#125;, getDescent: &#123; (pointer) -&gt; CGFloat in</div><div class=\"line\">  let d = pointer.assumingMemoryBound(to: RunStruct.self)</div><div class=\"line\">  return d.pointee.descent</div><div class=\"line\">&#125;, getWidth: &#123; (pointer) -&gt; CGFloat in</div><div class=\"line\">  let d = pointer.assumingMemoryBound(to: RunStruct.self)</div><div class=\"line\">  return d.pointee.width</div><div class=\"line\">&#125;)</div><div class=\"line\">//4</div><div class=\"line\">let delegate = CTRunDelegateCreate(&amp;callbacks, extentBuffer)</div><div class=\"line\">//5</div><div class=\"line\">let attrDictionaryDelegate = [(kCTRunDelegateAttributeName as NSAttributedStringKey): (delegate as Any)]              </div><div class=\"line\">attrString.append(NSAttributedString(string: &quot; &quot;, attributes: attrDictionaryDelegate))</div></pre></td></tr></table></figure></p>\n<ol>\n<li>添加包含图片尺寸、文件名和文本位置的字典到images数组中。</li>\n<li>定义RunStruct结构图去持有用来描述空格的属性。然后初始化一个包含RunStruct的指针，这个结构体的ascent等于图片的高度，宽度等于图片的宽度。</li>\n<li>创建一个CTRunDelegateCallbacks返回ascent、decent和宽度。</li>\n<li>用CTRunDelegateCreate生成一个绑定了callbacks和数据的委托实例。</li>\n<li>创建一个包含委托实例的属性字典，然后添加单个空格到attrString末尾，属性字典其实就是用来持有这些占位空格的位置和大小信息的。</li>\n</ol>\n<p>现在MarkupParser可以处理”img”标签了，你需要调整CTColumnView和CTView去渲染图片。</p>\n<p>打开CTColumnView.swift。把下列用来持有列的图片和图片的frame的代码加到 <figure class=\"highlight plain\"><figcaption><span>ctFrame:CTFrame! ```  语句后面：</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">```Objective-C</div><div class=\"line\">var images: [(image: UIImage, frame: CGRect)] = []</div></pre></td></tr></table></figure></p>\n<p>再然后就是把下列代码加到draw(_:)函数的后面：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">for imageData in images &#123;</div><div class=\"line\">  if let image = imageData.image.cgImage &#123;</div><div class=\"line\">    let imgBounds = imageData.frame</div><div class=\"line\">    context.draw(image, in: imgBounds)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在这段代码中你遍历了每一张图片然后把图片绘制到上下文它正确的frame内。</p>\n<p>然后打开CTView.swift并添加下面这个属性到类的顶部：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// MARK: - Properties</div><div class=\"line\">var imageIndex: Int!</div></pre></td></tr></table></figure></p>\n<p>imageIndex会持续追踪当前的图片索引在你绘制CTColumnView时。</p>\n<p>接下来，把下面一行代码添加到buildFrames(withAttrString:andImages:)函数上方：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">imageIndex = 0</div></pre></td></tr></table></figure></p>\n<p>这标志着images数组的第一个元素。</p>\n<p>然后添加下述attachImagesWithFrame(_:ctframe:margin:columnView)函数到buildFrames(withAttrString:andImages:)函数后面：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">func attachImagesWithFrame(_ images: [[String: Any]],</div><div class=\"line\">                           ctframe: CTFrame,</div><div class=\"line\">                           margin: CGFloat,</div><div class=\"line\">                           columnView: CTColumnView) &#123;</div><div class=\"line\">  //1</div><div class=\"line\">  let lines = CTFrameGetLines(ctframe) as NSArray</div><div class=\"line\">  //2</div><div class=\"line\">  var origins = [CGPoint](repeating: .zero, count: lines.count)</div><div class=\"line\">  CTFrameGetLineOrigins(ctframe, CFRangeMake(0, 0), &amp;origins)</div><div class=\"line\">  //3</div><div class=\"line\">  var nextImage = images[imageIndex]</div><div class=\"line\">  guard var imgLocation = nextImage[&quot;location&quot;] as? Int else &#123;</div><div class=\"line\">    return</div><div class=\"line\">  &#125;</div><div class=\"line\">  //4</div><div class=\"line\">  for lineIndex in 0..&lt;lines.count &#123;</div><div class=\"line\">    let line = lines[lineIndex] as! CTLine</div><div class=\"line\">    //5</div><div class=\"line\">    if let glyphRuns = CTLineGetGlyphRuns(line) as? [CTRun], </div><div class=\"line\">      let imageFilename = nextImage[&quot;filename&quot;] as? String, </div><div class=\"line\">      let img = UIImage(named: imageFilename)  &#123; </div><div class=\"line\">        for run in glyphRuns &#123;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ol>\n<li>获取一个ctframe的CTLine对象的数组。</li>\n<li>用CTFrameGetOrigins去复制ctframe的行初始点坐标到origins数组中。通过设置长度为0的range，CTFrameGetOrigins将知道要遍历整个CTFrame。</li>\n<li>设置nextImage以包含当前图像的属性数据。如果nextImage包含图像的位置，请将其展开并继续；否则，早点返回函数。</li>\n<li>遍历下一行文本。</li>\n<li>如果这一行的字形、文件名和图片文件名都存在的话，则遍历这一行的字形。</li>\n</ol>\n<p>然后呢，添加下列代码到字形的for-loop语句块中：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1</div><div class=\"line\">let runRange = CTRunGetStringRange(run)    </div><div class=\"line\">if runRange.location &gt; imgLocation || runRange.location + runRange.length &lt;= imgLocation &#123;</div><div class=\"line\">  continue</div><div class=\"line\">&#125;</div><div class=\"line\">//2</div><div class=\"line\">var imgBounds: CGRect = .zero</div><div class=\"line\">var ascent: CGFloat = 0       </div><div class=\"line\">imgBounds.size.width = CGFloat(CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &amp;ascent, nil, nil))</div><div class=\"line\">imgBounds.size.height = ascent</div><div class=\"line\">//3</div><div class=\"line\">let xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, nil)</div><div class=\"line\">imgBounds.origin.x = origins[lineIndex].x + xOffset </div><div class=\"line\">imgBounds.origin.y = origins[lineIndex].y</div><div class=\"line\">//4</div><div class=\"line\">columnView.images += [(image: img, frame: imgBounds)]</div><div class=\"line\">//5</div><div class=\"line\">imageIndex! += 1</div><div class=\"line\">if imageIndex &lt; images.count &#123;</div><div class=\"line\">  nextImage = images[imageIndex]</div><div class=\"line\">  imgLocation = (nextImage[&quot;location&quot;] as AnyObject).intValue</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ol>\n<li>如果当前字形的范围不包含下一个图像，则跳过循环的其余部分。否则，在此渲染图像。</li>\n<li>使用CTRunGetTypographicBounds计算图像宽度，并将高度设置为ascent。</li>\n<li>用CTLineGetOffsetForStringIndex获取线的x偏移，然后将其添加到imgBounds的起点坐标。</li>\n<li>将图像及其frame添加到当前的CTColumnView。</li>\n<li>增加图像索引。如果images[imageIndex]是一个图片，则更新nextImage和imgLocation，以便它们引用下一个图像。<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-b00481e7f05f0bce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></li>\n</ol>\n<p>好了！干得漂亮！基本完成，还剩下最后一步。</p>\n<p>在buildFrames(withAttrString:andImages:)内部的pageView.addSubview(column)上面添加以下代码用以附加图像(如果图像存在的话)：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">if images.count &gt; imageIndex &#123;</div><div class=\"line\">  attachImagesWithFrame(images, ctframe: ctframe, margin: settings.margin, columnView: column)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Build并且运行到iPhone和iPad上：<br><img src=\"http://upload-images.jianshu.io/upload_images/698554-9a01dbec1c6ea94d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>恭喜你！因为感激你所做的这些辛苦的工作，僵尸先生决定不吃你的大脑了！</p>\n<h3 id=\"何去何从\"><a href=\"#何去何从\" class=\"headerlink\" title=\"何去何从\"></a>何去何从</h3><p>在<a href=\"https://koenig-media.raywenderlich.com/uploads/2017/06/CoreTextMagazine-2.zip\">这里</a>查看完整的项目。</p>\n<p>正如介绍中所述，Text Kit通常可以替代Core Text；所以尝试用Text Kit编写同一个教程吧，比较一下两者有什么不同。也就是说，这堂Core Text课程不会白学！<br>Text Kit提供免费桥接(toll free bridging)到Core Text，因此你可以根据你的需要轻松地在框架之间进行转换。</p>\n<p>有任何问题，意见或建议？加入论坛讨论吧！</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjg4j8vy90002vfwx0wp4r48z","category_id":"cjg4j8vyb0004vfwx525bpdkn","_id":"cjg4j8vyh000cvfwxk3yon1hk"},{"post_id":"cjg4j8vye0008vfwxku8rvfdb","category_id":"cjg4j8vyb0004vfwx525bpdkn","_id":"cjg4j8vyj000gvfwxwxfuo2q0"},{"post_id":"cjg4j8vyg000bvfwxmqdb7s2w","category_id":"cjg4j8vyb0004vfwx525bpdkn","_id":"cjg4j8vyk000jvfwx9h1uviv9"},{"post_id":"cjg4j8vya0003vfwxdx1s8qcj","category_id":"cjg4j8vyb0004vfwx525bpdkn","_id":"cjg4j8vym000ovfwxoptae6z9"},{"post_id":"cjg4j8vyh000dvfwxs9t8xstm","category_id":"cjg4j8vyb0004vfwx525bpdkn","_id":"cjg4j8vym000qvfwxznzrswxc"},{"post_id":"cjg4j8vyj000hvfwxd05rjys3","category_id":"cjg4j8vyb0004vfwx525bpdkn","_id":"cjg4j8vyo000vvfwx59xf5ebx"},{"post_id":"cjg4j8vyd0006vfwx9erdsspm","category_id":"cjg4j8vyb0004vfwx525bpdkn","_id":"cjg4j8vyp000yvfwxkuiytn7h"},{"post_id":"cjg4j8vym000pvfwxc04mjsd5","category_id":"cjg4j8vyb0004vfwx525bpdkn","_id":"cjg4j8vyq0012vfwxfbvl0a0w"},{"post_id":"cjg4j8vye0007vfwxihd1fasg","category_id":"cjg4j8vyl000lvfwxzinl6pvs","_id":"cjg4j8vyr0014vfwxtlwdfwjk"},{"post_id":"cjg4j8vyn000rvfwxiwjk4au6","category_id":"cjg4j8vyl000lvfwxzinl6pvs","_id":"cjg4j8vys0017vfwx16igjt0o"},{"post_id":"cjg4j8vyo000wvfwxchtafdr5","category_id":"cjg4j8vyl000lvfwxzinl6pvs","_id":"cjg4j8vyt001avfwxohz2azpe"},{"post_id":"cjg4j8vyk000kvfwxk9xp1jyi","category_id":"cjg4j8vyl000lvfwxzinl6pvs","_id":"cjg4j8vyt001dvfwxej3qjgbg"},{"post_id":"cjg4j8vyp000zvfwx8uc555x6","category_id":"cjg4j8vyl000lvfwxzinl6pvs","_id":"cjg4j8vyu001fvfwxenfzhwen"},{"post_id":"cjg4j8vyq0013vfwx04sh26y3","category_id":"cjg4j8vyl000lvfwxzinl6pvs","_id":"cjg4j8vyu001hvfwx3dgk1e02"},{"post_id":"cjg4j8vyr0015vfwxjsryxlbo","category_id":"cjg4j8vyl000lvfwxzinl6pvs","_id":"cjg4j8vyu001kvfwxlqqu3ygj"},{"post_id":"cjg4j8vys0018vfwxj4rjs92j","category_id":"cjg4j8vyl000lvfwxzinl6pvs","_id":"cjg4j8vyv001mvfwxc3kglj30"},{"post_id":"cjg4j8w2m001uvfwx6waeyjwb","category_id":"cjg4j8vyl000lvfwxzinl6pvs","_id":"cjg4j8w2q001zvfwxgutg6cpd"},{"post_id":"cjg4j8w2o001xvfwxfowpog8l","category_id":"cjg4j8vyb0004vfwx525bpdkn","_id":"cjg4j8w2r0022vfwxrt1kalvf"},{"post_id":"cjg4j8w2p001yvfwx93mv8y2l","category_id":"cjg4j8vyb0004vfwx525bpdkn","_id":"cjg4j8w2s0024vfwxwo3fy5su"},{"post_id":"cjg4j8w2l001svfwx3vl9ulj5","category_id":"cjg4j8w2o001vvfwxjuf9vyei","_id":"cjg4j8w2t0027vfwxwz1poh15"},{"post_id":"cjg4j8w2q0020vfwxqtmbtpxd","category_id":"cjg4j8vyb0004vfwx525bpdkn","_id":"cjg4j8w2u0028vfwxljjqimim"},{"post_id":"cjg4j8w2r0023vfwxnmhc1sdx","category_id":"cjg4j8vyb0004vfwx525bpdkn","_id":"cjg4j8w2u002avfwx4w74hcc3"},{"post_id":"cjg4j8w2s0025vfwxdofnl3yk","category_id":"cjg4j8vyb0004vfwx525bpdkn","_id":"cjg4j8w2u002cvfwx6q2ci0nc"}],"PostTag":[{"post_id":"cjg4j8vy90002vfwx0wp4r48z","tag_id":"cjg4j8vyc0005vfwxu7x2zp12","_id":"cjg4j8vyk000ivfwx5in09ck0"},{"post_id":"cjg4j8vy90002vfwx0wp4r48z","tag_id":"cjg4j8vyf000avfwxt6sr4kkd","_id":"cjg4j8vyl000mvfwxojkwaxge"},{"post_id":"cjg4j8vym000pvfwxc04mjsd5","tag_id":"cjg4j8vyc0005vfwxu7x2zp12","_id":"cjg4j8vyo000uvfwxkcxzhz9y"},{"post_id":"cjg4j8vya0003vfwxdx1s8qcj","tag_id":"cjg4j8vyc0005vfwxu7x2zp12","_id":"cjg4j8vyp000xvfwxg8ye8xjh"},{"post_id":"cjg4j8vya0003vfwxdx1s8qcj","tag_id":"cjg4j8vyl000nvfwxau8urjhs","_id":"cjg4j8vyq0011vfwx0goiya9r"},{"post_id":"cjg4j8vyd0006vfwx9erdsspm","tag_id":"cjg4j8vyc0005vfwxu7x2zp12","_id":"cjg4j8vyt0019vfwxc14i4e6w"},{"post_id":"cjg4j8vyd0006vfwx9erdsspm","tag_id":"cjg4j8vyl000nvfwxau8urjhs","_id":"cjg4j8vyt001bvfwxdkwv9093"},{"post_id":"cjg4j8vye0008vfwxku8rvfdb","tag_id":"cjg4j8vyc0005vfwxu7x2zp12","_id":"cjg4j8vyu001evfwx72ln5w53"},{"post_id":"cjg4j8vye0008vfwxku8rvfdb","tag_id":"cjg4j8vyl000nvfwxau8urjhs","_id":"cjg4j8vyu001gvfwxd322a8co"},{"post_id":"cjg4j8vyg000bvfwxmqdb7s2w","tag_id":"cjg4j8vyc0005vfwxu7x2zp12","_id":"cjg4j8vyu001jvfwxihbyc6fn"},{"post_id":"cjg4j8vyg000bvfwxmqdb7s2w","tag_id":"cjg4j8vyt001cvfwxe4qpf1c8","_id":"cjg4j8vyv001lvfwxpwiq2djt"},{"post_id":"cjg4j8vyh000dvfwxs9t8xstm","tag_id":"cjg4j8vyc0005vfwxu7x2zp12","_id":"cjg4j8vyv001ovfwxou0c25v3"},{"post_id":"cjg4j8vyh000dvfwxs9t8xstm","tag_id":"cjg4j8vyu001ivfwxw2q8el93","_id":"cjg4j8vyv001pvfwxxl21hupu"},{"post_id":"cjg4j8vyj000hvfwxd05rjys3","tag_id":"cjg4j8vyc0005vfwxu7x2zp12","_id":"cjg4j8vyv001qvfwxazi8n9ql"},{"post_id":"cjg4j8vyj000hvfwxd05rjys3","tag_id":"cjg4j8vyv001nvfwxij5vltt5","_id":"cjg4j8vyv001rvfwx6hoqumlz"},{"post_id":"cjg4j8w2l001svfwx3vl9ulj5","tag_id":"cjg4j8w2o001wvfwxes2jglfe","_id":"cjg4j8w2u002bvfwx4fygs4az"},{"post_id":"cjg4j8w2l001svfwx3vl9ulj5","tag_id":"cjg4j8w2q0021vfwxqtyb74tz","_id":"cjg4j8w2v002dvfwxxsaziroy"},{"post_id":"cjg4j8w2l001svfwx3vl9ulj5","tag_id":"cjg4j8w2t0026vfwxbu2rin2h","_id":"cjg4j8w2v002fvfwxggdfecsh"},{"post_id":"cjg4j8w2o001xvfwxfowpog8l","tag_id":"cjg4j8vyc0005vfwxu7x2zp12","_id":"cjg4j8w2v002gvfwxyhuht0pp"},{"post_id":"cjg4j8w2o001xvfwxfowpog8l","tag_id":"cjg4j8w2u0029vfwxqh8ncd5y","_id":"cjg4j8w2w002ivfwx7nuu4o9o"},{"post_id":"cjg4j8w2p001yvfwx93mv8y2l","tag_id":"cjg4j8vyc0005vfwxu7x2zp12","_id":"cjg4j8w2w002jvfwxkfzoa9gm"},{"post_id":"cjg4j8w2p001yvfwx93mv8y2l","tag_id":"cjg4j8w2v002evfwx4ptt5ndd","_id":"cjg4j8w2w002lvfwxpsdgnysg"},{"post_id":"cjg4j8w2q0020vfwxqtmbtpxd","tag_id":"cjg4j8vyc0005vfwxu7x2zp12","_id":"cjg4j8w2x002mvfwx2ypp5ep3"},{"post_id":"cjg4j8w2q0020vfwxqtmbtpxd","tag_id":"cjg4j8w2v002hvfwx7sriys3k","_id":"cjg4j8w2x002ovfwx255vml09"},{"post_id":"cjg4j8w2r0023vfwxnmhc1sdx","tag_id":"cjg4j8vyc0005vfwxu7x2zp12","_id":"cjg4j8w2y002pvfwxgbsb6ewf"},{"post_id":"cjg4j8w2r0023vfwxnmhc1sdx","tag_id":"cjg4j8w2v002hvfwx7sriys3k","_id":"cjg4j8w2y002qvfwxyfcm7p3j"},{"post_id":"cjg4j8w2s0025vfwxdofnl3yk","tag_id":"cjg4j8vyc0005vfwxu7x2zp12","_id":"cjg4j8w2y002rvfwxxusvrcxz"},{"post_id":"cjg4j8w2s0025vfwxdofnl3yk","tag_id":"cjg4j8w2v002hvfwx7sriys3k","_id":"cjg4j8w2y002svfwx0ur5yhou"}],"Tag":[{"name":"iOS","_id":"cjg4j8vyc0005vfwxu7x2zp12"},{"name":"命令","_id":"cjg4j8vyf000avfwxt6sr4kkd"},{"name":"clang & llvm","_id":"cjg4j8vyl000nvfwxau8urjhs"},{"name":"Objective-C","_id":"cjg4j8vyt001cvfwxe4qpf1c8"},{"name":"Swift","_id":"cjg4j8vyu001ivfwxw2q8el93"},{"name":"性能优化","_id":"cjg4j8vyv001nvfwxij5vltt5"},{"name":"投资理财","_id":"cjg4j8w2o001wvfwxes2jglfe"},{"name":"基金定投","_id":"cjg4j8w2q0021vfwxqtyb74tz"},{"name":"读后感","_id":"cjg4j8w2t0026vfwxbu2rin2h"},{"name":"Xcode","_id":"cjg4j8w2u0029vfwxqh8ncd5y"},{"name":"架构","_id":"cjg4j8w2v002evfwx4ptt5ndd"},{"name":"翻译","_id":"cjg4j8w2v002hvfwx7sriys3k"}]}}