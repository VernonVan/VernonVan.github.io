<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="iOS,翻译," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="原文链接：https://www.raywenderlich.com/153591/core-text-tutorial-ios-making-magazine-app  
更新说明：本教程已经由Lyndsey Scott升级为Swift 4和Xcode 9。最初的教程由Marin Todorov所创作。
Core Text是一个底层的文本引擎，当与Core Graphics/Quartz框架配合">
<meta property="og:type" content="article">
<meta property="og:title" content="(翻译)iOS的Core Text教程：制作一个杂志应用">
<meta property="og:url" content="http://yoursite.com/2017/07/21/翻译杂志应用/index.html">
<meta property="og:site_name" content="ruanpapa和又吉君写字的地方">
<meta property="og:description" content="原文链接：https://www.raywenderlich.com/153591/core-text-tutorial-ios-making-magazine-app  
更新说明：本教程已经由Lyndsey Scott升级为Swift 4和Xcode 9。最初的教程由Marin Todorov所创作。
Core Text是一个底层的文本引擎，当与Core Graphics/Quartz框架配合">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/698554-57c6d4f3c2df1c38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/698554-e426ca1cea702142.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/698554-bdfec1f8b8817617.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/698554-5febf55f8e6bc993.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/698554-e7418de12cb5ae45.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/698554-6d55091e685937d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/698554-2c69a03c16835494.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/698554-a816139b2aed7b2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/698554-f7c0cd8d0f47a219.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/698554-b14a1b1e5fe27a9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/698554-2f22c94e5dde428a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/698554-b00481e7f05f0bce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/698554-9a01dbec1c6ea94d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2017-10-24T08:21:37.053Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="(翻译)iOS的Core Text教程：制作一个杂志应用">
<meta name="twitter:description" content="原文链接：https://www.raywenderlich.com/153591/core-text-tutorial-ios-making-magazine-app  
更新说明：本教程已经由Lyndsey Scott升级为Swift 4和Xcode 9。最初的教程由Marin Todorov所创作。
Core Text是一个底层的文本引擎，当与Core Graphics/Quartz框架配合">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/698554-57c6d4f3c2df1c38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/07/21/翻译杂志应用/"/>





  <title> (翻译)iOS的Core Text教程：制作一个杂志应用 | ruanpapa和又吉君写字的地方 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">ruanpapa和又吉君写字的地方</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/21/翻译杂志应用/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="ruanpapa & 又吉君">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="ruanpapa和又吉君写字的地方">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="ruanpapa和又吉君写字的地方" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                (翻译)iOS的Core Text教程：制作一个杂志应用
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-21T10:46:34+08:00">
                2017-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ruanpapa-技术贴/" itemprop="url" rel="index">
                    <span itemprop="name">ruanpapa--技术贴</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/07/21/翻译杂志应用/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/07/21/翻译杂志应用/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/07/21/翻译杂志应用/" class="leancloud_visitors" data-flag-title="(翻译)iOS的Core Text教程：制作一个杂志应用">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>原文链接：<a href="https://www.raywenderlich.com/153591/core-text-tutorial-ios-making-magazine-app" target="_blank" rel="external">https://www.raywenderlich.com/153591/core-text-tutorial-ios-making-magazine-app</a>  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/698554-57c6d4f3c2df1c38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="杂志，Core Text和大脑！"><br>更新说明：本教程已经由Lyndsey Scott升级为Swift 4和Xcode 9。最初的教程由Marin Todorov所创作。</p>
<p>Core Text是一个底层的文本引擎，当与Core Graphics/Quartz框架配合使用的时候，可以对布局和格式进行细粒度的控制。</p>
<p>随着iOS 7的发布，Apple公司发布了一个名叫Text Kit的高级库，可以用来储存、布局和显示具有各种排版特征的文本。虽然Text Kit在布局文本时不仅强大而且大部分情况下已经足够用了，但是Core Text可以提供更多的控制。例如，如果你想直接使用Quartz的话，那就请用Core Text吧。如果你需要构建你自己的布局引擎的话，Core Text将会帮助你生成<a href="https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/CoreText_Programming/Introduction/Introduction.html#//apple_ref/doc/uid/TP40005533" target="_blank" rel="external">字形(glyphs)并且根据互相之间的关系摆放好这些字形，并具有好的排版的所有特性</a>。</p>
<p>本教程将会引导你使用Core Text去创作一本非常简单的杂志应用…给僵尸看的！<br>呃，僵尸月刊的读者朋友们已经宽容的答应了，只要你本教程认真使用Core Text的话，就不会吃掉你的大脑了…所以呢，你还是尽快开始吧！</p>
<blockquote>
<p>说明：要充分读懂本教程，你首先需要了解iOS开发的基础。如果你是iOS开发的新人的话，你应该首先查看本网站的<a href="https://www.raywenderlich.com/category/ios" target="_blank" rel="external">其他教程</a>。</p>
</blockquote>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>打开Xcode，用Single View Application模板创建一个新的Swift universal project，命名为CoreTextMagazine。</p>
<p>然后，将Core Text框架加到你的工程中：</p>
<ol>
<li>单击工程导航器中的工程文件(在左边的导航条上)</li>
<li>在”General”按钮下，滚动到底部的”Linked Frameworks and Libraries”</li>
<li>单击”+”按钮然后找到”CoreText”</li>
<li>选中”CoreText.framework”然后点击”Add”按钮。就这么简单！</li>
</ol>
<p>现在工程已经配置好了，是时候开始写代码了。</p>
<h3 id="添加一个Core-Text-View"><a href="#添加一个Core-Text-View" class="headerlink" title="添加一个Core Text View"></a>添加一个Core Text View</h3><p>首先，你将要创建一个自定义的UIView，在这个UIView的draw(_:)方法中将会用到Core Text。</p>
<p>创建一个新的继承于UIView的Cocoa Touch Class file，命名为CTView。打开CTView.swift，然后在 <figure class="highlight plain"><figcaption><span>UIKit ``` 语句下面加上下面的代码：</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">```Objective-C</div><div class="line">import CoreText</div></pre></td></tr></table></figure></p>
<p>然后，将这个自定义的view设置为应用的主视图。打开Main.storyboard，在右边打开Utilities菜单，然后在顶部工具条单击Identity Inspector图标。在Interface Builder的左侧菜单中，选中View。现在在Utilities菜单的Class字段中应该写着UIView。在Class字段输入CTView以子类化主视图控制器的视图，然后点击回车键。<br><img src="http://upload-images.jianshu.io/upload_images/698554-e426ca1cea702142.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>接下来，打开CTView.swift并将被注释掉的draw(_:)方法全都替换成下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//1	 	 </div><div class="line">override func draw(_ rect: CGRect) &#123;	 	 </div><div class="line">  // 2	 	 </div><div class="line">  guard let context = UIGraphicsGetCurrentContext() else &#123; return &#125;	 	 </div><div class="line">  // 3	 	 </div><div class="line">  let path = CGMutablePath()	 	 </div><div class="line">  path.addRect(bounds)	 	 </div><div class="line">  // 4</div><div class="line">  let attrString = NSAttributedString(string: &quot;Hello World&quot;)</div><div class="line">  // 5</div><div class="line">  let framesetter = CTFramesetterCreateWithAttributedString(attrString as CFAttributedString)</div><div class="line">  // 6</div><div class="line">  let frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, attrString.length), path, nil) </div><div class="line">  // 7</div><div class="line">  CTFrameDraw(frame, context)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>让我们一步一步地分析一下代码：</p>
<ol>
<li>在视图创建的时候，draw(_:)会自动运行，渲染这个视图的背景图层。</li>
<li>打开用于绘制的当前图形上下文。</li>
<li>创建一条用来限定绘图区域的路径，在这个例子中就是整个视图的bounds。</li>
<li>在Core Text，使用NSAttributedString而不是String或者NSString，保存文本和属性(attributes)。初始化一个”Hello World”的属性字符串。</li>
<li>CTFramesetterCreateWithAttributedString使用提供的属性字符串创建一个CTFramesetter。CTFramesetter会管理你引用的字体和绘图区域。</li>
<li>通过使CTFramesetterCreateFrame在路径内渲染整个字符串，可以创建一个CTFrame。</li>
<li>CTFrameDraw在给定的上下文中绘制CTFrame。<br>这就是你绘制简单文本所需要做的全部了！Build，运行然后查看结果。<br><img src="http://upload-images.jianshu.io/upload_images/698554-bdfec1f8b8817617.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ol>
<p>噢不…似乎看起来不太对。就像很多的底层API一样，Core Text使用的是Y-flipped坐标系统。更糟糕的是，内容在竖直方向上也翻转了！</p>
<p>添加以下代码到<figure class="highlight plain"><figcaption><span>let context ```语句以修正内容的方向：</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">```Objective-C</div><div class="line">// Flip the coordinate system</div><div class="line">context.textMatrix = .identity</div><div class="line">context.translateBy(x: 0, y: bounds.size.height)</div><div class="line">context.scaleBy(x: 1.0, y: -1.0)</div></pre></td></tr></table></figure></p>
<p>这段代码通过应用变换(transformation)到视图的上下文来将内容翻转。</p>
<p>Build然后运行app。别担心状态栏重叠的问题，你接下来会学到怎样通过约束解决这个问题。<br><img src="http://upload-images.jianshu.io/upload_images/698554-5febf55f8e6bc993.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>祝贺你的第一个Core Text软件！僵尸们很高兴看到你的进步。</p>
<h3 id="Core-Text对象模型"><a href="#Core-Text对象模型" class="headerlink" title="Core Text对象模型"></a>Core Text对象模型</h3><p>如果你对CTFramesetter和CTFrame感到有点疑惑也是正常的，也是时候说明一下它们了。:]<br>Core Text对象模型如下所示：<br><img src="http://upload-images.jianshu.io/upload_images/698554-e7418de12cb5ae45.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>当你提供一个NSAttributedString创建一个CTFramesetter对象实例的时候，一个CTTypesetter的实例对象会自动为你创建用以管理你的字体。接下来你会在渲染文本的时候用到这个CTFramesetter去创建一个或者多个frame。</p>
<p>当你创建了一个frame，你可以为这个frame提供文本的一个subrange去渲染这段文本。Core Text会自动为文本的每一行创建一个CTLine，并为每个具有相同格式的字符创建一个CTRun。举个例子，Core Text只会创建一个CTRun用于同一行中的几个红色的单词，创建一个CTRun用于接下来的纯文本，创建一个CTRun用于粗体段落等等。Core Text创建会根据你提供的NSAttributedString中的属性创建CTRun。此外，上面说到的每一个CTRun对象都可以采用不同的属性，也就是说，你可以很好地控制字距、连字、宽度、高度等。</p>
<h3 id="深入杂志App！"><a href="#深入杂志App！" class="headerlink" title="深入杂志App！"></a>深入杂志App！</h3><p>下载并解压<a href="http://www.raywenderlich.com/downloads/zombieMagMaterials.zip" target="_blank" rel="external">the zombie magazine materials</a>。拖拽解压出来的文件夹到你的Xcode工程中。当弹出对话框时，确保Copy items if needed和Create groups选中。</p>
<p>为了创建这个app，你需要对文本应用各种属性。你将要创建一个用标签设置杂志格式的简单文本标记解析器。</p>
<p>创建一个新的Cocoa Touch Class file，命名为MarkupParser，继承于NSObject。</p>
<p>首先，我们快速看一下zombies.txt。看看它是如何在整个文本中包含括号内的格式化标签的。”img src”标签指向杂志的图片，而”font color/face”标签则确定了文本的颜色和字体。</p>
<p>打开MarkupParser.swift然后将它的内容替换为以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">import UIKit</div><div class="line">import CoreText</div><div class="line"></div><div class="line">class MarkupParser: NSObject &#123;</div><div class="line">  </div><div class="line">  // MARK: - Properties</div><div class="line">  var color: UIColor = .black</div><div class="line">  var fontName: String = &quot;Arial&quot;</div><div class="line">  var attrString: NSMutableAttributedString!</div><div class="line">  var images: [[String: Any]] = []</div><div class="line"></div><div class="line">  // MARK: - Initializers</div><div class="line">  override init() &#123;</div><div class="line">    super.init()</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  // MARK: - Internal</div><div class="line">  func parseMarkup(_ markup: String) &#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你在这段代码中添加了属性持有字体和文本颜色，设置了它们的初始值。创建了一个变量去持有parseMarkup(_:)生成的属性字符串。还创建了一个数组用来持有定义了尺寸、位置以及从文本中解析出来的图片文件名等信息的键值对。</p>
<p>通常来说，写一个解析器并不是一个轻松的工作，但是本教程所实现的解析器将会非常简易，只提供开放标签的支持，也就意味着一个标签会决定紧随着这个标签的文本的样式，直到找到一个新的标签。这段文本的标记如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">These are &lt;font color=&quot;red&quot;&gt;red&lt;font color=&quot;black&quot;&gt; and</div><div class="line">&lt;font color=&quot;blue&quot;&gt;blue &lt;font color=&quot;black&quot;&gt;words.</div></pre></td></tr></table></figure></p>
<p>输出如下所示：<br><img src="http://upload-images.jianshu.io/upload_images/698554-6d55091e685937d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>将以下代码加到 <figure class="highlight plain"><figcaption><span>``` 方法中：</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">```Objective-C</div><div class="line">//1</div><div class="line">attrString = NSMutableAttributedString(string: &quot;&quot;)</div><div class="line">//2 </div><div class="line">do &#123;</div><div class="line">  let regex = try NSRegularExpression(pattern: &quot;(.*?)(&lt;[^&gt;]+&gt;|\\Z)&quot;,</div><div class="line">                                      options: [.caseInsensitive,</div><div class="line">                                                .dotMatchesLineSeparators])</div><div class="line">  //3</div><div class="line">  let chunks = regex.matches(in: markup, </div><div class="line">                             options: NSRegularExpression.MatchingOptions(rawValue: 0), </div><div class="line">                             range: NSRange(location: 0,</div><div class="line">                                            length: markup.characters.count))</div><div class="line">&#125; catch _ &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>attrString初始为空，但是最后会包含解析出来的标记。</li>
<li>这个正则表达式，匹配了紧跟着这些标签的文本块。它就好像在说：“去查看字符串直到你找到一个开头的括号，然后查看字符串直到你找到一个结束的括号（或者文档的末尾）”。</li>
<li>搜索regex匹配到的整个标记范围，然后生成一个NSTextCheckingResult的数组。</li>
</ol>
<blockquote>
<p>想要学习更多有关正则表达式的内容，访问<a href="https://www.raywenderlich.com/86205/nsregularexpression-swift-tutorial" target="_blank" rel="external">NSRegularExpression Tutorial</a>吧。</p>
</blockquote>
<p>现在你已经解析了所有的文本并将所有格式化的标签都放进了chunks中，你要做的就是遍历chunks数组去生成对应的属性字符串。</p>
<p>但在那之前，你是否留意到matches(in:options:range:)方法是如何接受一个NSRange作为参数的吗？在你应用NSRegularExpression到你的标记String的时候会有大量NSRange到Range的转化。Swift已经成为了我们所有人的好帮手，所以它值得帮助。</p>
<p>还是在MarkupParser.swift中，将下面的extension加到文件的最后面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// MARK: - String</div><div class="line">extension String &#123;</div><div class="line">  func range(from range: NSRange) -&gt; Range&lt;String.Index&gt;? &#123;</div><div class="line">    guard let from16 = utf16.index(utf16.startIndex,</div><div class="line">                                   offsetBy: range.location,</div><div class="line">                                   limitedBy: utf16.endIndex),</div><div class="line">      let to16 = utf16.index(from16, offsetBy: range.length, limitedBy: utf16.endIndex),</div><div class="line">      let from = String.Index(from16, within: self),</div><div class="line">      let to = String.Index(to16, within: self) else &#123;</div><div class="line">        return nil</div><div class="line">   &#125;</div><div class="line"></div><div class="line">    return from ..&lt; to</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面这个函数将以NSRange表示的字符串的起止索引转换为了String.UTF16View.Index格式，即UTF-16字符串中的位置(position)集合，然后将每个String.UTF16View.Index格式转换为String.Index格式。String.Index格式在组合时，会生成Swift的范围格式：Range。只要索引是有效的，这个函数就会返回原始NSRange格式对应的Range格式。</p>
<p>现在是时候回头处理文本和标签数组了。<br><img src="http://upload-images.jianshu.io/upload_images/698554-2c69a03c16835494.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在parseMarkup(_:)函数中添加一下代码到 <figure class="highlight plain"><figcaption><span>chunks ``` 到下面(在do循环语句块中)：</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">```Objective-C</div><div class="line">let defaultFont: UIFont = .systemFont(ofSize: UIScreen.main.bounds.size.height / 40)</div><div class="line">//1</div><div class="line">for chunk in chunks &#123;  </div><div class="line">  //2</div><div class="line">  guard let markupRange = markup.range(from: chunk.range) else &#123; continue &#125;</div><div class="line">  //3    </div><div class="line">  let parts = markup.substring(with: markupRange).components(separatedBy: &quot;&lt;&quot;)</div><div class="line">  //4</div><div class="line">  let font = UIFont(name: fontName, size: UIScreen.main.bounds.size.height / 40) ?? defaultFont       </div><div class="line">  //5</div><div class="line">  let attrs = [NSAttributedStringKey.foregroundColor: color, NSAttributedStringKey.font: font] as [NSAttributedStringKey : Any]</div><div class="line">  let text = NSMutableAttributedString(string: parts[0], attributes: attrs)</div><div class="line">  attrString.append(text)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>循环chunks数组。</li>
<li>获取当前NSTextCheckingResult的range，展开Range<string.index>并且只要range存在就继续执行以下的语句块。</string.index></li>
<li>将chunk用”&lt;”分割成几部分。第一部分包含了杂志的文本而第二部分包含了对应的标签(如果标签存在的话)。</li>
<li>用fontName生成字体，现在的默认字体是”Arial”，并且根据设备屏幕创建了字体的大小。假如fontName不能产生有效的UIFont的话，将默认字体设为当前字体。</li>
<li>创建字体格式的字典，将其应用于parts[0]以创建属性字符串，然后将该字符串添加到结果字符串后面。</li>
</ol>
<p>将下面用来处理”font”标签的代码插到attrString.append(text)下面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">// 1</div><div class="line">if parts.count &lt;= 1 &#123;</div><div class="line">  continue</div><div class="line">&#125;</div><div class="line">let tag = parts[1]</div><div class="line">//2</div><div class="line">if tag.hasPrefix(&quot;font&quot;) &#123;</div><div class="line">  let colorRegex = try NSRegularExpression(pattern: &quot;(?&lt;=color=\&quot;)\\w+&quot;, </div><div class="line">                                           options: NSRegularExpression.Options(rawValue: 0))</div><div class="line">  colorRegex.enumerateMatches(in: tag, </div><div class="line">    options: NSRegularExpression.MatchingOptions(rawValue: 0), </div><div class="line">    range: NSMakeRange(0, tag.characters.count)) &#123; (match, _, _) in</div><div class="line">      //3</div><div class="line">      if let match = match,</div><div class="line">        let range = tag.range(from: match.range) &#123;</div><div class="line">          let colorSel = NSSelectorFromString(tag.substring(with:range) + &quot;Color&quot;)</div><div class="line">          color = UIColor.perform(colorSel).takeRetainedValue() as? UIColor ?? .black</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  //5    </div><div class="line">  let faceRegex = try NSRegularExpression(pattern: &quot;(?&lt;=face=\&quot;)[^\&quot;]+&quot;,</div><div class="line">                                          options: NSRegularExpression.Options(rawValue: 0))</div><div class="line">  faceRegex.enumerateMatches(in: tag, </div><div class="line">    options: NSRegularExpression.MatchingOptions(rawValue: 0), </div><div class="line">    range: NSMakeRange(0, tag.characters.count)) &#123; (match, _, _) in</div><div class="line"></div><div class="line">      if let match = match,</div><div class="line">        let range = tag.range(from: match.range) &#123;</div><div class="line">          fontName = tag.substring(with: range)</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125; //end of font parsing</div></pre></td></tr></table></figure></p>
<ol>
<li>如果parts数组元素少于2个，则跳过这个循环语句块。否则的话，将parts的第二部分存为tag。</li>
<li>如果tag以”font”开始则创建一个正则表达式去匹配字体的”color”值，然后用这个正则去枚举匹配到的tag中的”color”值。在这种情况下，只应该有一个匹配到的颜色值。</li>
<li>如果enumerateMatches(in:options:range:using:)函数返回标签的一个有效的match和一个有效的range的话，就去搜索出指示值，接着用这个颜色值生成一个UIColor的selector。执行这个selector所返回得到的color(如果存在的话)会赋值到你的类的color属性上，如果返回的color不存在的话，color属性会被赋值为black。</li>
<li>同样的，创建一个正则表达式去处理文本中字体的”face”值。如果匹配到一个”face”值，则将类的fontName属性设置为匹配的”face”值。</li>
</ol>
<p>干得漂亮！现在parseMarkup(_:)函数已经可以获取文本中的标记并生成一个对应的NSAttributedString了。</p>
<p>现在也是时候把你的app喂给一些僵尸了！我的意思是，喂一些僵尸给你的app… 也就是说，(开始处理)zombies.txt。</p>
<p>事实上，显示出被赋予的内容才是UIView的职责所在，而不是去加载内容。打开CTView.swift然后将下面代码添加到draw(_:)方法之前：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// MARK: - Properties</div><div class="line">var attrString: NSAttributedString!</div><div class="line"></div><div class="line">// MARK: - Internal</div><div class="line">func importAttrString(_ attrString: NSAttributedString) &#123;</div><div class="line">  self.attrString = attrString</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来，将 <figure class="highlight plain"><figcaption><span>attrString = NSAttributedString(string: "Hello World") ``` 从draw(_:)函数中删除。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这段代码中你创建了一个实例变量持有属性字符串和一个函数以便app的其他地方可以设置这个属性字符串。</div><div class="line"></div><div class="line">然后，打开ViewController.swift并将以下代码添加到viewDidLoad()中：</div><div class="line">```Objective-C</div><div class="line">// 1</div><div class="line">guard let file = Bundle.main.path(forResource: &quot;zombies&quot;, ofType: &quot;txt&quot;) else &#123; return &#125;</div><div class="line">  </div><div class="line">do &#123;</div><div class="line">  let text = try String(contentsOfFile: file, encoding: .utf8)</div><div class="line">  // 2</div><div class="line">  let parser = MarkupParser()</div><div class="line">  parser.parseMarkup(text)</div><div class="line">  (view as? CTView)?.importAttrString(parser.attrString)</div><div class="line">&#125; catch _ &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后一步步的过一下这段代码：</p>
<ol>
<li>从zombie.txt文件中加载文本。</li>
<li>创建一个新的解析器，传入文本作为参数，然后将返回的属性字符串赋给ViewController的CTView。</li>
</ol>
<p>Build并且运行这个app！<br><img src="http://upload-images.jianshu.io/upload_images/698554-a816139b2aed7b2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>简直太棒了！归功于这50多行解析代码你可以轻松的用文本文件持有你杂志app的内容了。</p>
<h3 id="基本的杂志布局"><a href="#基本的杂志布局" class="headerlink" title="基本的杂志布局"></a>基本的杂志布局</h3><p>如果你认为僵尸新闻的每月杂志只能全塞在一个可怜的页面中，那么你就错了！幸运的是，Core Text在文本列布局时相当有用，因为CTFrameGetVisibleStringRange可以告诉给定frame的情况下显示多少文本才是合适的。也就是说，你可以创建一列文本，当这一列塞满文本之后，你可以知道并开始新的一列。</p>
<p>就本app而言，你需要先打印出列，然后集列成页，再集页成文。未免冒犯这些亡灵，所以。。。你还是尽快把把你的CTView改成继承于UIScrollView。<br>打开CTView.swift然后将 <figure class="highlight plain"><figcaption><span>CTView ``` 一行改成以下代码：</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">```Objective-C</div><div class="line">class CTView: UIScrollView &#123;</div></pre></td></tr></table></figure></p>
<p>看到了吗，僵尸老爷？现在这个app已经支持永恒不死了！对的，行、滚动以及翻页现在都是可用的了。<br><img src="http://upload-images.jianshu.io/upload_images/698554-f7c0cd8d0f47a219.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>到现在为止，你已经在draw(_:)方法里创建了framesetter和frame了，不过由于你有很多不同格式的文本列，所以最好还是创建一个独立的实例表征所述的文本列。</p>
<p>创建一个新的名为CTColumnView的Cocoa Touch Class file，继承于UIView。<br>打开CTColumnView.swift并添加下列初始代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">import UIKit</div><div class="line">import CoreText</div><div class="line"></div><div class="line">class CTColumnView: UIView &#123;</div><div class="line">  </div><div class="line">  // MARK: - Properties</div><div class="line">  var ctFrame: CTFrame!</div><div class="line">  </div><div class="line">  // MARK: - Initializers</div><div class="line">  required init(coder aDecoder: NSCoder) &#123;</div><div class="line">    super.init(coder: aDecoder)!</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  required init(frame: CGRect, ctframe: CTFrame) &#123;</div><div class="line">    super.init(frame: frame)</div><div class="line">    self.ctFrame = ctframe</div><div class="line">    backgroundColor = .white</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  // MARK: - Life Cycle</div><div class="line">  override func draw(_ rect: CGRect) &#123;</div><div class="line">    guard let context = UIGraphicsGetCurrentContext() else &#123; return &#125;</div><div class="line">      </div><div class="line">    context.textMatrix = .identity</div><div class="line">    context.translateBy(x: 0, y: bounds.size.height)</div><div class="line">    context.scaleBy(x: 1.0, y: -1.0)</div><div class="line">      </div><div class="line">    CTFrameDraw(ctFrame, context)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>跟开始在CTView里做的工作一样，这段代码生成了一个CTFrame。自定义的初始化函数init(frame:ctframe:)设置了：</p>
<ol>
<li>这个视图的frame。</li>
<li>在当前上下文中绘制的CTFrame。</li>
<li>以及将这个视图的背景颜色设置为白色。</li>
</ol>
<p>接下来，创建一个新的swift文件命名为CTSettings.swift，用来持有你的文本列的设置。<br>将CTSettings.swift的内容替换为以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">import UIKit</div><div class="line">import Foundation</div><div class="line"></div><div class="line">class CTSettings &#123;</div><div class="line">  //1</div><div class="line">  // MARK: - Properties</div><div class="line">  let margin: CGFloat = 20</div><div class="line">  var columnsPerPage: CGFloat!</div><div class="line">  var pageRect: CGRect!</div><div class="line">  var columnRect: CGRect!</div><div class="line">  </div><div class="line">  // MARK: - Initializers</div><div class="line">  init() &#123;</div><div class="line">    //2</div><div class="line">    columnsPerPage = UIDevice.current.userInterfaceIdiom == .phone ? 1 : 2</div><div class="line">    //3</div><div class="line">    pageRect = UIScreen.main.bounds.insetBy(dx: margin, dy: margin)</div><div class="line">    //4</div><div class="line">    columnRect = CGRect(x: 0,</div><div class="line">                        y: 0,</div><div class="line">                        width: pageRect.width / columnsPerPage,</div><div class="line">                        height: pageRect.height).insetBy(dx: margin, dy: margin)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>这些属性将用来确定page的约束(在这个教程中约束默认是20)、在每一个页中文本列的数量、包含文本列的每一页的frame以及每一页中的每一个文本列的frame。</li>
<li>由于这本杂志的服务对象是拿着iPhone和iPad的僵尸们，iPad上显示两列，iPhone上显示一列，这样的列数对于任意的屏幕尺寸来说都是适宜的。</li>
<li>用约束的大小计算出来的pageRect去布局页面的边界。</li>
<li>用每一页的文本列数量划分pageRect的宽度并配合约束去计算出columnRect。</li>
</ol>
<p>打开CTView.swift，将文件中的内容整个替换成下列代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">import UIKit</div><div class="line">import CoreText</div><div class="line"></div><div class="line">class CTView: UIScrollView &#123;</div><div class="line"></div><div class="line">  //1</div><div class="line">  func buildFrames(withAttrString attrString: NSAttributedString,</div><div class="line">                   andImages images: [[String: Any]]) &#123;</div><div class="line">    //2</div><div class="line">    isPagingEnabled = true</div><div class="line">    //3</div><div class="line">    let framesetter = CTFramesetterCreateWithAttributedString(attrString as CFAttributedString)</div><div class="line">    //4</div><div class="line">    var pageView = UIView()</div><div class="line">    var textPos = 0</div><div class="line">    var columnIndex: CGFloat = 0</div><div class="line">    var pageIndex: CGFloat = 0</div><div class="line">    let settings = CTSettings()</div><div class="line">    //5</div><div class="line">    while textPos &lt; attrString.length &#123;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>buildFrames(withAttrString:andImages:)函数会创建并添加CTColumnView到滚动视图。</li>
<li>运行滚动视图的翻页行为；也就是说，用户不管什么时候停止滚动，滚动视图都能卡到位置使得同一时间只有一个完整的页面在显示。</li>
<li>CTFramesetter framesetter会为创建的每一列CTFrame提供属性字符串。</li>
<li>UIView pageView会作为每个页面文本列对应的子视图的容器；textPos会持续跟踪接下来的文字；columnIndex会持续跟踪当前列；pageIndex会持续跟踪当前页；同时settings能让你访问app的约束尺寸、每页的列、页的frame和列frame的设置等。</li>
<li>你将要遍历attrString然后逐列布局文本直到当前文本的位置到了最末尾。</li>
</ol>
<p>是时候开始遍历attrString了。把下列代码加进 <figure class="highlight plain"><figcaption><span>textPos < attrString.length &#123; ``` 里面：</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">```Objective-C</div><div class="line">//1</div><div class="line">if columnIndex.truncatingRemainder(dividingBy: settings.columnsPerPage) == 0 &#123;</div><div class="line">  columnIndex = 0</div><div class="line">  pageView = UIView(frame: settings.pageRect.offsetBy(dx: pageIndex * bounds.width, dy: 0))</div><div class="line">  addSubview(pageView)</div><div class="line">  //2</div><div class="line">  pageIndex += 1</div><div class="line">&#125;   </div><div class="line">//3</div><div class="line">let columnXOrigin = pageView.frame.size.width / settings.columnsPerPage</div><div class="line">let columnOffset = columnIndex * columnXOrigin</div><div class="line">let columnFrame = settings.columnRect.offsetBy(dx: columnOffset, dy: 0)</div></pre></td></tr></table></figure></p>
<ol>
<li>如果用每页列数划分的列索引等于0，也就能说明这是所在页的第一列，那么就创建新页视图持有这些列。为了设置这些列的frame，需要获取算好约束的setting. pageRect按照当前页面索引乘以屏幕宽度来对其原点计算偏移量。这样才能在翻页滚动视图内部保证杂志每一页都在前一页的右边。</li>
<li>自增pageIndex。</li>
<li>通过settings.columnsPerPage将pageView的宽度除以第一列的x原点，将该列乘以列索引以获得列偏移量；然后通过采用标准columnRect并通过columnOffset将其x原点偏移来创建当前列的frame。</li>
</ol>
<p>接下来把下列代码加到columnFrame初始化方法的下面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//1   </div><div class="line">let path = CGMutablePath()</div><div class="line">path.addRect(CGRect(origin: .zero, size: columnFrame.size))</div><div class="line">let ctframe = CTFramesetterCreateFrame(framesetter, CFRangeMake(textPos, 0), path, nil)</div><div class="line">//2</div><div class="line">let column = CTColumnView(frame: columnFrame, ctframe: ctframe)</div><div class="line">pageView.addSubview(column)</div><div class="line">//3</div><div class="line">let frameRange = CTFrameGetVisibleStringRange(ctframe)</div><div class="line">textPos += frameRange.length</div><div class="line">//4</div><div class="line">columnIndex += 1</div></pre></td></tr></table></figure></p>
<ol>
<li>创建一个CGMutablePath大小的列，然后从textPos开始在合适的范围内渲染足够多的文本到CTFrame中。</li>
<li>用CGRect类型的columnFrame和CTFrame类型的ctframe创建一个CTColumnView并将这一列加到pageView上。</li>
<li>用CTFrameGetVisibleStringRange(_:)函数计算用列限制的文本的范围，然后用这个计算出来的范围自增textPos的值。</li>
<li>在遍历到下一列之前将column的索引值加1。</li>
</ol>
<p>最后在遍历完成之后设置好滚动视图的size：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">contentSize = CGSize(width: CGFloat(pageIndex) * bounds.size.width,</div><div class="line">                     height: bounds.size.height)</div></pre></td></tr></table></figure></p>
<p>通过将内容大小设置为屏幕宽度乘以页数，僵尸先生现在可以滚动杂志到最后了。</p>
<p>打开ViewController.swift，将原先的下列代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(view as? CTView)?.importAttrString(parser.attrString)</div></pre></td></tr></table></figure></p>
<p>替换为下列代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(view as? CTView)?.buildFrames(withAttrString: parser.attrString, andImages: parser.images)</div></pre></td></tr></table></figure></p>
<p>Build并在iPad上运行应用。检查一下双列布局！在页面间左右拖动试试。看起来棒极了！<br><img src="http://upload-images.jianshu.io/upload_images/698554-b14a1b1e5fe27a9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>你已经有了按列排列且格式化好的文本了，但是你还忘了图片呢。用Core Text绘制图片并不是那么简单，Core Text毕竟是一个文本处理框架，但是呢在你刚刚创建的标记解析器的帮助之下，添加图片也没有那么糟糕。</p>
<h3 id="用Core-Text绘制图片"><a href="#用Core-Text绘制图片" class="headerlink" title="用Core Text绘制图片"></a>用Core Text绘制图片</h3><p>虽然Core Text不能直接绘制图片，但是作为一个布局引擎，它可以为图片留开空间。通过设置为CTRun的delegate，你可以确定CTRun的ascent空间、decent空间和宽度。就像下面这样：<br><img src="http://upload-images.jianshu.io/upload_images/698554-2f22c94e5dde428a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>当Core Text遇到一个设置了CTRunDelegate的CTRun，它就会询问delegate：“我需要留多少空间给这块的数据”。通过在CTRunDelegate中设置这些属性，您可以在文本中给图片留开空位。</p>
<p>首先让(解析器)支持”img”标签。打开MarkupParser.swift然后找到”} //end of font parsing”语句。并将下面代码加到后面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">//1</div><div class="line">else if tag.hasPrefix(&quot;img&quot;) &#123; </div><div class="line">      </div><div class="line">  var filename:String = &quot;&quot;</div><div class="line">  let imageRegex = try NSRegularExpression(pattern: &quot;(?&lt;=src=\&quot;)[^\&quot;]+&quot;,</div><div class="line">                                           options: NSRegularExpression.Options(rawValue: 0))</div><div class="line">  imageRegex.enumerateMatches(in: tag, </div><div class="line">    options: NSRegularExpression.MatchingOptions(rawValue: 0), </div><div class="line">    range: NSMakeRange(0, tag.characters.count)) &#123; (match, _, _) in</div><div class="line"></div><div class="line">    if let match = match,</div><div class="line">      let range = tag.range(from: match.range) &#123;</div><div class="line">        filename = tag.substring(with: range)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  //2</div><div class="line">  let settings = CTSettings()</div><div class="line">  var width: CGFloat = settings.columnRect.width</div><div class="line">  var height: CGFloat = 0</div><div class="line"></div><div class="line">  if let image = UIImage(named: filename) &#123;</div><div class="line">    height = width * (image.size.height / image.size.width)</div><div class="line">    // 3</div><div class="line">    if height &gt; settings.columnRect.height - font.lineHeight &#123;</div><div class="line">      height = settings.columnRect.height - font.lineHeight</div><div class="line">      width = height * (image.size.width / image.size.height)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>如果tag是以”img”开头的话就用正则去查找图片的”src”值，比如图片的filename。</li>
<li>设置图片宽度为列的宽度同时在保证图片宽高比的情况下设置图片高度。</li>
<li>如果图片的高度高过了列的高度就将列的高度设置为图片高度并减少图片的宽度以维持图片的宽高比。</li>
</ol>
<p>接下来，将下面代码加到紧随 <figure class="highlight plain"><figcaption><span>let image ``` 语句块后面的地方：</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">```Objective-C</div><div class="line">//1</div><div class="line">images += [[&quot;width&quot;: NSNumber(value: Float(width)),</div><div class="line">            &quot;height&quot;: NSNumber(value: Float(height)),</div><div class="line">            &quot;filename&quot;: filename,</div><div class="line">            &quot;location&quot;: NSNumber(value: attrString.length)]]</div><div class="line">//2</div><div class="line">struct RunStruct &#123;</div><div class="line">  let ascent: CGFloat</div><div class="line">  let descent: CGFloat</div><div class="line">  let width: CGFloat</div><div class="line">&#125;</div><div class="line"></div><div class="line">let extentBuffer = UnsafeMutablePointer&lt;RunStruct&gt;.allocate(capacity: 1)</div><div class="line">extentBuffer.initialize(to: RunStruct(ascent: height, descent: 0, width: width))</div><div class="line">//3</div><div class="line">var callbacks = CTRunDelegateCallbacks(version: kCTRunDelegateVersion1, dealloc: &#123; (pointer) in</div><div class="line">&#125;, getAscent: &#123; (pointer) -&gt; CGFloat in</div><div class="line">  let d = pointer.assumingMemoryBound(to: RunStruct.self)</div><div class="line">  return d.pointee.ascent</div><div class="line">&#125;, getDescent: &#123; (pointer) -&gt; CGFloat in</div><div class="line">  let d = pointer.assumingMemoryBound(to: RunStruct.self)</div><div class="line">  return d.pointee.descent</div><div class="line">&#125;, getWidth: &#123; (pointer) -&gt; CGFloat in</div><div class="line">  let d = pointer.assumingMemoryBound(to: RunStruct.self)</div><div class="line">  return d.pointee.width</div><div class="line">&#125;)</div><div class="line">//4</div><div class="line">let delegate = CTRunDelegateCreate(&amp;callbacks, extentBuffer)</div><div class="line">//5</div><div class="line">let attrDictionaryDelegate = [(kCTRunDelegateAttributeName as NSAttributedStringKey): (delegate as Any)]              </div><div class="line">attrString.append(NSAttributedString(string: &quot; &quot;, attributes: attrDictionaryDelegate))</div></pre></td></tr></table></figure></p>
<ol>
<li>添加包含图片尺寸、文件名和文本位置的字典到images数组中。</li>
<li>定义RunStruct结构图去持有用来描述空格的属性。然后初始化一个包含RunStruct的指针，这个结构体的ascent等于图片的高度，宽度等于图片的宽度。</li>
<li>创建一个CTRunDelegateCallbacks返回ascent、decent和宽度。</li>
<li>用CTRunDelegateCreate生成一个绑定了callbacks和数据的委托实例。</li>
<li>创建一个包含委托实例的属性字典，然后添加单个空格到attrString末尾，属性字典其实就是用来持有这些占位空格的位置和大小信息的。</li>
</ol>
<p>现在MarkupParser可以处理”img”标签了，你需要调整CTColumnView和CTView去渲染图片。</p>
<p>打开CTColumnView.swift。把下列用来持有列的图片和图片的frame的代码加到 <figure class="highlight plain"><figcaption><span>ctFrame:CTFrame! ```  语句后面：</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">```Objective-C</div><div class="line">var images: [(image: UIImage, frame: CGRect)] = []</div></pre></td></tr></table></figure></p>
<p>再然后就是把下列代码加到draw(_:)函数的后面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for imageData in images &#123;</div><div class="line">  if let image = imageData.image.cgImage &#123;</div><div class="line">    let imgBounds = imageData.frame</div><div class="line">    context.draw(image, in: imgBounds)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这段代码中你遍历了每一张图片然后把图片绘制到上下文它正确的frame内。</p>
<p>然后打开CTView.swift并添加下面这个属性到类的顶部：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// MARK: - Properties</div><div class="line">var imageIndex: Int!</div></pre></td></tr></table></figure></p>
<p>imageIndex会持续追踪当前的图片索引在你绘制CTColumnView时。</p>
<p>接下来，把下面一行代码添加到buildFrames(withAttrString:andImages:)函数上方：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">imageIndex = 0</div></pre></td></tr></table></figure></p>
<p>这标志着images数组的第一个元素。</p>
<p>然后添加下述attachImagesWithFrame(_:ctframe:margin:columnView)函数到buildFrames(withAttrString:andImages:)函数后面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">func attachImagesWithFrame(_ images: [[String: Any]],</div><div class="line">                           ctframe: CTFrame,</div><div class="line">                           margin: CGFloat,</div><div class="line">                           columnView: CTColumnView) &#123;</div><div class="line">  //1</div><div class="line">  let lines = CTFrameGetLines(ctframe) as NSArray</div><div class="line">  //2</div><div class="line">  var origins = [CGPoint](repeating: .zero, count: lines.count)</div><div class="line">  CTFrameGetLineOrigins(ctframe, CFRangeMake(0, 0), &amp;origins)</div><div class="line">  //3</div><div class="line">  var nextImage = images[imageIndex]</div><div class="line">  guard var imgLocation = nextImage[&quot;location&quot;] as? Int else &#123;</div><div class="line">    return</div><div class="line">  &#125;</div><div class="line">  //4</div><div class="line">  for lineIndex in 0..&lt;lines.count &#123;</div><div class="line">    let line = lines[lineIndex] as! CTLine</div><div class="line">    //5</div><div class="line">    if let glyphRuns = CTLineGetGlyphRuns(line) as? [CTRun], </div><div class="line">      let imageFilename = nextImage[&quot;filename&quot;] as? String, </div><div class="line">      let img = UIImage(named: imageFilename)  &#123; </div><div class="line">        for run in glyphRuns &#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>获取一个ctframe的CTLine对象的数组。</li>
<li>用CTFrameGetOrigins去复制ctframe的行初始点坐标到origins数组中。通过设置长度为0的range，CTFrameGetOrigins将知道要遍历整个CTFrame。</li>
<li>设置nextImage以包含当前图像的属性数据。如果nextImage包含图像的位置，请将其展开并继续；否则，早点返回函数。</li>
<li>遍历下一行文本。</li>
<li>如果这一行的字形、文件名和图片文件名都存在的话，则遍历这一行的字形。</li>
</ol>
<p>然后呢，添加下列代码到字形的for-loop语句块中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// 1</div><div class="line">let runRange = CTRunGetStringRange(run)    </div><div class="line">if runRange.location &gt; imgLocation || runRange.location + runRange.length &lt;= imgLocation &#123;</div><div class="line">  continue</div><div class="line">&#125;</div><div class="line">//2</div><div class="line">var imgBounds: CGRect = .zero</div><div class="line">var ascent: CGFloat = 0       </div><div class="line">imgBounds.size.width = CGFloat(CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &amp;ascent, nil, nil))</div><div class="line">imgBounds.size.height = ascent</div><div class="line">//3</div><div class="line">let xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, nil)</div><div class="line">imgBounds.origin.x = origins[lineIndex].x + xOffset </div><div class="line">imgBounds.origin.y = origins[lineIndex].y</div><div class="line">//4</div><div class="line">columnView.images += [(image: img, frame: imgBounds)]</div><div class="line">//5</div><div class="line">imageIndex! += 1</div><div class="line">if imageIndex &lt; images.count &#123;</div><div class="line">  nextImage = images[imageIndex]</div><div class="line">  imgLocation = (nextImage[&quot;location&quot;] as AnyObject).intValue</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>如果当前字形的范围不包含下一个图像，则跳过循环的其余部分。否则，在此渲染图像。</li>
<li>使用CTRunGetTypographicBounds计算图像宽度，并将高度设置为ascent。</li>
<li>用CTLineGetOffsetForStringIndex获取线的x偏移，然后将其添加到imgBounds的起点坐标。</li>
<li>将图像及其frame添加到当前的CTColumnView。</li>
<li>增加图像索引。如果images[imageIndex]是一个图片，则更新nextImage和imgLocation，以便它们引用下一个图像。<br><img src="http://upload-images.jianshu.io/upload_images/698554-b00481e7f05f0bce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ol>
<p>好了！干得漂亮！基本完成，还剩下最后一步。</p>
<p>在buildFrames(withAttrString:andImages:)内部的pageView.addSubview(column)上面添加以下代码用以附加图像(如果图像存在的话)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if images.count &gt; imageIndex &#123;</div><div class="line">  attachImagesWithFrame(images, ctframe: ctframe, margin: settings.margin, columnView: column)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Build并且运行到iPhone和iPad上：<br><img src="http://upload-images.jianshu.io/upload_images/698554-9a01dbec1c6ea94d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>恭喜你！因为感激你所做的这些辛苦的工作，僵尸先生决定不吃你的大脑了！</p>
<h3 id="何去何从"><a href="#何去何从" class="headerlink" title="何去何从"></a>何去何从</h3><p>在<a href="https://koenig-media.raywenderlich.com/uploads/2017/06/CoreTextMagazine-2.zip" target="_blank" rel="external">这里</a>查看完整的项目。</p>
<p>正如介绍中所述，Text Kit通常可以替代Core Text；所以尝试用Text Kit编写同一个教程吧，比较一下两者有什么不同。也就是说，这堂Core Text课程不会白学！<br>Text Kit提供免费桥接(toll free bridging)到Core Text，因此你可以根据你的需要轻松地在框架之间进行转换。</p>
<p>有任何问题，意见或建议？加入论坛讨论吧！</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"># iOS</a>
          
            <a href="/tags/翻译/" rel="tag"># 翻译</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/05/25/ruanpapa和又吉君的日常之六/" rel="next" title="ruanpapa和又吉君的日常之六">
                <i class="fa fa-chevron-left"></i> ruanpapa和又吉君的日常之六
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/09/20/iOS性能优化探讨/" rel="prev" title="iOS性能优化探讨">
                iOS性能优化探讨 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/07/21/翻译杂志应用/"
           data-title="(翻译)iOS的Core Text教程：制作一个杂志应用" data-url="http://yoursite.com/2017/07/21/翻译杂志应用/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="ruanpapa & 又吉君" />
          <p class="site-author-name" itemprop="name">ruanpapa & 又吉君</p>
          <p class="site-description motion-element" itemprop="description">ruanpapa和又吉君写字的地方</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/VernonVan" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#开始"><span class="nav-number">1.</span> <span class="nav-text">开始</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#添加一个Core-Text-View"><span class="nav-number">2.</span> <span class="nav-text">添加一个Core Text View</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Core-Text对象模型"><span class="nav-number">3.</span> <span class="nav-text">Core Text对象模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深入杂志App！"><span class="nav-number">4.</span> <span class="nav-text">深入杂志App！</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本的杂志布局"><span class="nav-number">5.</span> <span class="nav-text">基本的杂志布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用Core-Text绘制图片"><span class="nav-number">6.</span> <span class="nav-text">用Core Text绘制图片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#何去何从"><span class="nav-number">7.</span> <span class="nav-text">何去何从</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ruanpapa & 又吉君</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"vernonvan"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  












  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("fRSRDUvIyCVcsgLOHArGl58q-gzGzoHsz", "0mGpmjuTsGuu9JEKGaU6YX9j");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  


</body>
</html>
